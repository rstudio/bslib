---
title: "Cards"
resource_files:
  - shiny-hex.svg
---

Cards are a common organizing unit for modern user interfaces (UI). At their core, they're just rectangular containers with borders and padding. However, when utilized properly to group related information, they help users better digest, engage, and navigate through content. This is why most successful dashboard/UI frameworks make cards a core feature of their component library. This article provides an overview of the API that bslib provides to create [Bootstrap cards](https://getbootstrap.com/docs/5.0/components/card/).

## Setup code

Since this article is statically hosted and not powered by Shiny, it uses statically rendered [htmlwidgets](http://www.htmlwidgets.org/) like `{plotly}` and `{leaflet}`. Don't worry, `card()`s [work in Shiny equally as well](#shiny). Here's some code to create those widgets:

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, collapse = "#>")

# pkgdown really wants BS5+ markup for tabs, and this is currently the best way to achieving that :(
# (note this isn't a problem for any format based on html_document_base)
shiny:::setCurrentTheme(bslib::bs_theme())
```

```{scss, echo = FALSE}
/* Credit to https://getcssscan.com/css-box-shadow-examples */
.card {
  box-shadow:
    rgba(0, 0, 0, 0.25) 0px 54px 55px, 
    rgba(0, 0, 0, 0.12) 0px -12px 30px, 
    rgba(0, 0, 0, 0.12) 0px 4px 6px, 
    rgba(0, 0, 0, 0.17) 0px 12px 13px, 
    rgba(0, 0, 0, 0.09) 0px -3px 5px;
  margin-bottom: 3rem;
}

.bslib-grid-layout .card {
  box-shadow: none;
  margin-bottom: 0rem;
}

.bslib-value-box.card {
  box-shadow: none;
  margin-bottom: 0rem;
  color: white !important;
}

.section.level2 {
  margin-top: 5rem;
}
```

```{r ref.label="anim_helpers",echo=FALSE}
```


```{r}
library(bslib)
library(shiny)
library(htmltools)
library(plotly)
library(leaflet)

plotly_widget <- plot_ly(x = diamonds$cut) %>%
  config(displayModeBar = FALSE) %>%
  layout(margin = list(t = 0, b = 0, l = 0, r = 0))

leaflet_widget <- leaflet() %>%
  addTiles()
```


## Hello `card()`

::: row
::: col-md-6
A `card()` is designed to handle any number of "known" card items (e.g., `card_header()`, `card_body()`, etc) as unnamed arguments (i.e., children). As we'll see shortly, `card()` also has some useful named arguments (e.g., `full_screen`, `height`, etc).

At their core, `card()` and card items are just an HTML `div()` with a special Bootstrap class, so you can use Bootstrap's utility classes to customize things like [colors](https://getbootstrap.com/docs/5.2/utilities/background/), [text](https://getbootstrap.com/docs/5.2/utilities/text/), [borders](https://getbootstrap.com/docs/5.2/utilities/borders), etc.
:::

::: col-md-6
```{r}
card(
  card_header(
    class = "bg-dark",
    "A header"
  ),
  card_body(
    markdown("Some text with a [link](https://github.com)")
  )
)
```
:::
:::

## Implicit `card_body()`

::: row
::: col-md-6
If you find yourself using `card_body()` without changing any of its defaults, consider dropping it altogether since any direct children of `card()` that aren't "known" `card()` items, are wrapped together into an implicit `card_body()` call.[^1] For example, the code to the right generates HTML that is identical to the previous example:
:::

[^1]: If you want to customize this behavior, you can provide a function function to `wrapper` argument (or set it to `NULL` to avoid wrapping the non card items in a container).

::: col-md-6
```{r}
card(
  card_header(
    class = "bg-dark",
    "A header"
  ),
  markdown("Some text with a [link](https://github.com).")
)
```
:::
:::

## Restricting growth

::: row
::: col-md-6
By default, a `card()`'s size grows to accommodate the size of it's contents. Thus, if a `card_body()` contains a large amount of text, tables, etc., you may want to specify a `height` or `max_height`. That said, when laying out [multiple cards](#multiple-cards), you probably shouldn't constrain the height on the card-level. Instead, the height should probably come from a containing element, like `layout_column_wrap()`.

Although scrolling is convenient for reducing the amount of space required to park lots of content, it can also be a nuisance to the user. To help reduce the need for scrolling, consider pairing scrolling with `full_screen = TRUE` (which adds an icon to expand the card's size to the browser window). Notice how, when the card is expanded to full-screen, `max_height`/`height` won't effect the full-screen size of the card. 
:::

::: col-md-6
```{r}
card(
  max_height = 250,
  full_screen = TRUE,
  card_header(
    "A long, scrolling, description"
  ),
  lorem::ipsum(paragraphs = 3, sentences = 5),
  card_footer(
    class = "fs-6",
    "Copyright 2023 RStudio, PBC"
  )
)
```
:::
:::


## Filling outputs

::: row
::: col-md-6
A `card()`'s default behavior is optimized for facilitating [filling layouts](filling.html). For example, if **fill item**(s), like `plotly_widget`, appear as _direct children_ of the card (or a `card_body()`), they grow/shrink in size to fit their `card_body()` container.

:::

::: col-md-6
```{r}
card(
  max_height = 250, 
  full_screen = TRUE,
  card_header("A filling plot"),
  plotly_widget
)
```
:::
:::


::: row
::: col-md-6
Although most outputs (e.g., `shiny::plotOutput()`, etc.) are **fill items**, most other UI elements (e.g., `shiny::div()`) are not, so wrapping an output container in additional `shiny::div()` (which something like `shiny::uiOutput()` does implicitly) breaks filling behavior. In this case, you can leverage `as_fill_carrier()` to "carry" the potential to fill from the `card()` down to the relevant contents.
:::

::: col-md-6
```{r}
is_fill(plotly_widget)
is_fill(uiOutput("some_output"))

card(
  max_height = 250, 
  full_screen = TRUE,
  card_header("A filling plot"),
  uiOutput("some_output") |>
    as_fill_carrier()
)
```
:::
:::


::: row
::: col-md-6
Beware that, by default, there are no limits to how large or small **fill item**(s) may become, so 

:::

::: col-md-6
```{r}
card(
  max_height = 300, 
  full_screen = TRUE,
  card_header("A filling plot"),
  plotly_widget,
  plotly_widget
)
```
:::
:::

::: {.callout .callout-warning}
<h3 data-toc-skip>What's a fill item?</h3>

 See the [article on filling](filling.html) to learn more.
:::


## Multiple `card_body()`

::: {.row .mt-3}
::: col-md-6
A `card()` can have multiple `card_body()`s, which is especially useful for putting different grow/shrink limits on different sections of the body. For example, if we had lots of paragraphs

1. For combining both filling and scrolling contents (as shown on the example).
2. For having multiple rows of filling outputs, each with their own restrictions on the min/max height, etc.

Note that, when combining filling (i.e., ``)
:::

::: col-md-6
```{r}
card(
  max_height = 300, 
  full_screen = TRUE,
  card_header(
    "A filling plot and scrolling description"
  ),
  card_body(
    min_height = 150,
    plotly_widget
  ),
  lorem::ipsum(paragraphs = 10, sentences = 5)
)
```
:::
:::


## Multiple columns

::: row
::: col-md-6
Leverage `layout_column_wrap()` for multiple columns that still support [filling outputs](#filling-outputs) within a card (which can also be used to layout [multiple cards](#multiple-cards)), especially if the height of those columns should grow/shrink as needed.
:::

::: col-md-6
```{r}
card(
  max_height = 300, 
  full_screen = TRUE,
  card_header("A multi-column filling layout"),
  card_body(
    min_height = 150,
    layout_column_wrap(
      width = 1/2,
      plotOutput("p1"),
      plotOutput("p2")
    )
  ),
  lorem::ipsum(paragraphs = 3, sentences = 5)
)
```
:::
:::

## Sidebars

::: row
::: col-md-6

:::

::: col-md-6
```{r}
card(
  max_height = 300, 
  full_screen = TRUE,
  card_header("A card-based sidebar layout"),
  layout_sidebar(
    fillable = TRUE,
    sidebar(
      width = 100,
      actionButton("btn", "A button")
    ),
    plotly_widget
  )
)
```
:::
:::



## Flexbox

::: {.row .mt-3}
::: col-md-6
`card_body()` is a CSS [flexbox container](https://css-tricks.com/snippets/css/a-guide-to-flexbox/) by default, which is a great for enabling [filling output](#filling-output), but does lead to surprising behavior with things like inline tags (e.g., `shiny::actionButton()`, `shiny::span()`, etc). In this case, consider setting `fillable = FALSE` to get the typical layout experience. Also, for textual content, consider using `shiny::markdown()` (or `shiny::includeMarkdown()`), which effectively yields the same result regardless of `fillable`[^markdown]. 
:::

[^markdown]: This is essentially because each paragraph gets wrapped in a `<p>` tag, which means the children of the `<p>` tag won't be treated as flex items. 

::: col-md-6
```{r}
card(
  "Here's some", tags$i("inline"), "text",
  actionButton("btn1", "A button"),
  card_body(fillable = FALSE,
    "Here's some", tags$i("inline"), "text"
  ),
  markdown("Here's some _inline_ text"),
  card_body(fillable = FALSE,
    actionButton("btn2", "A button")
  )
)
```
:::
:::


::: {.row .mt-3}
::: col-md-6
Keep in mind though, sometimes the `fillable = TRUE` behavior of stretching each inline element horizontally can be pretty useful. Say, for example, making a button full-width below some filling output. Also, if you're willing to spend some time learning [flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/), it makes some spacing and alignment issues much easier to address. Say, for example, centering an `actionLink()` (done here with Bootstrap's [flex utility classes](https://getbootstrap.com/docs/5.3/utilities/flex/)):
:::

::: col-md-6
```{r}
card(
  height = 250, full_screen = TRUE,
  card_header("A plot with an action links"),
  card_body(
    plotly_widget,
    actionButton(
      "go_btn", "Action button", 
      class = "btn-primary rounded-0"
    ),
    actionLink(
      "go", "Action link", 
      class = "link-primary align-self-center py-1"
    )
  )
)
```
:::
:::


## Spacing & alignment

::: row
::: col-md-6
Both `card_body()` and `card_body_fillable()` include padding between their contents and the `card()` container by default. In either case, you can override those defaults with Bootstrap's [spacing utility classes](https://getbootstrap.com/docs/5.2/utilities/spacing/), like applying `"p-0"` to remove the padding altogether. This is especially useful if

1. The content itself already provides sufficient padding. 
2. The content's background color is different from the card.[^2]
:::

[^2]: There are other ways to workaround this problem other than removing padding. For example, you could set the [`card-bg` theming variable](bs5-variables.html) and/or use something like the `{thematic}` package to more generally ensure the plot styles match the card's styles.

::: col-md-6
```{r}
card(
  height = 250, full_screen = TRUE,
  card_header("A filling plot (with no padding)"),
  card_body(
    class = "p-0",
    plotOutput("id")
  )
)
```
:::
:::



::: row
::: col-md-6
Not only are utility classes useful to help with spacing and alignment of stuff _within_ a `card_body()` (or `card_body_fillable()`), but they also enable easy customization of [colors](https://getbootstrap.com/docs/5.3/utilities/colors/), [fonts](https://getbootstrap.com/docs/5.3/utilities/text/), and [more](https://getbootstrap.com/docs/5.3/utilities/).
:::

::: col-md-6
```{r}
card(
  card_title("A title"),
  p(class = "text-muted", "Paragraph 1"),
  p(class = "text-end", "Paragraph 2"),
  div(
    class = "p-5 bg-secondary text-center",
    span("Inline comment")
  )
)
```
:::
:::


::: row
::: col-md-6
In the case of `card_body_fillable()`, since it's based on [CSS flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/), you can add uniform spacing between children via the `gap` argument. Note there is a similar way to space between [multiple columns](#multiple-columns).
:::

::: col-md-6
```{r}
card(
  card_body(
    gap = "1rem", class = "p-3",
    div(class = "bg-secondary", "Thing 1"),
    div(class = "bg-secondary", "Thing 2"),
    div(class = "bg-secondary", "Thing 3")
  )
)
```
:::
:::

::: row
::: col-md-6
Again, thanks to CSS flexbox, if the contents of a `card_body_fillable()` aren't full width, you can pretty easily horizontally center them via [flex utility classes](https://getbootstrap.com/docs/5.2/utilities/flex/) (note that you could handle similar alignment issues with `card_body()` by making it a flexbox container with `card_body(class = "d-flex")`.
:::

::: col-md-6
```{r}
card(
  height = 150, full_screen = TRUE,
  card_body(
    class = "p-3 align-items-center",
    plotOutput("id", width = "50%")
  )
)
```
:::
:::

## Shiny

::: row
::: col-md-6
Since this article is statically rendered, the examples here use statically rendered content/widgets, but the same `card()` functionality works for dynamically rendered content via Shiny (e.g., `shiny::plotOutput()`, `plotly::plotlyOutput()`, etc).

One neat thing about dynamic rendering is that you can leverage `shiny::getCurrentOutputInfo()` to render content differently depending on the height of its container, which is particularly useful with `card(full_screen = T, ...)`. For example, you may want additional captions/labels when a plot is large, additional controls on a table, etc (see the [value boxes](value-boxes.html) article for a clever use of this).
:::

::: col-md-6
```{r, message=FALSE, eval=FALSE}
# UI logic
ui <- page_fluid(
  card(
    max_height = 200,
    full_screen = TRUE,
    card_header("A dynamically rendered plot"),
    plotOutput("plot_id")
  )
)

# Server logic
server <- function(input, output, session) {
  output$plot_id <- renderPlot({
    info <- getCurrentOutputInfo()
    if (info$height() > 600) {
      # code for "large" plot
    } else {
      # code for "small" plot
    }
  })
}

shinyApp(ui, server)
```
:::
:::

## Static images

::: row
::: col-md-6
`card_image()` makes it easy to embed static (i.e., pre-generated) images into a card. Provide a URL to `href` to make it clickable. In the case of multiple `card_image()`s, consider laying them out in [multiple cards](#multiple-cards) with `layout_column_wrap()` to produce a grid of clickable thumbnails.
:::

::: col-md-6
```{r}
card(
  height = 300, full_screen = TRUE,
  card_image(
    file = "shiny-hex.svg",
    href = "https://github.com/rstudio/shiny"
  ),
  card_title("Shiny for R"),
  card_body(
    class = "pt-0 fs-6 lead text-muted", 
    "Brought to you by RStudio."
  )
)
```
:::
:::


## Multiple tabs

::: row
::: col-md-6
`navs_tab_card()` and `navs_pill_card()` make it easy to create cards with multiple tabs or pills. These functions have the same `full_screen` capabilities as normal `card()`s as well some other options like `title` (since there is no natural place for a `card_header()` to be used). Note that, similar to `card()`, the children of each `nav()` panel will be implicitly wrapped in a `card_body()` call, and so, the children of each `nav()` are rendered as [flex items](#flexbox). To avoid this, wrap those children in an explicit `card_body(fillable = FALSE, ...)`, as done here:
:::


::: col-md-6
```{r}
library(leaflet)
navs_tab_card(
  height = 300, full_screen = TRUE,
  title = "HTML Widgets",
  nav(
    "Plotly", 
    card_title("A plotly plot", class = "pt-1"),
    plotly_widget
  ),
  nav(
    "Leaflet",
    card_title("A leaflet plot", class = "pt-1"),
    leaflet_widget
  ),
  nav(
    shiny::icon("circle-info"),
    card_body(
      fillable = FALSE,
      "Learn more about",
      tags$a("htmlwidgets", href = "http://www.htmlwidgets.org/")
    )
  )
)
```
:::
:::





## Multiple cards

See the article on layout, specifically the [section on `layout_column_wrap()`](layouts.html#layout_column_wrap) to learn about useful ways to layout multiple cards.

## Appendix

The following CSS is used to give `plotOutput()` a background color; it's necessary here because this documentation page is not actually hooked up to a Shiny app, so we can't show a real plot.

```{css}
.shiny-plot-output, .shiny-html-output {
  background-color: #216B7288;
  height: 400px;
  width: 100%;
}
```
