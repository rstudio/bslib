---
title: "Sidebars"
output:
  html_document:
    theme:
      version: 5
resource_files:
  - infobox.svg
  - examples/sidebars
---

```{r setup, include=FALSE}
library(knitr)
library(htmltools)
library(bslib)

opts_chunk$set(message = FALSE)

render_as_iframe <- function(x, options, ...) {
  lbl <- opts_current$get("label")
  doc_name <- sub("[.]Rmd", "", knitr::current_input())
  lbl_dir <- file.path("examples", doc_name, lbl)
  if (!dir.exists(lbl_dir)) {
    dir.create(lbl_dir, recursive = TRUE)
  }
  file <- file.path(lbl_dir, paste0(lbl, ".html"))
  x <- tagList(x, tags$head(tags$style(".plotly { height: 250px !important; } .modebar-container { display: none; }")))
  tryCatch(
    save_html(x, file),
    error = function(e) {
      stop("Don't know how to render ", class(x)[[1]], " as an <iframe>")
    }
  )
  include_url(file)
}

knitr::opts_hooks$set(as_iframe = function(opts) {
  opts$render <- render_as_iframe
  opts$out.width <- "100%"
  opts$out.extra <- paste0(
    'height=600px seamless="seamless" frameBorder="0" loading="lazy"',
    if (isFALSE(opts$scrolling)) ' scrolling="no"',
    if (isTRUE(opts$resizable)) ' class="resizable"'
  )
  opts
})

# pkgdown really wants BS5+ markup for tabs, and this is currently the best way to achieving that :(
# (note this isn't a problem for any format based on html_document_base)
shiny:::setCurrentTheme(bslib::bs_theme())

# Each time we source this file, it'll give us a new crosstalk controls/views that use a different crosstalk group (this way, interactions won't be shared across chunks)
knitr::read_chunk(
  rprojroot::find_package_root_file("vignettes/sidebar-create-contents.R")
)

describe_layout_function <- function(name, description, element = NULL) {
  name <- knitr::combine_words(sprintf("<code>%s</code>", name),  and = " or ")

  if (is.null(element)) {
    element <- card_body_fillable(
      class = "d-flex flex-column align-items-center",
      div(style = "width: 6em; height: 6em; background-color: gray")
    )
  }

  card(
    card_header(class = "bg-info", HTML(name)),
    element,
    card_footer(class = "bg-white", description)
  )
}
```

```{scss, echo = FALSE}
.plotly {
  height: 250px !important;
  .modebar-container {
    display: none;
  }
}
.html-widget {
  margin-bottom: 0;
}
iframe, .bslib-page-fill {
  height: 450px;
  border: var(--bs-border-width) solid var(--bs-border-color);
  margin-bottom: 4rem;
  box-shadow:
    rgba(0, 0, 0, 0.25) 0px 54px 55px,
    rgba(0, 0, 0, 0.12) 0px -12px 30px,
    rgba(0, 0, 0, 0.12) 0px 4px 6px,
    rgba(0, 0, 0, 0.17) 0px 12px 13px,
    rgba(0, 0, 0, 0.09) 0px -3px 5px;
}

iframe {
  margin-bottom: calc(55px + 2rem);
}

iframe.resizable {
  resize: vertical;
  min-height: 200px;
}

.card-header.bg-info code {
  background: none;
  color: hsl(209deg, 85%, 25%);
}
```

::: lead
Sidebar layouts in web interfaces allow your users to easily access filters, settings and other inputs alongside the interactive features they control.
In this article, you'll learn how to create sidebar layouts with bslib.
:::

## Introduction

There are two main ways to create a sidebar layout: an **individual** or **shared** sidebar layout. In either case, you'll start by creating a `sidebar()` object and end up with a collapsible sidebar layout.

:::: {.row}
::: {.col-sm-12 .col-lg-6}
### Individual Sidebar

All [individual sidebar layouts](#individual) start by providing a `sidebar()` object to `layout_sidebar()`. The resulting `layout_sidebar()` can then be placed inside any page context (e.g., `page_fillable()`, `page_fixed()`, etc) including _within_ individual pages/tabs (e.g., `page_navbar()` `navs_tab_card()`). They also integrate nicely with [cards](#cards) to enable headers, footer, full screen expansion, and more.
:::

::: {.col-sm-12 .col-lg-6 .text-center .mt-2 .mt-lg-4}
```{r preview-layout-sidebar, echo = FALSE}
describe_layout_function(
  "layout_sidebar()",
  "A flexible, local sidebar layout.",
  card_body_fillable(
    class = "p-2",
    height = 200,
    layout_sidebar(
      sidebar = sidebar("Local sidebar", width = "33%", class = "bg-light"),
      "Content with a sidebar"
    ) |> 
      tagAppendAttributes(class = "border rounded-top")
  )
)
```
:::
::::


:::: {.row}
::: {.col-sm-12 .col-lg-6}
### Shared Sidebar

Provide a `sidebar()` object to the `sidebar` argument of `page_navbar()`, `navs_tab_card()`, or `navs_pill_card()` to create a shared sidebar layout. In this case, that sidebar is visible on every page/tab, and the sidebar layout container fills the page/card.
:::

::: {.col-sm-12 .col-lg-6 .text-center .mt-2 .mt-lg-4}
```{r preview-page-navbar, echo = FALSE}
describe_layout_function(
  "page_navbar()",
  "A shared sidebar in a multi-page layout.",
  card_body_fillable(
    class = "p-0",
    height = 200,
    id = "page_navbar_example_card",
    navs_bar(
      collapsible = FALSE,
      fillable = TRUE,
      sidebar = sidebar("Shared sidebar", width = "33%", class = "bg-light"),
      nav("Page 1", "Page 1 content"),
      nav("Page 2", "Page 2 content")
    ),
    tags$script(HTML("$(document).ready(function() {
      // pkgdown activates headroom on the navs_bar() container and ends up
      // auto-hiding our navbar, so this destroys the unwanted headroom instance
      var demo_nav = $('#page_navbar_example_card nav.navbar');
      setTimeout(function() {
        if (demo_nav.headroom) demo_nav.headroom('destroy')
      }, 100);
    });"))
  ) |>
  tagAppendAttributes(class = "flex-row", .cssSelector = ".navbar-nav") |>
  tagAppendAttributes(class = "d-none", .cssSelector = ".navbar-header") |>
  tagAppendAttributes(class = "navbar-dark", .cssSelector = "nav")
)
```

```{r preview-navs-tab-card, echo = FALSE}
describe_layout_function(
  c("navs_tab_card()", "navs_pill_card()"),
  "A shared sidebar for tabs within a card.",
  card_body_fillable(
    class = "p-2",
    height = 200,
    navs_tab_card(
      title = "Tab Card",
      sidebar = sidebar("Shared sidebar", width = "33%", class = "bg-light"),
      nav("Tab 1", "Tab 1 content"),
      nav("Tab 2", "Tab 2 content")
    )
  )
)
```
:::
::::


::: {.callout .callout-warning}
<h3 data-toc-skip>Prefer individual sidebars</h3>

Although [shared sidebars](#shared-sidebar) have been popularized by packages like [shinydashboard](http://rstudio.github.io/shinydashboard/), they're not always ideal for creating a good user experience.

As a general rule, sidebars work best when their controls are grouped closely with the contents they affect, which can be done more effectively with [individual sidebars](#individual).

Note that choosing a individual sidebar layout won't prevent the sidebar controls from affecting outputs elsewhere in the UI.
It's your job as the app developer to choose where the controls appear and to ensure a good user experience.
:::

## Setup

In this article, we'll explore the flexibility of bslib's sidebar layouts by showing many variations of the same inputs and outputs to filter and visualize diamond quality data[^diamonds].

In a Shiny app[^1], you'll probably want to use inputs like `shiny::selectInput()`, `shiny::sliderInput()`, etc., in the sidebar, but because you're reading this article in a static website, we'll use [crosstalk](https://rstudio.github.io/crosstalk/) input widgets.

[^diamonds]: The diamonds in our data set are a 1,000 rows randomly sampled from `ggplot2::diamonds`.
[^1]: In a Shiny app, we also recommend you add an `id` to the `sidebar()` so that you can reactively read/update whether the sidebar is open/closed.

```{r, sidebar-create-contents}
```

::: {.callout .callout-warning}
<h3 data-toc-skip>Resizable examples</h3>

Example containers in this article are resizable, allowing you to examine how the filling/non-filling behavior changes with the "window" size.
:::

## Individual

This section covers individual sidebar layouts (i.e., `layout_sidebar()`) and its integration with `card()`s and filling layouts.

### Standalone {#individual-standalone}

By default, `layout_sidebar()` provides borders and padding around it's content, so that the sidebar controls and the main content that it affects are visually grouped together. This is a great option if you have input controls that are specific to a sub-region of the page. 

```{r, as_iframe = TRUE, resizable = TRUE}
hello_sidebar <- layout_sidebar(
  sidebar = sidebar(
    width = 150,
    filter_cut, 
    filter_clarity, 
  ),
  plot_price
)

unrelated_map <- card(
  class = "mt-3",
  card_header("An unrelated map"),
  map_quakes
)

page_fixed(hello_sidebar, unrelated_map)
```

### Cards {#individual-cards}

`layout_sidebar()` can also be provided as a child to `card()`, which is convenient for adding headers, footers, full-screen behavior, and more. Also be aware that, just like [cards](cards.html), `layout_sidebar()` grows with the size of it's contents, so you may want to add a `max_height` to prevent the card/sidebar-layout from growing too large.

```{r, as_iframe = TRUE, resizable = TRUE}
card_sidebar <- card(
  full_screen = TRUE,
  max_height = 350,
  card_header("Filtering diamonds"),
  layout_sidebar(
    sidebar = sidebar(
      width = 150,
      filter_cut, 
      filter_clarity, 
    ),
    "Scroll for more ðŸ‘‡",
    plot_price,
    plot_carat
  )
)

unrelated_map <- card(
  class = "mt-3",
  card_header("An unrelated map"),
  map_quakes
)

page_fixed(card_sidebar, unrelated_map)
```

::: {.callout .callout-warning}
<h3 data-toc-skip>Multiple tabs in a card</h3>
  
:::

### Filling {#individual-filling}

`layout_sidebar()` is considered a fill item (by default), which means, when it appears of a fillable container with an opinionated height (e.g., `page_fillable()` which sets it's height to `100%` of the browser window), then it'll grow/shrink to fit that container.

::: {.callout .callout-warning}
<h3 data-toc-skip>Prefer standalone sidebars</h3>

A `layout_sidebar()` that fills the page may not be an optimal design if sidebar control(s) affect only particular sub-regions of the main content area. In that case, you may want to place the control(s) closer to the regions they affect (by using an approach like those presented above).
:::

```{r, as_iframe = TRUE, resizable = TRUE}
page_fillable(
  padding = 0, 
  layout_sidebar(
    border_radius = FALSE,
    sidebar(
      bg = "#F1F3F5",
      filter_cut, 
      filter_clarity
    ),
    plot_price,
    plot_carat
  )
)
```

If the main content portion should also allow it's contents to fill, set `fillable = TRUE`.

```{r, as_iframe = TRUE, resizable = TRUE}
page_fillable(
  padding = 0, 
  layout_sidebar(
    fillable = TRUE,
    border_radius = FALSE,
    sidebar(filter_cut, filter_clarity, bg = "#F1F3F5"),
    plot_price,
    plot_carat
  )
)
```


::: {.callout .callout-warning}
<h3 data-toc-skip>Filling layouts</h3>

The plots above fill the main content area because they are also fill items. To learn more, filling layouts see [this article](https://rstudio.github.io/bslib/articles/filling.html).
:::


## Shared

This section covers shared sidebar layouts, meaning that a singular `sidebar()` object is displayed across multiple pages (or tabs).

### Multiple pages

Pass a `sidebar()` to `page_navbar()`'s `sidebar` argument to create a multi-page app with a shared sidebar. Note that, in this example, the sidebar controls affect every output on every page. If, instead, some controls only affect certain pages, consider using `shiny::conditionalPanel()` to hide/show controls on certain pages (see [this section](#dynamic-sidebar) for an example).

```{r, as_iframe = TRUE, resizable = TRUE}
page_navbar(
  title = "Shared sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

Similar to how you can set `fillable = TRUE` in `layout_sidebar()` to allow the main contents to fill their container in [individual sidebar layouts](#individual-filling), setting `page_navbar()`'s `fillable` to `TRUE` does effectively the same thing. It's also possible to make particular pages `fillable` by providing a suitable value (e.g., `fillable = "Page 1"`).

```{r, as_iframe = TRUE}
page_navbar(
  title = "Shared sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  fillable = TRUE,
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```



### Multiple tabs

Pass a `sidebar()` to `navs_tab_card()`'s (or `navs_pill_card()`'s) `sidebar` argument to create a card with multiple tabs and a shared sidebar. The interface is quite similar to `page_navbar()`, but since `navs_tab_card()` is based on the [card API](cards.html), in order to make the contents fillable, you'll need to wrap each tab in `card_body_fillable`:

```{r}
navs_tab_card(
  title = "Shared sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  full_screen = TRUE,
  height = 400,
  wrapper = card_body_fillable,
  nav("Tab 1", plot_price, plot_carat),
  nav("Tab 2", plot_depth)
)
```


<!--
## Foundations

Let's start with the most common sidebar layout: a page-level sidebar.
With bslib, `page_navbar()` provides a modern version of `shiny::navbarPage()` to create a "multi-page app"[^2].
`page_navbar()` not only defaults to a modern version of Bootstrap, but also includes a `sidebar` argument to let you add a shared sidebar to all pages.

[^2]: These functions don't actually make what web developers would consider a  multi-page app since they don't actually request different HTML pages (they are based on Bootstrap nav components).

### Shared sidebar {#shared-sidebar}

To show the same `sidebar()` on every page -- i.e. a _shared_ or _global_ sidebar  --- pass a `sidebar()` to the `sidebar` argument of `page_navbar()`:

```{r navbar-global, as_iframe = TRUE}
page_navbar(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

Try changing the filter selections while switching between Page 1 and Page 2.
The changes you make to the filters while looking at one page are also used to update the plots on other page(s).
This is a good use of a shared sidebar because the same inputs control all plots in the shared container, which in this case is the pages of the app.

### Local sidebar {#local-sidebar}

When your inputs aren't shared across outputs in your app or page, you can create a _local sidebar_ with `layout_sidebar()`[^dynamic-sidebar].
Place a `layout_sidebar()` inside a `nav()` container to create a sidebar adjacent to the content items included in your `layout_sidebar()`.
In the example below, we used a sidebar layout for the filter controls for the plot on Page 1 without including these inputs next to the unrelated map on Page 2.

[^dynamic-sidebar]: If **some** of your inputs overlap across pages in your Shiny app, you can use `conditionalPanel()` to create a [dynamic sidebar](#dynamic-sidebar) with inputs that appear only on certain pages.

```{r navbar-local-scroll, as_iframe = TRUE, scrolling = TRUE}
page_navbar(
  title = "Local sidebar",
  fluid = FALSE,
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity, width = 175),
      plot_price,
      plot_carat
    ),
    h3("More content in page 1...")
  ),
  nav("Page 2", map_quakes)
)
```

Notice that `layout_sidebar()` includes a border by default and doesn't fill its parent page container.
In fact, there is content on Page 1 below the container with the sidebar -- and that content could even include other containers with local sidebar layouts.

In the next section, we'll show you how to determine the scrolling or filling behavior of each sidebar content areas.

### Scrolling layout

By default, `layout_sidebar()` provides rounded borders and padding around the container so that it can easily be dropped into any larger page.
In this way, the `layout_sidebar()` container is like a pared-down `card()` component.

Like [cards](cards.html), by default, the vertical height of the sidebar layout container will grow with the size of its contents.

```{r, sidebar-create-contents, echo=FALSE}
```

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  plot_price, plot_carat
)
```
:::
::::

If you have a lot of content in a `layout_sidebar()`, one option is to specify a `height` for the container to make its contents scrollable.

```{r, sidebar-create-contents, echo=FALSE}
```

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short-300}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long-300}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  plot_price, plot_carat
)
```
:::
::::

### Filling layout

If, instead of scrolling the content area, you want to allow the contents of the sidebar layout to resize themselves to the container height, also set `fillable = TRUE`.

```{r, sidebar-create-contents, echo=FALSE}
```

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short-fillable}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  fillable = TRUE,
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long-fillable}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  fillable = TRUE,
  plot_price, plot_carat
)
```
:::
::::

By setting `fillable = TRUE`, we tell `layout_sidebar()` that its main content area should be a _fillable container_.
Fillable containers work together with _fill items_.
When a container is fillable, any fill items in the container will grow or shrink to fill all available space in the container.
Because plotly plots are fill items, they grow or shrink to fill the available space of the fillable container in which they are placed.

In the next section, we'll see how we can use fillable pages for full-height sidebar layouts.

## Page sidebars

The [first example](#shared-sidebar) in this article used the `sidebar` argument of `page_navbar()` to create a shared sidebar across all pages in the app.
In this section, we'll explore a few more page-based sidebar layouts.

### Navbar pages

Let's return to the [shared sidebar example](#shared-sidebar) and apply the concepts we learned about in [Filling layout](#filling-layout).
If we set `fillable = TRUE` in `page_navbar()`, any fill items in each page will grow or shrink to fill the main content area.
Recall that plotly plots are fill items, so the plots on each fillable page will grow or shrink to fill the available space.

```{r navbar-global-fillable, as_iframe = TRUE, resizable = TRUE}
page_navbar(
  title = "Global sidebar w/ fill",
  sidebar = sidebar(filter_cut, filter_clarity),
  fillable = TRUE,
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

Suppose we want to include a full-height sidebar on just one page of our app because the other pages include unrelated outputs.
Like plotly plots, `layout_sidebar()` containers are also fill items by default.
We can create a local sidebar for Page 1 with `layout_sidebar()` and we can take advantage of the fact that, in addition to accepting logical values, `fillable` in `page_navber()` can accept a vector of page titles.
We'll take this alternate approach in the following example to make only the first page fillable.

```{r navbar-local-fill-outer, as_iframe = TRUE, scrolling = TRUE, resizable = TRUE}
page_navbar(
  title = "Local sidebar",
  fillable = "Page 1",
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity, width = 175),
      border = FALSE,
      plot_price,
      plot_carat
    )
  ),
  nav("Page 2", map_quakes)
)
```

Notice that the sidebar is full height but the plots are in a scrolling region.
Which option do we need to change to make the plots also fill the page?

If we want fill items, in this case the plotly plots, to fill available space, we need to make their containing element a fillable container.
We can do this by setting `fillable = TRUE` in `layout_sidebar()`.
Then, the plotly plots (which are fill items) will fill the main content area of the sidebar layout (which is a fillable container _and_ a fill item), and the sidebar layout will, in turn, fill the page (which is a fillable container).

```{r navbar-local-fill, as_iframe = TRUE, resizable = TRUE}
page_navbar(
  title = "Local sidebar w/ fill",
  fillable = "Page 1",
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity),
      fillable = TRUE,
      border = FALSE,
      plot_price,
      plot_carat
    )
  ),
  nav("Page 2", map_quakes)
)
```

The examples above all have resizable height.
Try resizing the page frame by grabbing the lower right corner to see how the plots grow and shrink to fit in their fillable container's height.

### Other pages

Most of our examples so far have focused on sidebar layouts within `page_navbar()`, but `layout_sidebar()` can be also used inside any Bootstrap `page()`: it works with `page_fixed()`, `page_fluid()`, `page_fillable()`, and more.

For example, instead of `page_navbar()`, we can add a full-page sidebar to `page_fillable()` because `page_fillable()` produces a fillable container by definition that `layout_sidebar()` will fill[^why-scrollable].

[^why-scrollable]: **Check your understanding:** Why do you have to scroll to see the second plot? How would you make the plots fill the page too?

```{r page-fill, as_iframe = TRUE}
page_fillable(
  title = "My filled page",
  h1("My filled page", class = "px-3 my-3"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity),
    border_radius = FALSE,
    "Scroll down for another plot ðŸ‘‡",
    plot_price,
    plot_carat
  )
)
```


## Cards

You can create a sidebar layout within a `card()` simply by adding `layout_sidebar()` within the card next to other card elements like `card_header()` and `card_footer()`.

The sidebar even works with the `full_screen = TRUE` option, in which case you probably also want to set `fillable = TRUE` in `layout_sidebar()` so that its contents will grow or shrink to fill the card container.
Also, consider hiding the sidebar by default within cards by setting `open = FALSE` within `sidebar()`, especially if space is limited or if you have [multiple cards with sidebars in a responsive layout](layouts.html#responsive-column-first-layout).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
card(
  full_screen = TRUE,
  card_header("Filter diamond price by cut and clarity"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity, open = FALSE),
    plot_price,
    fillable = TRUE
  )
)
```

## Cards with tabs

It's also possible to embed a sidebar layout within a `card()`s that has multiple tabs or pills with `navs_tab_card()` or `navs_pill_card()`.
As with `page_navbar()`, you can create a [shared sidebar](#card-tabs-shared-sidebar) using the `sidebar` argument of `navs_tab_card()` or `navs_pill_card()`.
Or you can create use `layout_sidebar()` to create a [local sidebar](#card-tabs-local-sidebar) for a particular tab pane.

### Shared sidebar {#card-tabs-shared-sidebar}

To show the same `sidebar()` on every tab pane, pass it to the `sidebar` argument of `navs_tab_card()` or `navs_pill_card()`.

You'll also probably want to set the card `height` as well (we chose `height = 450` in the example below) to keep a fixed card height across all tabs.
If you want the tab contents to fill the available card height, wrap the card elements in `card_body_fillable()` or set `wrapper = card_body_fillable` so that it's used for all tab cards.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  height = 450,
  full_screen = TRUE,
  wrapper = card_body_fillable,
  nav("Tab 1", plot_price, plot_carat),
  nav("Tab 2", plot_depth)
)
```

### Local sidebar {#card-tabs-local-sidebar}

To create a sidebar layout that's specific to a page[^dynamic-sidebar-tabs], place a `layout_sidebar()` inside the tab's `nav()` container.

[^dynamic-sidebar-tabs]: In Shiny apps, you can also have a shared sidebar with content that conditionally appears based on the current tab selection by using `conditionalPanel()` to create a [dynamic sidebar](#dynamic-sidebar).

In this example, we've used `fillable = TRUE` in the `layout_sidebar()` on the first tab so that plots fill the tab's card body.
When you expand the example card below, the plotly plot on Tab 1 will grow but the map on Tab 2 will keep the same height.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Tab-specific sidebar",
  height = 450,
  full_screen = TRUE,
  nav(
    "Tab 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity),
      fillable = TRUE,
      plot_price
    )
  ),
  nav("Tab 2", map_quakes)
)
```

-->

## Shiny

When used within Shiny apps, sidebars provide a few additional features you can leverage.

### Sidebar state

In a shiny app, whether or not the `sidebar()` is opened reported through an input named after the `id` of the sidebar.
In the following Shiny UI, the sidebar has `id = "sidebar"`.
In the server logic, `input$sidebar` will report `TRUE` when the sidebar is opened and `FALSE` when the sidebar is closed.

```{r eval = FALSE}
library(shiny)

ui <- page_navbar(
  title = "Sidebar example",
  id = "nav",
  sidebar = sidebar(id = "sidebar", filter_cut, filter_clarity),
  fillable = "Page 2",
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth)
)
```

You can also open and close the sidebar reactively in your Shiny `server` function using `sidebar_open()` and `sidebar_close()` and the sidebar `id`.
In the following chunk, we read the current navbar page and close the sidebar on Page 2 and re-open it on Page 1.

```{r, eval = FALSE}
server <- function(input, output) {
  observe({
    if (input$nav == "Page 1") {
      sidebar_open("sidebar")
     } else {
      sidebar_close("sidebar")
     }
  })
}

shinyApp(ui, server)
```


```{r shiny-sidebar-state, echo = FALSE, as_iframe = TRUE}
page_navbar(
  title = "Sidebar example",
  id = "nav",
  fillable = "Page 2",
  sidebar = sidebar(
    id = "sidebar",
    filter_cut,
    filter_clarity
  ),
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth),
  footer = htmltools::tags$script(htmltools::HTML("
$('#nav').on('shown.bs.tab', function(ev) {
  const page = ev.target.dataset.value;
  const $sb = $('.bslib-sidebar-layout > .bslib-sidebar-input');
  if (page === 'Page 2') {
    $sb.parent().addClass('sidebar-collapsed');
  } else {
    $sb.parent().removeClass('sidebar-collapsed');
  }
  $sb.trigger('toggleCollapse.sidebarInputBinding');
  setTimeout(function() {
    const resizeEvent = new Event('resize');
    window.dispatchEvent(resizeEvent);
  }, 500);
});"
  ))
)
```


### Dynamic sidebar

When [shared sidebars](#shared-sidebar) include the same inputs in several pages or tabs, it's sometimes helpful to have the sidebar controls change depending on which page or tab is active. Thanks to `shiny::conditionalPanel()`[^4], this can be done fairly easily in a Shiny app with `page_navvar()` or in `navs_tab_card()` or `navs_tab_pill()`.

[^4]: If the controls depend on some other application state, we can also, of course, use `shiny::uiOutput()` to fill the contents of a `sidebar()`).

```{r, eval = FALSE}
shinyApp(
  page_navbar(
    title = "Dynamic sidebar",
    id = "nav",
    sidebar = sidebar(
      filter_cut, filter_clarity,
      conditionalPanel(
        "input.nav === 'Page 2'",
        filter_color
      )
    ),
    fillable = "Page 2",
    nav("Page 1", plot_price, plot_carat),
    nav("Page 2", plot_depth)
  ),
  server = function(...) {
    # no server logic required
  }
)
```

```{r shiny-dynamic-sidebar, echo = FALSE, as_iframe = TRUE}
page_navbar(
  title = "Sidebar example",
  id = "nav",
  fillable = "Page 2",
  sidebar = sidebar(
    id = "sidebar",
    filter_cut,
    filter_clarity,
    div(id = "sidebar-page-2", class = "hidden", filter_color)
  ),
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth),
  footer = htmltools::tags$script(htmltools::HTML("
$('#sidebar-page-2').hide();

$('#nav').on('shown.bs.tab', function(ev) {
  const page = ev.target.dataset.value;
  page === 'Page 2' ? $('#sidebar-page-2').show() : $('#sidebar-page-2').hide();
});
"
  ))
)
```

## Accordians

All sidebars have special treatment for accordians.
When an `accordion()` appears directly within a `sidebar()` (as an immediate child of the sidebar), the accordian panels will render flush to the sidebar, providing a convenient way to group multiple related input controls under a collapsible section.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
filters_acc <- accordion(
  open = TRUE,
  accordion_panel(
    "Cut", icon = bsicons::bs_icon("scissors"),
    filter_select("cut", NULL, dat, ~cut),
  ),
  accordion_panel(
    "Clarity", icon = bsicons::bs_icon("search"),
    filter_select("clarity", NULL, dat, ~clarity)
  )
)

layout_sidebar(sidebar(filters_acc), plot_price)
```

## Nested sidebars

It's possible to nest sidebar layouts, which means you can effectively have any number of left and/or right sidebars in a given layout. When doing this, you'll want the main content area of every `layout_sidebar()` that contains a `layout_sidebar()` to be fillable and have zero padding (`class = "p-0"`).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-fill-double, as_iframe = TRUE}
page_fillable(
  h1("Left and right sidebar", class = "px-3 my-3"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity),
    layout_sidebar(
        sidebar(filter_color, position = "right", open = FALSE),
        plot_price,
        border = FALSE
    ),
    border_radius = FALSE,
    fillable = TRUE,
    class = "p-0"
  )
)
```

## Styling and customization

In the above sections we've focused primarily on the variety of interface layouts where sidebars can be used.
Along the way, we've touched on a few of the named arguments of `sidebar()` and `layout_sidebar()` that are helpful for customizing the styling and behavior of both the sidebar and main content areas.
Let's look at these arguments in more detail.

Within `sidebar()`, you can use

* `open = FALSE` to hide the sidebar initially (the default is `TRUE`)
* `position = "right"` to position the sidebar on the right side (the default is `"left"`)
* `width` to set the desired width of the sidebar.

The options in `layout_sidebar()` include

* `border = FALSE` to disable the container border (defaults to `TRUE`)
* `border_radius = FALSE` to disable the border's radius (defaults to `TRUE`)
* `fillable = TRUE` to make the main content area a fillable container (defaults to `FALSE`)
* `height` to set the fixed height of the sidebar layout container

Both `sidebar()` and `layout_sidebar()` also let you specific a background color via `bg` that is applied to the sidebar area and main content area respectively.
When `bg` is provided, bslib will automatically choose an appropriate, corresponding, high-contrast foreground color.
Both functions also include a `class` argument that works well with [Bootstrap utility `class`es](https://getbootstrap.com/docs/5.3/utilities/spacing/) and a `style` argumnet for inline styles.

Be aware that in `layout_sidebar()`, `bg`, `class` and `style` attributes are applied to the main content area's container and _not_ the overall layout container.
To add additional classes to the layout container, use `htmltools::tagAppendAttributes()`.
Also note that `layout_sidebar()` derives some of it's default style from Bootstrap CSS variables (e.g., `--bs-card-border-color`), which enables theming at the component-level ([theming via `bs_theme()`](bs5-variables.html) works on the page-level).

The following example combines all of these concepts to create sidebar with a dark background.
Utility classes are used to make the sidebar text monospace and bold, and we used `tagAppendAttributes()` to tweak the border color of the sidebar layout to match the sidebar background.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
library(htmltools)
library(leaflet)

squake <- SharedData$new(quakes)

container <- layout_sidebar(
  class = "p-0",
  sidebar(
    bg = "#1E1E1E",
    width = "35%",
    class = "fw-bold font-monospace",
    div("Earthquakes off Fiji", class = "text-white mb-3 h3"),
    filter_slider("mag", "Magnitude", squake, ~mag)
  ),
  leaflet(squake) |> addTiles() |> addCircleMarkers()
)

tagAppendAttributes(container, style = css("--bs-card-border-color" = "#1E1E1E"))
```
