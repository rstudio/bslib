---
title: "Sidebars"
output:
  html_document:
    theme:
      version: 5
resource_files:
  - infobox.svg
  - navbar-global
  - navbar-global-fillable
  - navbar-local-scroll
  - navbar-local-fill
  - page-scroll
  - page-fill
  - page-fill-double
---

```{r setup, include=FALSE}
library(knitr)
library(htmltools)
library(bslib)

opts_chunk$set(message = FALSE)

render_as_iframe <- function(x, options, ...) {
  lbl <- opts_current$get("label")
  if (!dir.exists(lbl)) {
    dir.create(lbl)
  }
  file <- file.path(lbl, paste0(lbl, ".html"))
  x <- tagList(x, tags$head(tags$style(".plotly { height: 250px !important; } .modebar-container { display: none; }")))
  tryCatch(
    save_html(x, file),
    error = function(e) {
      stop("Don't know how to render ", class(x)[[1]], " as an <iframe>")
    }
  )
  include_url(file)
}

knitr::opts_hooks$set(as_iframe = function(opts) {
  opts$render <- render_as_iframe
  opts$out.width <- "100%"
  opts$out.extra <- paste0(
    'height=600px seamless="seamless" frameBorder="0"',
    if (!isTRUE(opts$scrolling)) ' scrolling="no"'
  )
  opts
})

# pkgdown really wants BS5+ markup for tabs, and this is currently the best way to achieving that :(
# (note this isn't a problem for any format based on html_document_base)
shiny:::setCurrentTheme(bslib::bs_theme())

# Each time we source this file, it'll give us a new crosstalk controls/views that use a different crosstalk group (this way, interactions won't be shared across chunks)
knitr::read_chunk(
  rprojroot::find_package_root_file("vignettes/sidebar-create-contents.R")
)

describe_layout_function <- function(name, description, element = NULL) {
  name <- knitr::combine_words(sprintf("<code>%s</code>", name),  and = " or ")

  if (is.null(element)) {
    element <- card_body_fill(
      class = "d-flex flex-column align-items-center",
      div(style = "width: 6em; height: 6em; background-color: gray")
    )
  }

  card(
    card_header(class = "bg-info", HTML(name)),
    element,
    card_footer(class = "bg-white", description)
  )
}
```

```{scss, echo = FALSE}
.plotly {
  height: 250px !important;
  .modebar-container {
    display: none;
  }
}
.html-widget {
  margin-bottom: 0;
}
iframe, .bslib-page-fill {
  height: 450px;
  border: var(--bs-border-width) solid var(--bs-border-color);
  margin-bottom: 4rem;
  box-shadow:
    rgba(0, 0, 0, 0.25) 0px 54px 55px,
    rgba(0, 0, 0, 0.12) 0px -12px 30px,
    rgba(0, 0, 0, 0.12) 0px 4px 6px,
    rgba(0, 0, 0, 0.17) 0px 12px 13px,
    rgba(0, 0, 0, 0.09) 0px -3px 5px;
}
.card-header.bg-info code {
  background: none;
  color: hsl(209deg, 85%, 25%);
}
```

::: lead
Sidebar layouts in web interfaces allow your users to easily access filters, settings and other inputs alongside the interactive features they control.
In this article, you'll learn how to create sidebar layouts with bslib.
:::

## Sidebar layouts

To create a sidebar layout, provide a `sidebar()` to the `sidebar` argument of one of the following functions.

:::: {.row}

::: {.col-sm-12 .col-lg-6}
### Local Sidebar

Use `layout_sidebar()` whenever you want a **local sidebar** adjacent to a content panel.

`layout_sidebar()` creates a bordered area by default, making it useful anywhere in your interface.
It also fits nicely into `card()` components and `nav()` pages or tabs.
:::

::: {.col-sm-12 .col-lg-6 .text-center .mt-2 .mt-lg-4}
```{r echo = FALSE}
describe_layout_function(
  "layout_sidebar()",
  "A flexible, local sidebar layout.",
  card_body_fill(
    class = "p-2",
    height = 200,
    layout_sidebar(
      sidebar = sidebar("Local sidebar", width = "33%", class = "bg-light"),
      "Content with a sidebar"
    )
  )
)
```
:::

::::

:::: {.row}

::: {.col-sm-12 .col-lg-6}
### Global Sidebar

When `sidebar` is an argument to a function containing multiple pages or panels, it creates a **global sidebar**.

Provide a `sidebar()` to `page_navbar()` to recreate the classic [shinydashboard](http://rstudio.github.io/shinydashboard/) look with a global sidebar shared across several pages.

You can also add a global sidebar to a card with tabs or pills created with `navs_tab_card()` or `navs_pill_card()`.
:::

::: {.col-sm-12 .col-lg-6 .text-center .mt-2 .mt-lg-4}
```{r echo = FALSE}
describe_layout_function(
  "page_navbar()",
  "A shared sidebar in a multi-page layout.",
  card_body_fill(
    class = "p-0",
    height = 200,
    id = "page_navbar_example_card",
    navs_bar(
      collapsible = FALSE,
      fillable = TRUE,
      sidebar = sidebar("Global sidebar", width = "33%", class = "bg-light"),
      nav("Page 1", "Page 1 content"),
      nav("Page 2", "Page 2 content")
    ),
    tags$script(HTML("$(document).ready(function() {
      var demo_nav = $('#page_navbar_example_card nav.navbar');
      setTimeout(function(){ demo_nav.headroom('destroy') }, 100);
    });"))
  ) |>
  tagAppendAttributes(class = "flex-row", .cssSelector = ".navbar-nav") |>
  tagAppendAttributes(class = "d-none", .cssSelector = ".navbar-header") |>
  tagAppendAttributes(class = "navbar-dark", .cssSelector = "nav")
)
```

```{r echo = FALSE}
describe_layout_function(
  c("navs_tab_card()", "navs_pill_card()"),
  "A shared sidebar for tabs within a card.",
  card_body_fill(
    class = "p-2",
    height = 200,
    navs_tab_card(
      title = "Tab Card",
      sidebar = sidebar("Global sidebar", width = "33%", class = "bg-light"),
      nav("Tab 1", "Tab 1 content"),
      nav("Tab 2", "Tab 2 content")
    )
  )
)
```
:::

::::

::: {.callout .callout-warning}
### Prefer local sidebars

Although [global sidebars](#global-sidebar) have been popularized by packages like [shinydashboard](http://rstudio.github.io/shinydashboard/), they're not always ideal for creating a good user experience.

As a general rule, group sidebar controls as closely as possible with the contents they affect.
Use `layout_sidebar()` to group inputs in a [local sidebar](#local-sidebar) adjacent to the output they control.
Use global sidebars sparingly and only when the inputs in them are use across many outputs on your page.
:::

In the next few sections, we'll dive a little deeper into each of the sidebar layout functions listed above.

## Setup code

In this article, we'll explore the flexibility of bslib's sidebar layouts by showing many variations of the same inputs and outputs to filter and visualize diamond quality data[^diamonds].

In a Shiny app[^1], you'll probably want to use inputs like `shiny::selectInput()`, `shiny::sliderInput()`, etc., in the sidebar, but because you're reading this article in a static website, we'll use [crosstalk](https://rstudio.github.io/crosstalk/) input widgets.

[^diamonds]: The diamonds in our data set are a 1,000 rows randomly sampled from `ggplot2::diamonds`.
[^1]: In a Shiny app, we also recommend you add an `id` to the `sidebar()` so that you can reactively read/update whether the sidebar is open/closed.

```{r, sidebar-create-contents}
```


## Navbar page

The `page_navbar()` function provides a modern version of `shiny::navbarPage()` (i.e., a "multi-page app"[^2]) which not only defaults to a modern version of Bootstrap, but has additional features, such as a `sidebar` argument.

[^2]: These functions don't actually make what web developers would consider a  multi-page app since they don't actually request different HTML pages (they are based on Bootstrap nav components).

### Global sidebar

To show the same `sidebar()` on every page (i.e., create a "global" sidebar), pass it to the `sidebar` argument of `page_navbar()`:

```{r navbar-global, as_iframe = TRUE}
page_navbar(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

With a global sidebar, the `fillable` argument controls whether the _main content area_ of the sidebar layout has the potential to grow/shrink to fit the browser window. By setting `fillable = TRUE`, every page's main contents are allowed to grow/shrink.[^3] In this example, this causes `Page 1`'s plots to shrink and `Page 2`'s plots to grow (in the previous example, the plots on `Page 1` spill over their container, but are still accessible via scrolling).

[^3]: Specific page(s) can also be made `fillable` (e.g., `fillable = "Page 1"`)

```{r navbar-global-fillable, as_iframe = TRUE}
page_navbar(
  title = "Global sidebar w/ fill",
  sidebar = sidebar(filter_cut, filter_clarity),
  fillable = TRUE,
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

### Dynamic sidebar

Sometimes it's helpful to have the sidebar controls change depending on what page is active (especially with a global sidebar).[^4] Thanks to `shiny::conditionalPanel()`, this can be done fairly easily in a Shiny app:

[^4]: If the controls depend on some other application state, we can also, of course, use `shiny::uiOutput()` to fill the contents of a `sidebar()`).

```{r, eval = FALSE}
shinyApp(
  page_navbar(
    title = "Dynamic sidebar",
    sidebar = sidebar(
      filter_cut, filter_clarity,
      conditionalPanel(
        "input.nav === 'Page 2'",
        filter_color
      )
    ),
    id = "nav",
    nav("Page 1", plot_price, plot_carat),
    nav("Page 2", plot_depth)
  ),
  function(input, output) {}
)
```

```{r}
# Yields similar result to the examples above
# (only difference is `color` filter appears on Page 2)
```

<br>

### Local sidebar

To create a sidebar layout that's specific to a page, place a `layout_sidebar()` inside a page (i.e., `nav()`) container. In addition to allowing pages to not have a sidebar, this approach also makes it possible to make a group of related inputs/outputs visually distinct from other (unrelated) inputs/outputs.

```{r navbar-local-scroll, as_iframe = TRUE, scrolling = TRUE}
library(leaflet)

page_navbar(
  title = "Local sidebar",
  fluid = FALSE,
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity, width = 175),
      plot_price
    ),
    br(),
    card(
      card_header("Some unrelated map"),
      leaflet(quakes) |> addTiles() |> addCircleMarkers()
    )
  ),
  nav("Page 2", "Something else")
)
```

If the `layout_sidebar()` should fit the browser window (in the same way a [global sidebar](#global-sidebar) does), then make the relevant page `fillable`. In addition, if the main contents want to be `fillable` (e.g., `plot_price` should be allowed to grow/shrink to fit the layout container), then also set `fillable = TRUE` in `layout_sidebar()`.

```{r navbar-local-fill, as_iframe = TRUE}
page_navbar(
  title = "Local sidebar w/ fill",
  fillable = "Page 1",
  nav(
    "Page 1",
    layout_sidebar(
      fillable = TRUE,
      border = FALSE,
      sidebar(filter_cut, filter_clarity),
      plot_price
    )
  ),
  nav("Page 2", "Something else")
)
```

## Other page layouts

The previous section focused on sidebar layouts in the context of a `page_navbar()`, but as you may have guessed from the last couple [local sidebar](#local-sidebar) examples, `layout_sidebar()` can be also used inside any Bootstrap `page()` (i.e., it works with `page_fixed()`, `page_fluid()`, `page_fill()`, etc) and/or `card()` (which we'll cover [later](#cards)).

### Scrolling layout

By default, `layout_sidebar()` provides rounded borders and padding around the container so that it can easily be dropped into any larger page. The sizing rules are also very similar to [cards](cards.html) in the sense that the container grows with the size of it's contents (by default). So, if there's lots of content, consider specifying a `height` in the container (contents will then be scrollable). If, instead, of scrolling contents (the default), you want to allow those contents to resize themselves to that height, also set `fillable = TRUE`:

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-scroll, as_iframe = TRUE, scrolling = TRUE}
page_fixed(
  h1("My scrolling page", class = "lead fs-2 my-3"),
  layout_sidebar(
    height = 325,
    sidebar(filter_cut, filter_clarity),
    "Scroll down for another plot ðŸ‘‡",
    plot_price, plot_carat
  ),
  br(),
  layout_sidebar(
    height = 350,
    fillable = TRUE,
    sidebar(filter_color, position = "right"),
    "No scrolling here",
    plot_price, plot_carat
  ),
  br()
)
```

<br>

Note that this idea of scrolling multiple sidebar layouts concept also works with a `page_fluid()` or `page()` container (the only difference is the amount of horizontal padding provided on the page level). If, instead of scrolling at the page level, you want sidebar layout(s) to fit the browser window, consider using `page_fill()`.

### Filling layout

Since `page_fill()` is a fillable container (with a height of 100%) and `layout_sidebar()` is a fill item (it defaults to `fill = TRUE`, just like the `{plotly}` plots do), `layout_sidebar()`(s) that are direct children of `page_fill()` will grow/shrink as needed to fit the browser window. Note that, this doesn't necessarily mean the _contents_ of the `layout_sidebar()` will grow/shrink (for that behavior, set `fillable = TRUE` in `layout_sidebar()`):

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-fill, as_iframe = TRUE}
page_fill(
  h1(
    class = "lead text-center bg-primary bg-gradient my-0 p-3",
    "My filled page"
  ),
  layout_sidebar(
    border = FALSE,
    border_radius = FALSE,
    sidebar(filter_cut, filter_clarity),
    "Scroll down for another plot ðŸ‘‡",
    plot_price, plot_carat
  )
)
```

<br>


## Cards

`layout_sidebar()` can also be dropped into a `card()`, which is especially convenient for adding a `card_header()`, `card_footer()`, or even `full_screen = TRUE` behavior. If you do want `full_screen = TRUE` (and/or specify a `height`), then you may also want `fillable = TRUE` to allow the contents of the main area (e.g., `plot_price`) to grow/shrink to the card container. Also, in a card context, it might make sense to hide the sidebar by default (`open = FALSE`), especially if space is limited (e.g., maybe you want [multiple cards with sidebars](layouts.html#responsive-column-first-layout)).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
card(
  full_screen = TRUE,
  card_header("Filter diamond price by cut and clarity"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity, open = FALSE),
    plot_price,
    fillable = TRUE
  )
)
```

<br>

## Cards with tabs

It's also possible to embed a sidebar layout within a `card()`s that has multiple tabs/pills via `navs_tab_card()`/`navs_pill_card()`. And, similar to `page_navbar()`, a `sidebar()` can either be passed as an argument (i.e., global sidebar) or to a particular tab/pill (i.e., local sidebar).

### Global sidebar

To show the same `sidebar()` on every tab/pill (i.e., create a "global" sidebar), pass it to the `sidebar` argument of `navs_tab_card()` (or `navs_pill_card()`).

Remember that, just like `layout_sidebar()` and `card()`, `navs_tab_card()` sizes itself according to it's contents (by default), so consider setting a `height` to keep a fixed height across all tabs. And, to allow the contents to grow/shrink to fit the card container, you'll want to wrap the contents of each tab with `card_body_fill()` (`wrapper = card_body_fill` is a convenient way to do this for all tabs).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  height = 450,
  full_screen = TRUE,
  wrapper = card_body_fill,
  nav("Tab 1", plot_price, plot_carat),
  nav("Tab 2", plot_depth)
)
```

### Dynamic sidebar

Sometimes it's helpful to have the sidebar controls change depending on what page is active (especially with a global sidebar).[^4] Thanks to `shiny::conditionalPanel()`, this can be done fairly easily in a Shiny app:

```{r, eval = FALSE}
dynamic <- navs_tab_card(
  title = "Dynamic sidebar",
  sidebar = sidebar(
    filter_cut, filter_clarity,
    conditionalPanel(
      "input.nav === 'Page 2'",
      filter_color
    )
  ),
  id = "nav",
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth)
)

shinyApp(
  page_fixed(dynamic),
  function(input, output) {}
)
```

```{r}
# Yields similar result to the examples above
# (only difference is `color` filter appears on Page 2)
```

<br>


### Local sidebar

To create a sidebar layout that's specific to a page, place a `layout_sidebar()` inside a tab (i.e., `nav()`) container (similar to how you would for [a `card()` without tabs](#cards)).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Tab-specific sidebar",
  full_screen = TRUE,
  nav(
    "Tab 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity),
      plot_price,
      fillable = TRUE
    )
  ),
  nav(
    "Tab 2",
    "Something else entirely"
  )
)
```

<br>


## Shiny

Inside a Shiny context, the `open` state of a `sidebar()` can programmatically updated and/or queried through an input value. Doing so requires that an `id` is provided to the `sidebar()`. Here's an example of using `sidebar_close()` and `sidebar_open()` to make sure the sidebar is open on `Page 1` but closed on `Page 2`.

```{r, eval = FALSE}
library(shiny)

ui <- page_navbar(
  title = "Sidebar example",
  id = "nav",
  sidebar = sidebar(id = "sidebar", filter_cut, filter_clarity),
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth)
)

server <- function(input, output) {
  observe({
    func <- if (input$nav == "Page 2") sidebar_close else sidebar_open
    func("sidebar")
  })
}

shinyApp(ui, server)
```


## Sidebar accordions

When an accordion appears as a immediate child inside `sidebar()`, they'll render "flush" to the sidebar, providing a convenient way to group multiple related input controls under a collapsible section.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
filters_acc <- accordion(
  open = TRUE,
  accordion_panel(
    "Cut", icon = bsicons::bs_icon("scissors"),
    filter_select("cut", NULL, dat, ~cut),
  ),
  accordion_panel(
    "Clarity", icon = bsicons::bs_icon("search"),
    filter_select("clarity", NULL, dat, ~clarity)
  )
)

layout_sidebar(sidebar(filters_acc), plot_price)
```

<br>

## Nested sidebars

It's possible to nest sidebar layouts, which means you can effectively have any number of left and/or right sidebars in a given layout. When doing this, you'll want the main content area of every `layout_sidebar()` that contains a `layout_sidebar()` to be fillable and have zero padding (`class = "p-0"`).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-fill-double, as_iframe = TRUE}
page_fill(
    h1(
        class = "lead fs-2 text-center bg-primary bg-gradient my-0 p-3",
        "Left and right sidebar"
    ),
    layout_sidebar(
        sidebar(filter_cut, filter_clarity),
        layout_sidebar(
            sidebar(filter_color, position = "right", open = FALSE),
            plot_price,
            border = FALSE
        ),
        border_radius = FALSE,
        fillable = TRUE,
        class = "p-0"
    )
)
```

## Styling and customization

Both `sidebar()` and `layout_sidebar()` have named arguments which, as we've already seen, are helpful for customizing the styling and behavior of both the sidebar and main content areas. In fact, the previous example demonstrated advanced usage of `sidebar()`'s `position` and `open` as well as `layout_sidebar()`'s `fillable`, `border`, etc. However, there are other useful arguments we haven't seen yet like `bg` color (when specified, a contrasting foreground color may also be provided to dark backgrounds "just work").

For other "lower-level" theming, you may want to leverage [Bootstrap utility `class`es]((https://getbootstrap.com/docs/5.3/utilities/spacing/)) and/or inline styles. When doing this, you'll want to be aware that `layout_sidebar()`'s `...` arguments (and thus `class`, `style`, etc.) are added to the main content's container (_not_ the overall layout container). So, to add `class` or `style` attributes on the layout `container`, use `htmltools::tagAppendAttributes()`. Note also that `layout_sidebar()` derives some of it's default style from Bootstrap CSS variables (e.g., `--bs-border-color`), which enables theming at the component-level ([theming via `bs_theme()`](bs5-variables.html) works on the page-level).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
library(htmltools)
library(leaflet)

squake <- SharedData$new(quakes)

container <- layout_sidebar(
  class = "p-0",
  sidebar(
    bg = "#1E1E1E",
    width = "35%",
    class = "fw-bold font-monospace",
    filter_slider("mag", "Magnitude", squake, ~mag)
  ),
  leaflet(squake) |> addTiles() |> addCircleMarkers()
)

tagAppendAttributes(container, style = css("--bs-border-color" = "darkgray"))
```

<br>
