---
title: "Sidebars"
resource_files:
  - infobox.svg
  - navbar-global
  - navbar-global-fillable
  - navbar-local-scroll
  - navbar-local-fill
  - page-scroll
  - page-fill
  - page-fill-double
---

```{r setup, include=FALSE}
library(knitr)
library(htmltools)

opts_chunk$set(message = FALSE)

render_as_iframe <- function(x, options, ...) {
  lbl <- opts_current$get("label")
  if (!dir.exists(lbl)) {
    dir.create(lbl)
  }
  file <- file.path(lbl, paste0(lbl, ".html"))
  x <- tagList(x, tags$head(tags$style(".plotly { height: 250px !important; } .modebar-container { display: none; }")))
  tryCatch(
    save_html(x, file),
    error = function(e) {
      stop("Don't know how to render ", class(x)[[1]], " as an <iframe>")
    }
  )
  include_url(file)
}

# pkgdown really wants BS5+ markup for tabs, and this is currently the best way to achieving that :(
# (note this isn't a problem for any format based on html_document_base)
shiny:::setCurrentTheme(bslib::bs_theme())

# Each time we source this file, it'll give us a new crosstalk controls/views that use a different crosstalk group (this way, interactions won't be shared across chunks)
knitr::read_chunk(
  rprojroot::find_package_root_file("vignettes/sidebar-create-contents.R")
)
```

```{scss, echo = FALSE}
.plotly {
  height: 250px !important;
  .modebar-container {
    display: none;
  }
}
.html-widget {
  margin-bottom: 0;
}
iframe, .bslib-page-fill {
  height: 450px;
  border: var(--bs-border-width) solid var(--bs-border-color);
  margin-bottom: 4rem;
  box-shadow:
    rgba(0, 0, 0, 0.25) 0px 54px 55px,
    rgba(0, 0, 0, 0.12) 0px -12px 30px,
    rgba(0, 0, 0, 0.12) 0px 4px 6px,
    rgba(0, 0, 0, 0.17) 0px 12px 13px,
    rgba(0, 0, 0, 0.09) 0px -3px 5px;
}
```

### Sidebar layouts

To create a sidebar layout, provide a `sidebar()` to the `sidebar` argument of one of the following functions:

1. `layout_sidebar()`
   * A flexible sidebar layout.
2. `card_sidebar()`
   * A `card()`-based sidebar layout.
3. `navs_tab_card()` (or `navs_pill_card()`)
   * A multi-tab, `card()`-based, sidebar layout.
4. `page_navbar()`
   * A multi-page sidebar layout.

Cases 3 and 4 are inherently different from 1 and 2 because, in the former cases, you have the choice of either passing the sidebar directly to the function (which creates a [global sidebar](#global-sidebar)) or passing a sidebar layout to a particular page / tab (i.e., a [local sidebar](#local-sidebar)).[^1]

[^1]: As a general UX rule, sidebar controls should be grouped as closely as possible with the contents that it effects. So, if you have multiple groups of outputs you want to show on the same page, you may want to put several card-based sidebar layouts on a given page.


### Setup code

This article's code examples make repeated use of the following UI elements. In a Shiny context[^2], you'll probably want inputs like `shiny::selectInput()`, `shiny::sliderInput()`, etc., in the sidebar, but since this is a statically hosted website, we'll use `{crosstalk}` input widgets.

[^2]: In a Shiny context, you may also want to add an `id` to the `sidebar()` so you can reactive-ly read/update whether the sidebar is open/closed.

```{r, sidebar-create-contents}
```


### Navbar page

The `page_navbar()` function provides a modern version of `shiny::navbarPage()` (i.e., a "multi-page app"[^3]) which not only defaults to a modern version of Bootstrap, but has additional features, such as a `sidebar` argument.

[^3]: These functions don't actually make what web developers would consider a  multi-page app since they don't actually request different HTML pages (they are based on Bootstrap nav components).

#### Global sidebar

To show the same `sidebar()` on every page (i.e., create a "global" sidebar), pass it to the `sidebar` argument of `page_navbar()`:

```{r navbar-global, render=render_as_iframe, out.width="100%", out.extra='height=600px scrolling="no" seamless="seamless" frameBorder="0"'}
page_navbar(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

With a global sidebar, the `fillable` argument controls whether the _main content area_ of the sidebar layout has the potential to grow/shrink to fit the browser window. By setting `fillable = TRUE`, every page's main contents are allowed to grow/shrink.[^4] In this example, this causes `Page 1`'s plots to shrink and `Page 2`'s plots to grow (in the previous example, the plots on `Page 1` spill over their container, but are still accessible via scrolling).

[^4]: Specific page(s) can also be made `fillable` (e.g., `fillable = "Page 1"`)

```{r navbar-global-fillable, render=render_as_iframe, out.width="100%", out.extra='height=600px scrolling="no" seamless="seamless" frameBorder="0"'}
page_navbar(
  title = "Global sidebar w/ fill",
  sidebar = sidebar(filter_cut, filter_clarity),
  fillable = TRUE,
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

#### Dynamic sidebar

Sometimes it's helpful to have the sidebar controls change depending on what page is active (especially with a global sidebar).[^5] Thanks to `shiny::conditionalPanel()`, this can be done fairly easily in a Shiny app:

[^5]: If the controls depend on some other application state, we can also, of course, use `shiny::uiOutput()` to fill the contents of a `sidebar()`).

```{r, eval = FALSE}
shinyApp(
  page_navbar(
    title = "Dynamic sidebar",
    sidebar = sidebar(
      filter_cut, filter_clarity,
      conditionalPanel(
        "input.nav === 'Page 2'",
        filter_color
      )
    ),
    id = "nav",
    nav("Page 1", plot_price, plot_carat),
    nav("Page 2", plot_depth)
  ),
  function(input, output) {}
)
```

```{r}
# Yields similar result to the examples above
# (only difference is `color` filter appears on Page 2)
```

<br>

#### Local sidebar

To create a sidebar layout that's specific to a page, place a `layout_sidebar()` (and/or a `card_sidebar()`) inside a page (i.e., `nav()`) container. In addition to allowing pages to not have a sidebar, this approach also makes it possible to make a group of related inputs/outputs visually distinct from other (unrelated) inputs/outputs.

```{r navbar-local-scroll, render=render_as_iframe, out.width="100%", out.extra='height=600px seamless="seamless" frameBorder="0"'}
library(leaflet)

page_navbar(
  title = "Local sidebar",
  fluid = FALSE,
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity, width = 175),
      plot_price
    ),
    br(),
    card(
      card_header("Some unrelated map"),
      leaflet(quakes) |> addTiles() |> addCircleMarkers()
    )
  ),
  nav("Page 2", "Something else")
)
```

If the `layout_sidebar()` should fit the browser window (in the same way a [global sidebar](#global-sidebar) does), then make the relevant page `fillable`. In addition, if the main contents want to be `fillable` (e.g., `plot_price` should be allowed to grow/shrink to fit the layout container), then also set `fillable = TRUE` in `layout_sidebar()`.

```{r navbar-local-fill, render=render_as_iframe, out.width="100%", out.extra='height=600px scrolling="no" seamless="seamless" frameBorder="0"'}
page_navbar(
  title = "Local sidebar w/ fill",
  fillable = "Page 1",
  nav(
    "Page 1",
    layout_sidebar(
      fillable = TRUE,
      border = FALSE,
      sidebar(filter_cut, filter_clarity),
      plot_price
    )
  ),
  nav("Page 2", "Something else")
)
```

### Other page layouts

The previous section focused on sidebar layouts in the context of a `page_navbar()`, but as you may have guessed from the last couple [local sidebar](#local-sidebar) examples, `layout_sidebar()` can be also used inside any Bootstrap `page()` (i.e., it works with `page_fixed()`, `page_fluid()`, `page_fill()`, etc). The same also goes for `card_sidebar()` (which we'll cover [later](#cards)), and since it's a thin wrapper around `layout_sidebar()`, many of the same concepts we'll cover here also apply to `card_sidebar()`.

#### Scrolling layout

By default, `layout_sidebar()` provides rounded borders and padding around the container so that it can easily be dropped into any larger page. The sizing rules are also very similar to [cards](cards.html) in the sense that the container grows with the size of it's contents (by default). So, if there's lots of content, consider specifying a `height` in the container (contents will then be scrollable). If, instead, of scrolling contents (the default), you want to allow those contents to resize themselves to that height, also set `fillable = TRUE`:

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-scroll, render=render_as_iframe, out.width="100%", out.extra='height=600px seamless="seamless" frameBorder="0"'}
page_fixed(
  h1("My scrolling page", class = "lead fs-2 my-3"),
  layout_sidebar(
    height = 325,
    sidebar(filter_cut, filter_clarity),
    "Scroll down for another plot ðŸ‘‡",
    plot_price, plot_carat
  ),
  br(),
  layout_sidebar(
    height = 350,
    fillable = TRUE,
    sidebar(filter_color, position = "right"),
    "No scrolling here",
    plot_price, plot_carat
  ),
  br()
)
```

<br>

Note that this idea of scrolling multiple sidebar layouts concept also works with a `page_fluid()` or `page()` container (the only difference is the amount of horizontal padding provided on the page level). If, instead of scrolling at the page level, you want sidebar layout(s) to fit the browser window, consider using `page_fill()`.

#### Filling layout

Since `page_fill()` is a fillable container (with a height of 100%) and `layout_sidebar()` is a fill item (it defaults to `fill = TRUE`, just like the `{plotly}` plots do), `layout_sidebar()`(s) that are direct children of `page_fill()` will grow/shrink as needed to fit the browser window. Note that, this doesn't necessarily mean the _contents_ of the `layout_sidebar()` will grow/shrink (for that behavior, set `fillable = TRUE` in `layout_sidebar()`):

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-fill, render=render_as_iframe, out.width="100%", out.extra='height=600px scrolling="no" seamless="seamless" frameBorder="0"'}
page_fill(
  h1(
    class = "lead text-center bg-primary bg-gradient my-0 p-3",
    "My filled page"
  ),
  layout_sidebar(
    border = FALSE,
    border_radius = FALSE,
    sidebar(filter_cut, filter_clarity),
    "Scroll down for another plot ðŸ‘‡",
    plot_price, plot_carat
  )
)
```

<br>


### Cards

`card_sidebar()` provides a convenient short-hand for creating a sidebar layout inside a `card()`. This way, you can easily add a `card_header()`, `card_footer()`, or even `full_screen = TRUE` behavior. If you do want `full_screen = TRUE` (and/or specify a `height`), then you may also want `fillable = TRUE` to allow the contents of the main area (e.g., `plot_price`) to grow/shrink to the card container. Also, in a card context, it might make sense to hide the sidebar by default (`open = FALSE`), especially if space is limited (e.g., maybe you want [multiple cards with sidebars](layouts.html#responsive-column-first-layout)).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
card(
  full_screen = TRUE,
  card_header("Filter diamond price by cut and clarity"),
  card_sidebar(
    sidebar(filter_cut, filter_clarity, open = FALSE),
    plot_price,
    fillable = TRUE
  )
)
```

<br>

And, since `card_sidebar(...)` is implemented as `card_body_fill(class = "p-0", layout_sidebar(...))`, other `layout_sidebar()` arguments like `bg`, `class`, etc. can be also passed to `card_sidebar()` (to [customize](#customize) the main content area).[^6]

[^6]: To customize the `card_body_fill()` container (e.g., to set a `max_height`), consider explicitly using `card_body_fill(class = "p-0", layout_sidebar(...))` over `card_sidebar()`.

### Cards with tabs

It's also possible to embed a sidebar layout within a `card()`s that has multiple tabs/pills via `navs_tab_card()`/`navs_pill_card()`. And, similar to `page_navbar()`, a `sidebar()` can either be passed as an argument (i.e., global sidebar) or to a particular tab/pill (i.e., local sidebar).

#### Global sidebar

To show the same `sidebar()` on every tab/pill (i.e., create a "global" sidebar), pass it to the `sidebar` argument of `navs_tab_card()` (or `navs_pill_card()`).

Remember that, just like `layout_sidebar()` and `card()`, `navs_tab_card()` sizes itself according to it's contents (by default), so consider setting a `height` to keep a fixed height across all tabs. And, to allow the contents to grow/shrink to fit the card container, you'll want to wrap the contents of each tab with `card_body_fill()` (`wrapper = card_body_fill` is a convenient way to do this for all tabs).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  height = 450,
  full_screen = TRUE,
  wrapper = card_body_fill,
  nav("Tab 1", plot_price, plot_carat),
  nav("Tab 2", plot_depth)
)
```

#### Dynamic sidebar

Sometimes it's helpful to have the sidebar controls change depending on what page is active (especially with a global sidebar).[^5] Thanks to `shiny::conditionalPanel()`, this can be done fairly easily in a Shiny app:

```{r, eval = FALSE}
dynamic <- navs_tab_card(
  title = "Dynamic sidebar",
  sidebar = sidebar(
    filter_cut, filter_clarity,
    conditionalPanel(
      "input.nav === 'Page 2'",
      filter_color
    )
  ),
  id = "nav",
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth)
)

shinyApp(
  page_fixed(dynamic),
  function(input, output) {}
)
```

```{r}
# Yields similar result to the examples above
# (only difference is `color` filter appears on Page 2)
```

<br>


#### Local sidebar

To create a sidebar layout thatâ€™s specific to a page, place a `card_sidebar()` inside a tab (i.e., `nav()`) container (similar to how you would for [a `card()` without tabs](#cards)).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Tab-specific sidebar",
  full_screen = TRUE,
  nav(
    "Tab 1",
    card_sidebar(
      sidebar(filter_cut, filter_clarity),
      plot_price,
      fillable = TRUE
    )
  ),
  nav(
    "Tab 2",
    "Something else entirely"
  )
)
```

<br>


### Shiny

Inside a Shiny context, the `open` state of a `sidebar()` can programmatically updated and/or queried through an input value. Doing so requires that an `id` is provided to the `sidebar()`. Here's an example of using `sidebar_close()` and `sidebar_open()` to make sure the sidebar is open on `Page 1` but closed on `Page 2`.

```{r, eval = FALSE}
library(shiny)

ui <- page_navbar(
  title = "Sidebar example",
  id = "nav",
  sidebar = sidebar(id = "sidebar", filter_cut, filter_clarity),
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth)
)

server <- function(input, output) {
  observe({
    func <- if (input$nav == "Page 2") sidebar_close else sidebar_open
    func("sidebar")
  })
}

shinyApp(ui, server)
```


### Sidebar accordions

When an accordion appears as a immediate child inside `sidebar()`, they'll render "flush" to the sidebar, providing a convenient way to group multiple related input controls under a collapsible section.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
filters_acc <- accordion(
  open = TRUE,
  accordion_panel(
    "Cut", icon = bsicons::bs_icon("scissors"),
    filter_select("cut", NULL, dat, ~cut),
  ),
  accordion_panel(
    "Clarity", icon = bsicons::bs_icon("search"),
    filter_select("clarity", NULL, dat, ~clarity)
  )
)

layout_sidebar(sidebar(filters_acc), plot_price)
```

<br>

### Nested sidebars

It's possible to nest sidebar layouts, which means you can effectively have any number of left and/or right sidebars in a given layout. When doing this, you'll want the main content area of every `layout_sidebar()` that contains a `layout_sidebar()` to be fillable and have zero padding (`class = "p-0"`).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-fill-double, render=render_as_iframe, out.width="100%", out.extra='height=600px scrolling="no" seamless="seamless" frameBorder="0"'}
page_fill(
    h1(
        class = "lead fs-2 text-center bg-primary bg-gradient my-0 p-3",
        "Left and right sidebar"
    ),
    layout_sidebar(
        sidebar(filter_cut, filter_clarity),
        layout_sidebar(
            sidebar(filter_color, position = "right", open = FALSE),
            plot_price,
            border = FALSE
        ),
        border_radius = FALSE,
        fillable = TRUE,
        class = "p-0"
    )
)
```

### Styling and customization

Both `sidebar()` and `layout_sidebar()` have named arguments which, as we've already seen, are helpful for customizing the styling and behavior of both the sidebar and main content areas. In fact, the previous example demonstrated advanced usage of `sidebar()`'s `position` and `open` as well as `layout_sidebar()`'s `fillable`, `border`, etc. However, there are other useful arguments we haven't seen yet like `bg` color (when specified, a contrasting foreground color may also be provided to dark backgrounds "just work").

For other "lower-level" theming, you may want to leverage [Bootstrap utility `class`es]((https://getbootstrap.com/docs/5.3/utilities/spacing/)) and/or inline styles. When doing this, you'll want to be aware that `layout_sidebar()`'s `...` arguments (and thus `class`, `style`, etc.) are added to the main content's container (_not_ the overall layout container). So, to add `class` or `style` attributes on the layout `container`, use `htmltools::tagAppendAttributes()`. Note also that `layout_sidebar()` derives some of it's default style from Bootstrap CSS variables (e.g., `--bs-border-color`), which enables theming at the component-level ([theming via `bs_theme()`](bs5-variables.html) works on the page-level).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
library(htmltools)
library(leaflet)

squake <- SharedData$new(quakes)

container <- layout_sidebar(
  class = "p-0",
  sidebar(
    bg = "#1E1E1E",
    width = "35%",
    class = "fw-bold font-monospace",
    filter_slider("mag", "Magnitude", squake, ~mag)
  ),
  leaflet(squake) |> addTiles() |> addCircleMarkers()
)

tagAppendAttributes(container, style = css("--bs-border-color" = "darkgray"))
```

<br>
