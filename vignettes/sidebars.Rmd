---
title: "Sidebars"
output:
  html_document:
    theme:
      version: 5
resource_files:
  - infobox.svg
  - examples/sidebars
---

```{r setup, include=FALSE}
library(knitr)
library(htmltools)
library(bslib)

opts_chunk$set(message = FALSE)

render_as_iframe <- function(x, options, ...) {
  lbl <- opts_current$get("label")
  doc_name <- sub("[.]Rmd", "", knitr::current_input())
  lbl_dir <- file.path("examples", doc_name, lbl)
  if (!dir.exists(lbl_dir)) {
    dir.create(lbl_dir, recursive = TRUE)
  }
  file <- file.path(lbl_dir, paste0(lbl, ".html"))
  x <- tagList(x, tags$head(tags$style(".plotly { height: 250px !important; } .modebar-container { display: none; }")))
  tryCatch(
    save_html(x, file),
    error = function(e) {
      stop("Don't know how to render ", class(x)[[1]], " as an <iframe>")
    }
  )
  include_url(file)
}

knitr::opts_hooks$set(as_iframe = function(opts) {
  opts$render <- render_as_iframe
  opts$out.width <- "100%"
  opts$out.extra <- paste0(
    'height=600px seamless="seamless" frameBorder="0"',
    if (!isTRUE(opts$scrolling)) ' scrolling="no"',
    if (isTRUE(opts$resizable)) ' class="resizable"'
  )
  opts
})

# pkgdown really wants BS5+ markup for tabs, and this is currently the best way to achieving that :(
# (note this isn't a problem for any format based on html_document_base)
shiny:::setCurrentTheme(bslib::bs_theme())

# Each time we source this file, it'll give us a new crosstalk controls/views that use a different crosstalk group (this way, interactions won't be shared across chunks)
knitr::read_chunk(
  rprojroot::find_package_root_file("vignettes/sidebar-create-contents.R")
)

describe_layout_function <- function(name, description, element = NULL) {
  name <- knitr::combine_words(sprintf("<code>%s</code>", name),  and = " or ")

  if (is.null(element)) {
    element <- card_body_fill(
      class = "d-flex flex-column align-items-center",
      div(style = "width: 6em; height: 6em; background-color: gray")
    )
  }

  card(
    card_header(class = "bg-info", HTML(name)),
    element,
    card_footer(class = "bg-white", description)
  )
}
```

```{scss, echo = FALSE}
.plotly {
  height: 250px !important;
  .modebar-container {
    display: none;
  }
}
.html-widget {
  margin-bottom: 0;
}
iframe, .bslib-page-fill {
  height: 450px;
  border: var(--bs-border-width) solid var(--bs-border-color);
  margin-bottom: 4rem;
  box-shadow:
    rgba(0, 0, 0, 0.25) 0px 54px 55px,
    rgba(0, 0, 0, 0.12) 0px -12px 30px,
    rgba(0, 0, 0, 0.12) 0px 4px 6px,
    rgba(0, 0, 0, 0.17) 0px 12px 13px,
    rgba(0, 0, 0, 0.09) 0px -3px 5px;
}

iframe {
  margin-bottom: calc(55px + 2rem);
}

iframe.resizable {
  resize: vertical;
  min-height: 300px;
}

.card-header.bg-info code {
  background: none;
  color: hsl(209deg, 85%, 25%);
}
```

::: lead
Sidebar layouts in web interfaces allow your users to easily access filters, settings and other inputs alongside the interactive features they control.
In this article, you'll learn how to create sidebar layouts with bslib.
:::

## Introduction

To create a sidebar layout, provide a `sidebar()` to the `sidebar` argument of one of the following functions.

:::: {.row}
::: {.col-sm-12 .col-lg-6}
### Shared Sidebar {#intro-shared-sidebar}

When `sidebar` is an argument to a function containing multiple pages or panels, it creates a **shared sidebar**.

Provide a `sidebar()` to `page_navbar()` to recreate the classic [shinydashboard](http://rstudio.github.io/shinydashboard/) look with a global sidebar shared across several pages.

You can also add a shared sidebar to a card with tabs or pills created with `navs_tab_card()` or `navs_pill_card()`.
:::

::: {.col-sm-12 .col-lg-6 .text-center .mt-2 .mt-lg-4}
```{r preview-page-navbar, echo = FALSE}
describe_layout_function(
  "page_navbar()",
  "A shared sidebar in a multi-page layout.",
  card_body_fill(
    class = "p-0",
    height = 200,
    id = "page_navbar_example_card",
    navs_bar(
      collapsible = FALSE,
      fillable = TRUE,
      sidebar = sidebar("Shared sidebar", width = "33%", class = "bg-light"),
      nav("Page 1", "Page 1 content"),
      nav("Page 2", "Page 2 content")
    ),
    tags$script(HTML("$(document).ready(function() {
      var demo_nav = $('#page_navbar_example_card nav.navbar');
      setTimeout(function(){ demo_nav.headroom('destroy') }, 100);
    });"))
  ) |>
  tagAppendAttributes(class = "flex-row", .cssSelector = ".navbar-nav") |>
  tagAppendAttributes(class = "d-none", .cssSelector = ".navbar-header") |>
  tagAppendAttributes(class = "navbar-dark", .cssSelector = "nav")
)
```

```{r preview-navs-tab-card, echo = FALSE}
describe_layout_function(
  c("navs_tab_card()", "navs_pill_card()"),
  "A shared sidebar for tabs within a card.",
  card_body_fill(
    class = "p-2",
    height = 200,
    navs_tab_card(
      title = "Tab Card",
      sidebar = sidebar("Shared sidebar", width = "33%", class = "bg-light"),
      nav("Tab 1", "Tab 1 content"),
      nav("Tab 2", "Tab 2 content")
    )
  )
)
```
:::
::::

:::: {.row}
::: {.col-sm-12 .col-lg-6}
### Local Sidebar {#intro-local-sidebar}

Use `layout_sidebar()` whenever you want a **local sidebar** adjacent to a content panel.
`layout_sidebar()` creates a bordered area by default, making it useful anywhere in your interface.

It also fits nicely into `card()` components and `nav()` pages or tabs allowing you to add a sidebar to individual pages or tabs.
:::

::: {.col-sm-12 .col-lg-6 .text-center .mt-2 .mt-lg-4}
```{r preview-layout-sidebar, echo = FALSE}
describe_layout_function(
  "layout_sidebar()",
  "A flexible, local sidebar layout.",
  card_body_fill(
    class = "p-2",
    height = 200,
    layout_sidebar(
      sidebar = sidebar("Local sidebar", width = "33%", class = "bg-light"),
      "Content with a sidebar"
    )
  )
)
```
:::
::::

::: {.callout .callout-warning}
<h3 data-toc-skip>Prefer local sidebars</h3>

Although [shared sidebars](#shared-sidebar) have been popularized by packages like [shinydashboard](http://rstudio.github.io/shinydashboard/), they're not always ideal for creating a good user experience.

As a general rule, group sidebar controls as closely as possible with the contents they affect.
Use `layout_sidebar()` to group inputs in a [local sidebar](#local-sidebar) adjacent to the output they control.
Use global sidebars sparingly and only when the inputs in them are use across many outputs on your page.

Note that while we talk about shared and local sidebars in this article, those are properties of the interface design.
Controls placed in a sidebar aren't inherently limited to the outputs next to the sidebar.
It's your job as the app designer to choose where the controls appear and to ensure a good user experience.
:::

In the next few sections, we'll dive a little deeper into each of the sidebar layout functions listed above.

## Setup

In this article, we'll explore the flexibility of bslib's sidebar layouts by showing many variations of the same inputs and outputs to filter and visualize diamond quality data[^diamonds].

In a Shiny app[^1], you'll probably want to use inputs like `shiny::selectInput()`, `shiny::sliderInput()`, etc., in the sidebar, but because you're reading this article in a static website, we'll use [crosstalk](https://rstudio.github.io/crosstalk/) input widgets.

[^diamonds]: The diamonds in our data set are a 1,000 rows randomly sampled from `ggplot2::diamonds`.
[^1]: In a Shiny app, we also recommend you add an `id` to the `sidebar()` so that you can reactively read/update whether the sidebar is open/closed.

```{r, sidebar-create-contents}
```

## Foundations

We'll start with the most common sidebar layout: a page-level sidebar.
With bslib, `page_navbar()` provides a modern version of `shiny::navbarPage()` to create a "multi-page app"[^2].
`page_navbar()` not only defaults to a modern version of Bootstrap, but also includes a `sidebar` argument to let you add a shared sidebar to all pages.

[^2]: These functions don't actually make what web developers would consider a  multi-page app since they don't actually request different HTML pages (they are based on Bootstrap nav components).

### Shared sidebar {#shared-sidebar}

To show the same `sidebar()` on every page -- i.e. a _shared_ or _global_ sidebar  --- pass a `sidebar()` to the `sidebar` argument of `page_navbar()`:

```{r navbar-global, as_iframe = TRUE}
page_navbar(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

Try changing the filter selections while switching between Page 1 and Page 2.
The changes you make to the filters while looking at one page are also used to update the plots on other page(s).
This is a good use of a shared sidebar because the same inputs control all plots in the shared container, which in this case is the pages of the app.

### Local sidebar {#local-sidebar}

When your inputs aren't shared across outputs in your app or page, you can create a _local sidebar_ with `layout_sidebar()`.
Place a `layout_sidebar()` inside a `nav()` container to create a sidebar adjacent to the content items included in your `layout_sidebar()`.
In the example below, we used a sidebar layout for the filter controls for the plot on Page 1 without including these inputs next to the unrelated map on Page 2.

```{r navbar-local-scroll, as_iframe = TRUE, scrolling = TRUE}
page_navbar(
  title = "Local sidebar",
  fluid = FALSE,
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity, width = 175),
      plot_price,
      plot_carat
    ),
    h3("More content in page 1...")
  ),
  nav("Page 2", map_quakes)
)
```

Notice that `layout_sidebar()` includes a border by default and doesn't fill its parent page container.
In fact, there is content on Page 1 below the container with the sidebar -- and that content could even include other containers with local sidebar layouts.

In the next section, we'll show you how to determine the scrolling or filling behavior of each sidebar content areas.

### Scrolling layout

By default, `layout_sidebar()` provides rounded borders and padding around the container so that it can easily be dropped into any larger page.
In this way, the `layout_sidebar()` container is like a pared-down `card()` component.

Like [cards](cards.html), by default, the vertical height of the sidebar layout container will grow with the size of its contents.

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  plot_price, plot_carat
)
```
:::
::::

If you have a lot of content in a `layout_sidebar()`, one option is to specify a `height` for the container to make its contents scrollable.

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short-300}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long-300}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  plot_price, plot_carat
)
```
:::
::::

### Filling layout

If, instead of scrolling the content area, you want to allow the contents of the sidebar layout to resize themselves to the container height, also set `fillable = TRUE`.

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short-fillable}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  fillable = TRUE,
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long-fillable}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  fillable = TRUE,
  plot_price, plot_carat
)
```
:::
::::

By setting `fillable = TRUE`, we tell `layout_sidebar()` that its main content area should be a _fillable container_.
Fillable containers work together with _fill items_.
When a container is fillable, any fill items in the container will grow or shrink to fill all available space in the container.
Because plotly plots are fill items, they grow or shrink to fill the available space of the fillable container in which they are placed.

In the next section, we'll see how we can use fillable pages for full-height sidebar layouts.

## Page sidebars

### Navbar pages

Like many other layout functions in bslib, `page_navbar()` includes a `fillable` argument.
When `fillable = TRUE`, the main content areas, i.e. the pages, inside the `page_navbar()` become _fillable containers_.
Fillable containers work together with _fill items_.
When a container is fillable, any fill items in the container will grow or shrink to fill all available space in the container.

Let's return to the shared sidebar example.
If we set `fillable = TRUE` in `page_navbar()`, any fill items in each page will grow or shrink to fill the main content area.
Because plotly plots are fill items, the single plot on Page 2 will grow to fill the entire page container and the plots on Page 1 will each shrink so that both plots fit in the page (in the [previous example](#shared-sidebar-1) you had to scroll down to see the second plot).

```{r navbar-global-fillable, as_iframe = TRUE, resizable = TRUE}
page_navbar(
  title = "Global sidebar w/ fill",
  sidebar = sidebar(filter_cut, filter_clarity),
  fillable = TRUE,
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

`layout_sidebar()` creates a container to hold the sidebar and content area that, like a plotly plot, is also a fill item.
To create a single-page sidebar layout that fills the browser window we need to place the `layout_sidebar()` in a fillable container.
As we just saw, with `page_navbar()` we can make all pages fillable with `fillable = TRUE`.
Alternatively, we can provide `fillable` with a vector of page titles to make an individual page fillable.
We'll take the alternate approach in the following example to make only the first page fillable.

```{r navbar-local-fill-outer, as_iframe = TRUE, scrolling = TRUE, resizable = TRUE}
page_navbar(
  title = "Local sidebar",
  fillable = "Page 1",
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity, width = 175),
      plot_price,
      plot_carat
    )
  ),
  nav("Page 2", map_quakes)
)
```

To fully recreate the global sidebar look for the first page, you might also want to set `fillable = TRUE` in `layout_sidebar()`.
Then, the plotly plots (which are fill items) will fill the main content area of the sidebar layout (which is a fillable container _and_ a fill item), and the sidebar layout will, in turn, fill the page (which is a fillable container).

```{r navbar-local-fill, as_iframe = TRUE, resizable = TRUE}
page_navbar(
  title = "Local sidebar w/ fill",
  fillable = "Page 1",
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity),
      fillable = TRUE,
      border = FALSE,
      plot_price,
      plot_carat
    )
  ),
  nav("Page 2", map_quakes)
)
```

The example above has resizable height.
Try resizing the page frame by grabbing the lower right corner to see how the plots grow and shrink to fill their container's height.

### Other pages

Most of the previous section focused on sidebar layouts within `page_navbar()`.
As we saw in the [filling](#filling-layouts) and [scrolling layouts](#scrolling-layouts) sections above, `layout_sidebar()` can be also used inside any Bootstrap `page()`: it works with `page_fixed()`, `page_fluid()`, `page_fill()`, and more.
It's also very uesful within `card()` components, which we'll cover in the next section.


So far all of our examples have used `page_navbar()`, but the same filling behavior can be used in any fillable container.
One such page layout is `page_fill()`, which produces a fillable container by definition.

```{r page-fill, as_iframe = TRUE}
page_fill(
  title = "My filled page",
  h1("My filled page", class = "px-3 my-3"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity),
    border_radius = FALSE,
    "Scroll down for another plot ðŸ‘‡",
    plot_price,
    plot_carat
  )
)
```


```{r page-scroll, as_iframe = TRUE, scrolling = TRUE}
page_fixed(
  h1("My scrolling page", class = "lead fs-2 my-3"),
  layout_sidebar(
    height = 325,
    sidebar(filter_cut, filter_clarity),
    "Scroll down for another plot ðŸ‘‡",
    plot_price, plot_carat
  ),
  br(),
  layout_sidebar(
    height = 350,
    fillable = TRUE,
    sidebar(filter_color, position = "right"),
    "No scrolling here",
    plot_price, plot_carat
  ),
  br()
)
```

Note that this idea of scrolling multiple sidebar layouts concept also works with a `page_fluid()` or `page()` container (the only difference is the amount of horizontal padding provided on the page level). If, instead of scrolling at the page level, you want sidebar layout(s) to fit the browser window, consider using `page_fill()`.


## Cards

`layout_sidebar()` can also be dropped into a `card()`, which is especially convenient for adding a `card_header()`, `card_footer()`, or even `full_screen = TRUE` behavior. If you do want `full_screen = TRUE` (and/or specify a `height`), then you may also want `fillable = TRUE` to allow the contents of the main area (e.g., `plot_price`) to grow/shrink to the card container. Also, in a card context, it might make sense to hide the sidebar by default (`open = FALSE`), especially if space is limited (e.g., maybe you want [multiple cards with sidebars](layouts.html#responsive-column-first-layout)).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
card(
  full_screen = TRUE,
  card_header("Filter diamond price by cut and clarity"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity, open = FALSE),
    plot_price,
    fillable = TRUE
  )
)
```

## Cards with tabs

It's also possible to embed a sidebar layout within a `card()`s that has multiple tabs/pills via `navs_tab_card()`/`navs_pill_card()`. And, similar to `page_navbar()`, a `sidebar()` can either be passed as an argument (i.e., global sidebar) or to a particular tab/pill (i.e., local sidebar).

### Global sidebar

To show the same `sidebar()` on every tab/pill (i.e., create a "global" sidebar), pass it to the `sidebar` argument of `navs_tab_card()` (or `navs_pill_card()`).

Remember that, just like `layout_sidebar()` and `card()`, `navs_tab_card()` sizes itself according to it's contents (by default), so consider setting a `height` to keep a fixed height across all tabs. And, to allow the contents to grow/shrink to fit the card container, you'll want to wrap the contents of each tab with `card_body_fill()` (`wrapper = card_body_fill` is a convenient way to do this for all tabs).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  height = 450,
  full_screen = TRUE,
  wrapper = card_body_fill,
  nav("Tab 1", plot_price, plot_carat),
  nav("Tab 2", plot_depth)
)
```

### Dynamic sidebar

Sometimes it's helpful to have the sidebar controls change depending on what page is active (especially with a global sidebar).[^4] Thanks to `shiny::conditionalPanel()`, this can be done fairly easily in a Shiny app:

```{r, eval = FALSE}
dynamic <- navs_tab_card(
  title = "Dynamic sidebar",
  sidebar = sidebar(
    filter_cut, filter_clarity,
    conditionalPanel(
      "input.nav === 'Page 2'",
      filter_color
    )
  ),
  id = "nav",
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth)
)

shinyApp(
  page_fixed(dynamic),
  function(input, output) {}
)
```

```{r}
# Yields similar result to the examples above
# (only difference is `color` filter appears on Page 2)
```

### Local sidebar

To create a sidebar layout that's specific to a page, place a `layout_sidebar()` inside a tab (i.e., `nav()`) container (similar to how you would for [a `card()` without tabs](#cards)).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Tab-specific sidebar",
  full_screen = TRUE,
  nav(
    "Tab 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity),
      plot_price,
      fillable = TRUE
    )
  ),
  nav(
    "Tab 2",
    "Something else entirely"
  )
)
```

## Shiny

### Dynamic sidebar

Sometimes it's helpful to have the sidebar controls change depending on what page is active (especially with a global sidebar).[^4] Thanks to `shiny::conditionalPanel()`, this can be done fairly easily in a Shiny app:

[^4]: If the controls depend on some other application state, we can also, of course, use `shiny::uiOutput()` to fill the contents of a `sidebar()`).

```{r, eval = FALSE}
shinyApp(
  page_navbar(
    title = "Dynamic sidebar",
    sidebar = sidebar(
      filter_cut, filter_clarity,
      conditionalPanel(
        "input.nav === 'Page 2'",
        filter_color
      )
    ),
    id = "nav",
    nav("Page 1", plot_price, plot_carat),
    nav("Page 2", plot_depth)
  ),
  function(input, output) {}
)
```

```{r}
# Yields similar result to the examples above
# (only difference is `color` filter appears on Page 2)
```

### Sidebar state

Inside a Shiny context, the `open` state of a `sidebar()` can programmatically updated and/or queried through an input value. Doing so requires that an `id` is provided to the `sidebar()`. Here's an example of using `sidebar_close()` and `sidebar_open()` to make sure the sidebar is open on `Page 1` but closed on `Page 2`.

```{r, eval = FALSE}
library(shiny)

ui <- page_navbar(
  title = "Sidebar example",
  id = "nav",
  sidebar = sidebar(id = "sidebar", filter_cut, filter_clarity),
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth)
)

server <- function(input, output) {
  observe({
    if (input$nav == "Page 2") {
      sidebar_close("sidebar")
     } else {
      sidebar_open("sidebar")
     }
  })
}

shinyApp(ui, server)
```

## Sidebar accordions

When an accordion appears as a immediate child inside `sidebar()`, they'll render "flush" to the sidebar, providing a convenient way to group multiple related input controls under a collapsible section.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
filters_acc <- accordion(
  open = TRUE,
  accordion_panel(
    "Cut", icon = bsicons::bs_icon("scissors"),
    filter_select("cut", NULL, dat, ~cut),
  ),
  accordion_panel(
    "Clarity", icon = bsicons::bs_icon("search"),
    filter_select("clarity", NULL, dat, ~clarity)
  )
)

layout_sidebar(sidebar(filters_acc), plot_price)
```

## Nested sidebars

It's possible to nest sidebar layouts, which means you can effectively have any number of left and/or right sidebars in a given layout. When doing this, you'll want the main content area of every `layout_sidebar()` that contains a `layout_sidebar()` to be fillable and have zero padding (`class = "p-0"`).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-fill-double, as_iframe = TRUE}
page_fill(
    h1(
        class = "lead fs-2 text-center bg-primary bg-gradient my-0 p-3",
        "Left and right sidebar"
    ),
    layout_sidebar(
        sidebar(filter_cut, filter_clarity),
        layout_sidebar(
            sidebar(filter_color, position = "right", open = FALSE),
            plot_price,
            border = FALSE
        ),
        border_radius = FALSE,
        fillable = TRUE,
        class = "p-0"
    )
)
```

## Styling and customization

Both `sidebar()` and `layout_sidebar()` have named arguments which, as we've already seen, are helpful for customizing the styling and behavior of both the sidebar and main content areas. In fact, the previous example demonstrated advanced usage of `sidebar()`'s `position` and `open` as well as `layout_sidebar()`'s `fillable`, `border`, etc. However, there are other useful arguments we haven't seen yet like `bg` color (when specified, a contrasting foreground color may also be provided to dark backgrounds "just work").

For other "lower-level" theming, you may want to leverage [Bootstrap utility `class`es]((https://getbootstrap.com/docs/5.3/utilities/spacing/)) and/or inline styles. When doing this, you'll want to be aware that `layout_sidebar()`'s `...` arguments (and thus `class`, `style`, etc.) are added to the main content's container (_not_ the overall layout container). So, to add `class` or `style` attributes on the layout `container`, use `htmltools::tagAppendAttributes()`. Note also that `layout_sidebar()` derives some of it's default style from Bootstrap CSS variables (e.g., `--bs-border-color`), which enables theming at the component-level ([theming via `bs_theme()`](bs5-variables.html) works on the page-level).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
library(htmltools)
library(leaflet)

squake <- SharedData$new(quakes)

container <- layout_sidebar(
  class = "p-0",
  sidebar(
    bg = "#1E1E1E",
    width = "35%",
    class = "fw-bold font-monospace",
    filter_slider("mag", "Magnitude", squake, ~mag)
  ),
  leaflet(squake) |> addTiles() |> addCircleMarkers()
)

tagAppendAttributes(container, style = css("--bs-border-color" = "darkgray"))
```
