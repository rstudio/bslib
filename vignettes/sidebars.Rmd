---
title: "Sidebars"
output:
  html_document:
    theme:
      version: 5
resource_files:
  - infobox.svg
  - examples/sidebars
---

```{r setup, include=FALSE}
library(knitr)
library(htmltools)
library(bslib)

opts_chunk$set(message = FALSE)

render_as_iframe <- function(x, options, ...) {
  lbl <- opts_current$get("label")
  doc_name <- sub("[.]Rmd", "", knitr::current_input())
  lbl_dir <- file.path("examples", doc_name, lbl)
  if (!dir.exists(lbl_dir)) {
    dir.create(lbl_dir, recursive = TRUE)
  }
  file <- file.path(lbl_dir, paste0(lbl, ".html"))
  x <- tagList(x, tags$head(tags$style(".html-widget { height: 250px !important; } .modebar-container { display: none; }")))
  tryCatch(
    save_html(x, file),
    error = function(e) {
      stop("Don't know how to render ", class(x)[[1]], " as an <iframe>")
    }
  )
  include_url(file)
}

knitr::opts_hooks$set(as_iframe = function(opts) {
  opts$render <- render_as_iframe
  opts$out.width <- "100%"
  opts$out.extra <- paste0(
    'seamless="seamless" frameBorder="0" loading="lazy"',
    if (isFALSE(opts$scrolling)) ' scrolling="no"',
    if (isTRUE(opts$resizable)) ' class="resizable"'
  )
  opts
})

# pkgdown really wants BS5+ markup for tabs, and this is currently the best way to achieving that :(
# (note this isn't a problem for any format based on html_document_base)
shiny:::setCurrentTheme(bslib::bs_theme())

describe_layout_function <- function(name, description, element = NULL) {
  name <- knitr::combine_words(sprintf("<code>%s</code>", name),  and = " or ")

  if (is.null(element)) {
    element <- card_body(
      class = "d-flex flex-column align-items-center",
      div(style = "width: 6em; height: 6em; background-color: gray")
    )
  }

  card(
    card_header(class = "bg-info text-center", HTML(name)),
    element,
    card_footer(class = "bg-white text-center", description)
  )
}
```

```{scss, echo = FALSE}
.plotly {
  height: 250px !important;
  .modebar-container {
    display: none;
  }
}
iframe, .bslib-page-fill {
  height: 500px;
  border: var(--bs-border-width) solid var(--bs-border-color);
}

iframe.resizable {
  resize: vertical;
  min-height: 200px;
}

.card-header.bg-info code {
  background: none;
  color: hsl(209deg, 85%, 25%);
}
```

::: lead
Sidebar layouts in web interfaces allow your users to easily access filters, settings and other inputs alongside the interactive features they control.
In this article, you'll learn how to create sidebar layouts with bslib.
:::

## Overview

There are three main types of sidebar layouts: floating, filled, and multi-page/tab. In any scenario, start by creating a `sidebar()` object. And, unless you want a `sidebar()` to be shared across [multiple pages/tabs](#multi-page-layout), pass that object to `layout_sidebar()`.

:::: {.row .mt-3}
### Floating layout

For a sidebar layout that can go anywhere on any page, first provide a `sidebar()` object to `layout_sidebar()`. The `layout_sidebar()` can also be placed inside a `card()` to add a header/footer, full screen expansion, and more. This layout approach is great for visually grouping together semantically related inputs and output(s):

::: {.col-sm-12 .col-lg-6}

<details>
<summary>Show code</summary>
```r
layout_sidebar(
  sidebar = sidebar("Sidebar"),
  "Main contents"
)
```
</details>

```{r preview-layout-sidebar, echo = FALSE}
describe_layout_function(
  "layout_sidebar()",
  "A sidebar layout.",
  card_body(
    class = "p-2",
    height = 200,
    layout_sidebar(
      sidebar = sidebar("Sidebar", width = "33%", class = "bg-light"),
      "Main contents"
    ) |>
      tagAppendAttributes(class = "border rounded-top")
  )
)
```
:::

::: {.col-sm-12 .col-lg-6}

<details>
<summary>Show code</summary>
```r
card(
  full_screen = TRUE,
  card_header("Title"),
  layout_sidebar(
    sidebar = sidebar("Sidebar"),
    "Main contents"
  )
)
```
</details>

```{r preview-layout-sidebar-card, echo = FALSE}
describe_layout_function(
  "layout_sidebar() in card()",
  "A sidebar layout within a card.",
  card_body(
    class = "p-2",
    height = 200,
    card(
      full_screen = TRUE,
      card_header("Title"),
      layout_sidebar(
        sidebar = sidebar("Sidebar", width = "33%", class = "bg-light"),
        "Main contents"
      )
    )
  )
)
```
:::
::::


:::: {.row .mt-5}
### Filling layout

::: {.col-sm-12 .col-lg-6}
For a sidebar layout that fills the entire page, pass `layout_sidebar()` directly to `page_fillable()`. However, if your app has multiple groups of input and outputs, a floating layout (for each group) is often preferable to a filling layout. That's because, when a sidebar fills the page, it gives the impression that its controls impact _everything_ in the main content area.
:::

::: {.col-sm-12 .col-lg-6}

<details>
<summary>Show code</summary>
```r
page_fillable(
  layout_sidebar(
    sidebar = sidebar("Sidebar area"),
    "Main area"
  )
)
```
</details>

```{r preview-page-fillable, echo = FALSE}
describe_layout_function(
  "layout_sidebar() in page_fillable()",
  "A sidebar that fills the page.",
  card_body(
    class = "p-0",
    height = 200,
    page_fillable(
      layout_sidebar(
        sidebar = sidebar("Sidebar", width = "33%", class = "bg-light"),
        "Main contents"
      )
    )
  ) |>
  tagAppendAttributes(class = "flex-row", .cssSelector = ".navbar-nav") |>
  tagAppendAttributes(class = "d-none", .cssSelector = ".navbar-header") |>
  tagAppendAttributes(class = "navbar-dark", .cssSelector = "nav")
)
```
:::
::::


:::: {.row .mt-5}

### Multi-page layout

For a multi-page (or multi-tab) layout, pass a `sidebar()` to the `sidebar` argument of `page_navbar()` (or `navs_tab_card()`). In this case, we get a sidebar that not only fills the page, but also _remains visible on every page/tab_. Later on, we'll explore how to [put sidebar layouts inside of particular pages](#multi-page-example); but also keep in mind, if it's desirable to have a sidebar on every page, it often helps to [hide/show sidebar contents on certain pages](#conditional-contents) via `conditionalPanel()`.

::: {.col-sm-12 .col-lg-6}

<details>
<summary>Show code</summary>
```r
page_navbar(
  sidebar = sidebar("Sidebar"),
  nav("Page 1", "Page 1 content"),
  nav("Page 2", "Page 2 content")
)
```
</details>

```{r preview-page-navbar, echo = FALSE}
describe_layout_function(
  "page_navbar()",
  "A sidebar shared across multiple pages.",
  card_body(
    class = "p-0",
    height = 200,
    id = "page_navbar_example_card",
    navs_bar(
      collapsible = FALSE,
      sidebar = sidebar("Shared sidebar", width = "33%", class = "bg-light"),
      nav("Page 1", "Page 1 content"),
      nav("Page 2", "Page 2 content")
    ),
    tags$script(HTML("$(document).ready(function() {
      // pkgdown activates headroom on the navs_bar() container and ends up
      // auto-hiding our navbar, so this destroys the unwanted headroom instance
      var demo_nav = $('#page_navbar_example_card nav.navbar');
      setTimeout(function() {
        if (demo_nav.headroom) demo_nav.headroom('destroy')
      }, 100);
    });"))
  ) |>
  tagAppendAttributes(class = "flex-row", .cssSelector = ".navbar-nav") |>
  tagAppendAttributes(class = "d-none", .cssSelector = ".navbar-header") |>
  tagAppendAttributes(class = "navbar-dark", .cssSelector = "nav")
)
```
:::

::: {.col-sm-12 .col-lg-6}

<details>
<summary>Show code</summary>
```r
navs_tab_card(
  sidebar = sidebar("Sidebar"),
  nav("Tab 1", "Tab 1 content"),
  nav("Tab 2", "Tab 2 content")
)
```
</details>

```{r preview-navs-tab-card, echo = FALSE}
describe_layout_function(
  "navs_tab_card()",
  "A sidebar shared across multiple tabs.",
  card_body(
    class = "p-2",
    height = 200,
    navs_tab_card(
      title = "Tab Card",
      sidebar = sidebar("Shared sidebar", width = "33%", class = "bg-light"),
      nav("Tab 1", "Tab 1 content"),
      nav("Tab 2", "Tab 2 content")
    )
  )
)
```
:::
::::


## A real example

Now that we've enumerated bslib's sidebar layout options, lets use some real data[^real-data] to create some real inputs and outputs, and explore some additional features of sidebar layouts.

In a Shiny app[^shiny-id], you'll probably want to use inputs like `selectInput()`, `sliderInput()`, etc., in the sidebar, but because you're reading this article in a static website, we'll use [crosstalk](https://rstudio.github.io/crosstalk/) input widgets.

[^real-data]: Our "real data" is just a 1,000 rows randomly sampled from `{ggplot2}`'s `diamonds` data as well as `{leaflet}`'s `quakes`.
[^shiny-id]: In a Shiny app, we also recommend you add an `id` to the `sidebar()` so that you can reactively read/update whether the sidebar is open/closed.

### Setup code

Throughout this section, we'll make repeated use of the following widgets from `{plotly}` and `{leaflet}`. The details on how these widgets work alongside `{crosstalk}` to create linked views isn't important for understanding sidebar layouts, but do keep in mind this will give us a list of `filters` and `plots` (views of the `diamonds` dataset), as well as `map_filter` and `map_quakes` (views of the `quakes` dataset).

<details>
<summary>Show code</summary>
```{r}
library(bslib)
library(shiny)
library(crosstalk)
library(plotly)
library(leaflet)

# Creates the "filter link" between the controls and plots
dat <- SharedData$new(dplyr::sample_n(diamonds, 1000))

# Sidebar elements (e.g., filter controls)
filters <- list(
  filter_select("cut", "Cut", dat, ~cut),
  filter_select("color", "Color", dat, ~color),
  filter_select("clarity", "Clarity", dat, ~clarity)
)

# plotly visuals
plots <- list(
  plot_ly(dat) |> add_histogram(x = ~price),
  plot_ly(dat) |> add_histogram(x = ~carat),
  plot_ly(dat) |> add_histogram(x = ~cut, color = ~clarity)
)
plots <- lapply(plots, \(x) config(x, displayModeBar = FALSE))

# map filter and visual
quake_dat <- SharedData$new(quakes)
map_filter <- filter_slider("mag", "Magnitude", quake_dat, ~mag)
map_quakes <- leaflet(quake_dat) |>
  addTiles() |>
  addCircleMarkers()

```
</details>

### Fillable contents

Since `layout_sidebar()` is a fill item (defaults to `fill = TRUE`), it fills a fillable container with an opinionated height (e.g., `page_fillable()` which sets it's height to `100%` of the browser window). However, the _main content area_ of the layout is not a fillable container by default, so set `fillable = TRUE` if fill items in the main content area (i.e., `plots`) should also fill.

```{r, as_iframe = TRUE, resizable = TRUE}
# NOTE: in attempt keep the code brief, we make use of rlang's
# splice operator (!!!) https://rlang.r-lib.org/reference/splice-operator.html
diamonds_view <- layout_sidebar(
  sidebar = sidebar(
    title = "Diamond filters",
    !!!filters
  ),
  fillable = TRUE,
  border = FALSE,
  border_radius = FALSE,
  !!!plots
)

page_fillable(
  padding = 0,
  diamonds_view
)
```

:::: {.row .my-3}
::: {.col-sm-12 .col-lg-6}
::: {.callout .callout-note}
<h3 data-toc-skip>Resizable example</h3>

The example above is resizable. Try using the handle in the lower-right corner to change the "window" size and notice how the plot grow/shrink to fit the window (because of `fillable = TRUE`).
:::
:::

::: {.col-sm-12 .col-lg-6 .mt-auto .mb-auto}
::: {.callout .callout-note}
<h3 data-toc-skip>Filling layouts</h3>

To learn more about how fillable containers and fill items work, see the article on [filling layouts](filling.html).
:::
:::
::::

### Multi-page, multi-layout {#multi-page-example}

As we saw in the [overview](#overview), providing a `sidebar()` to the `sidebar` argument of `page_navbar()` puts a sidebar _on each page_ that fills the window. However, sometimes it's better that only particular pages have such a sidebar layout. In this case, you can provide a `layout_sidebar()` as a "root" element of a particular page, then use `page_navbar()`'s `fillable` argument to make that element fill the window.

For example, let's put the same `diamonds_view` sidebar layout on it's own filled page (via `fillable = "Diamonds"`), and leverage a [floating layout](#floating-layout) for a view of the `quakes` data. The floating layout provides a more flexible way to group input controls next the outputs that they effect, which would be especially important if we had multiple output groups on the "Earthquakes" page.

```{r, as_iframe = TRUE, resizable = TRUE}
quakes_view <- card(
  full_screen = TRUE,
  card_header("Earthquake locations"),
  layout_sidebar(
    sidebar(map_filter),
    map_quakes
  )
)

page_navbar(
  title = "Sidebar demo",
  fillable = "Diamonds",
  nav("Diamonds", diamonds_view),
  nav("Earthquakes", quakes_view)
)
```


:::: {.row .my-3}
::: {.col-sm-12 .col-lg-6}
::: {.callout .callout-note}
<h3 data-toc-skip>The fillable argument</h3>

You might have noticed other UI elements like `layout_sidebar()`, `card_body()`, `layout_column_wrap()`, etc., also have a `fillable` argument. In those cases, it's just a boolean value for whether or not the element should be a [fillable container](filling.html). In `page_navbar()`'s case, it can be used to target specific page(s) (by matching their `title`) and/or all pages (`fillable = TRUE`).
:::
:::

::: {.col-sm-12 .col-lg-6 .mt-auto .mb-auto}
::: {.callout .callout-note}
<h3 data-toc-skip>Multi-tab, multi-layout</h3>

As we saw in the [overview](#overview), providing a `sidebar()` to the `sidebar` argument of `navs_tab_card()` puts a sidebar inside every tab of a multi-tab card. However, just like how we can provide a `layout_sidebar()` to a particular page (as shown above), the same can be done with `navs_tab_card()`.
:::
:::
::::


### Restricting growth

With a [floating layout](#floating-layout), the layout container's size matches the size of it's contents (just like [cards do](cards.html#restricting-growth)). Thus, if there a large amount of sidebar/main contents, consider specifying a `height` or `max_height` via `card()` (as well as `full_screen = TRUE` to reduce the need for scrolling).

```{r, as_iframe = TRUE, resizable = TRUE}
page_fixed(
  h2("Diamonds data", class = "lead mt-3"),
  card(
    max_height = 350,
    full_screen = TRUE,
    layout_sidebar(
      sidebar = sidebar(!!!filters),
      "Scroll for more plots 👇",
      !!!plots
    )
  )
)
```

Although we don't show it here, do keep in mind that setting `fillable=TRUE` in `layout_sidebar()` would allow the fill items (i.e., `plots`) to shrink/grow to fit the `card()` containers specified size.


## Shiny

Although sidebars work just fine outside Shiny, using them in Shiny provides a few additional useful features.

### Conditional contents

Sometimes in a multiple page/tab setting, it's useful to have a sidebar on every page/tab, but changes it's contents based on which page/tab is active.[^4] Thanks to `conditionalPanel()`, this can be done fairly easily in a Shiny app with `page_navbar()` (or in `navs_tab_card()`/`navs_tab_pill()`). The trick is to provide an `id` to the `page_navbar()` and then reference that `id` in the `conditionalPanel()`:

[^4]: If the controls depend on some other application state, you'll need to use `uiOutput()` to fill the contents of a `sidebar()`).

:::: row
::: {.col-sm-12 .col-lg-6}
```{r, eval = FALSE}
shinyApp(
  page_navbar(
    title = "Conditional sidebar",
    id = "nav",
    sidebar = sidebar(
      conditionalPanel(
        "input.nav === 'Page 1'",
        "Page 1 sidebar"
      ),
      conditionalPanel(
        "input.nav === 'Page 2'",
        "Page 2 sidebar"
      )
    ),
    nav("Page 1", "Page 1 contents"),
    nav("Page 2", "Page 2 contents")
  ),
  server = function(...) {
    # no server logic required
  }
)
```
:::

::: {.col-sm-12 .col-lg-6 .mt-auto .mb-auto}
```{r shiny-dynamic-sidebar, echo = FALSE, as_iframe = TRUE}
page_navbar(
  title = "Conditional sidebar",
  id = "nav",
  sidebar = sidebar(
    conditionalPanel(
      "input.nav === 'Page 1'",
      "Page 1 sidebar"
    ),
    conditionalPanel(
      "input.nav === 'Page 2'",
      "Page 2 sidebar"
    )
  ),
  nav("Page 1", "Page 1 contents"),
  nav("Page 2", "Page 2 contents"),
  footer = htmltools::tags$script(htmltools::HTML("
var $page1,$page2;
$(document).ready(function() {
  $page1 = $(`[data-display-if*='Page 1']`);
  $page2 = $(`[data-display-if*='Page 2']`);
  $page2.hide();
});

$('#nav').on('shown.bs.tab', function(ev) {
  const page = ev.target.dataset.value;
  page === 'Page 2' ? $page1.hide() : $page1.show();
  page === 'Page 1' ? $page2.hide() : $page2.show();
});
"
  ))
)
```
:::
::::
:::
::::


### Reactive updates

To programmatically update (and/or re-actively read) the open/closed state of a `sidebar()`, provide an `id` and reference that `id` in your server code. Here we reference use the `id` to programmatically open the sidebar on the 2nd page.


:::: row
::: {.col-sm-12 .col-lg-6}
```{r eval = FALSE}
library(shiny)

ui <- page_navbar(
  title = "Sidebar updates",
  id = "nav",
  sidebar = sidebar(
    id = "sidebar",
    open = FALSE,
    "Sidebar"
  ),
  nav("Page 1", "Sidebar closed. Go to Page 2 to open."),
  nav("Page 2", "Sidebar open. Go to Page 1 to close.")
)

server <- function(input, output) {
  observe({
    sidebar_toggle(
      id = "sidebar",
      open = input$nav == "Page 2"
    )
  })
}

shinyApp(ui, server)
```
:::
:::

::: {.col-sm-12 .col-lg-6 .mt-auto .mb-auto}
```{r shiny-sidebar-state, echo = FALSE, as_iframe = TRUE}
page_navbar(
  title = "Sidebar updates",
  id = "nav",
  collapsible = FALSE,
  sidebar = sidebar(id = "sidebar", open = FALSE, "Sidebar"),
  nav("Page 1", "Sidebar closed. Go to Page 2 to open."),
  nav("Page 2", "Sidebar open. Go to Page 1 to close."),
  footer = htmltools::tags$script(htmltools::HTML("
$('#nav').on('shown.bs.tab', function(ev) {
  const page = ev.target.dataset.value;
  const layout = document.getElementById('sidebar').parentElement;
  const open = page === 'Page 2' ? 'open' : 'close';
  window.bslib.Sidebar.toggle(layout, open);
});"
  ))
)
```
:::
::::




## Accordions

All sidebars have special treatment for accordions.
When an `accordion()` appears directly within a `sidebar()` (as an immediate child of the sidebar), the accordion panels will render flush to the sidebar, providing a convenient way to group multiple related input controls under a collapsible section.

::: {.callout .callout-note}
<h3 data-toc-skip>Setup code</h3>

This example depends on objects from the [setup code section](#setup-code).
:::

```{r}
accordion_filters <- accordion(
  accordion_panel(
    "Dropdowns", icon = bsicons::bs_icon("menu-app"),
    !!!filters
  ),
  accordion_panel(
    "Numerical", icon = bsicons::bs_icon("sliders"),
    filter_slider("depth", "Depth", dat, ~depth),
    filter_slider("table", "Table", dat, ~table)
  )
)

card(
  card_header("Groups of diamond filters"),
  layout_sidebar(
    fillable = TRUE,
    sidebar(accordion_filters),
    plots[[1]]
  )
)
```


## Nested sidebars

It's possible to nest sidebar layouts, which means you can effectively have any number of left and/or right sidebars in a given layout. When doing this, you'll want the main content area of every `layout_sidebar()` that contains a `layout_sidebar()` to be fillable and have zero padding (`class = "p-0"`).

```{r page-fill-double, as_iframe = TRUE}
page_fillable(
  h1("Left and right sidebar", class = "px-3 my-3"),
  layout_sidebar(
    sidebar("Left sidebar"),
    layout_sidebar(
        sidebar("Right sidebar", position = "right", open = FALSE),
        "Main contents",
        border = FALSE
    ),
    border_radius = FALSE,
    fillable = TRUE,
    class = "p-0"
  )
)
```

## Styling and customization

In the above sections we've focused primarily on the variety of interface layouts where sidebars can be used.
Along the way, we've touched on a few of the named arguments of `sidebar()` and `layout_sidebar()` that are helpful for customizing the styling and behavior of both the sidebar and main content areas.
However, there are a handful of other arguments to further customize the look and feel if the sidebar layout.

Both `sidebar()` and `layout_sidebar()` allow for a specific background color (via `bg`), which is applied to the sidebar area and main content area respectively.
When `bg` is provided, bslib automatically provides a high-contrast foreground color to ensure readability (but a `fg` color may also be provided).
Both functions also include a `class` argument that works well with [Bootstrap utility `class`es](https://getbootstrap.com/docs/5.3/utilities/spacing/) and a `style` argument for inline styles.

Be aware that in `layout_sidebar()`, `bg`, `class` and `style` attributes are applied to the main content area's container and _not_ the overall layout container.
To add additional classes to the layout container, use `htmltools::tagAppendAttributes()`.
Also note that `layout_sidebar()` derives some of it's default style from Bootstrap CSS variables (e.g., `--bs-card-border-color`), which enables theming at the component-level ([theming via `bs_theme()`](bs5-variables.html) works on the page-level).

The following example combines all of these concepts to create sidebar with a dark background.
Utility classes are used to make the sidebar text monospace and bold, and we used `tagAppendAttributes()` to tweak the border color of the sidebar layout to match the sidebar background.

```{r}
library(htmltools)
library(leaflet)

squake <- SharedData$new(quakes)

container <- layout_sidebar(
  class = "p-0",
  sidebar(
    title = "Earthquakes off Fiji",
    bg = "#1E1E1E",
    width = "35%",
    class = "fw-bold font-monospace",
    filter_slider("mag", "Magnitude", squake, ~mag)
  ),
  leaflet(squake) |> addTiles() |> addCircleMarkers()
)

tagAppendAttributes(container, style = css("--bs-card-border-color" = "#1E1E1E"))
```


