---
title: "Sidebars"
output:
  html_document:
    theme:
      version: 5
resource_files:
  - infobox.svg
  - examples/sidebars
---

```{r setup, include=FALSE}
library(knitr)
library(htmltools)
library(bslib)

opts_chunk$set(message = FALSE)

render_as_iframe <- function(x, options, ...) {
  lbl <- opts_current$get("label")
  doc_name <- sub("[.]Rmd", "", knitr::current_input())
  lbl_dir <- file.path("examples", doc_name, lbl)
  if (!dir.exists(lbl_dir)) {
    dir.create(lbl_dir, recursive = TRUE)
  }
  file <- file.path(lbl_dir, paste0(lbl, ".html"))
  x <- tagList(x, tags$head(tags$style(".plotly { height: 250px !important; } .modebar-container { display: none; }")))
  tryCatch(
    save_html(x, file),
    error = function(e) {
      stop("Don't know how to render ", class(x)[[1]], " as an <iframe>")
    }
  )
  include_url(file)
}

knitr::opts_hooks$set(as_iframe = function(opts) {
  opts$render <- render_as_iframe
  opts$out.width <- "100%"
  opts$out.extra <- paste0(
    'height=600px seamless="seamless" frameBorder="0" loading="lazy"',
    if (!isTRUE(opts$scrolling)) ' scrolling="no"',
    if (isTRUE(opts$resizable)) ' class="resizable"'
  )
  opts
})

# pkgdown really wants BS5+ markup for tabs, and this is currently the best way to achieving that :(
# (note this isn't a problem for any format based on html_document_base)
shiny:::setCurrentTheme(bslib::bs_theme())

# Each time we source this file, it'll give us a new crosstalk controls/views that use a different crosstalk group (this way, interactions won't be shared across chunks)
knitr::read_chunk(
  rprojroot::find_package_root_file("vignettes/sidebar-create-contents.R")
)

describe_layout_function <- function(name, description, element = NULL) {
  name <- knitr::combine_words(sprintf("<code>%s</code>", name),  and = " or ")

  if (is.null(element)) {
    element <- card_body_fill(
      class = "d-flex flex-column align-items-center",
      div(style = "width: 6em; height: 6em; background-color: gray")
    )
  }

  card(
    card_header(class = "bg-info", HTML(name)),
    element,
    card_footer(class = "bg-white", description)
  )
}
```

```{scss, echo = FALSE}
.plotly {
  height: 250px !important;
  .modebar-container {
    display: none;
  }
}
.html-widget {
  margin-bottom: 0;
}
iframe, .bslib-page-fill {
  height: 450px;
  border: var(--bs-border-width) solid var(--bs-border-color);
  margin-bottom: 4rem;
  box-shadow:
    rgba(0, 0, 0, 0.25) 0px 54px 55px,
    rgba(0, 0, 0, 0.12) 0px -12px 30px,
    rgba(0, 0, 0, 0.12) 0px 4px 6px,
    rgba(0, 0, 0, 0.17) 0px 12px 13px,
    rgba(0, 0, 0, 0.09) 0px -3px 5px;
}

iframe {
  margin-bottom: calc(55px + 2rem);
}

iframe.resizable {
  resize: vertical;
  min-height: 300px;
}

.card-header.bg-info code {
  background: none;
  color: hsl(209deg, 85%, 25%);
}
```

::: lead
Sidebar layouts in web interfaces allow your users to easily access filters, settings and other inputs alongside the interactive features they control.
In this article, you'll learn how to create sidebar layouts with bslib.
:::

## Introduction

To create a sidebar layout, provide a `sidebar()` to the `sidebar` argument of one of the following functions.

:::: {.row}
::: {.col-sm-12 .col-lg-6}
### Shared Sidebar {#intro-shared-sidebar}

When `sidebar` is an argument to a function containing multiple pages or panels, it creates a **shared sidebar**.

Provide a `sidebar()` to `page_navbar()` to recreate the classic [shinydashboard](http://rstudio.github.io/shinydashboard/) look with a global sidebar shared across several pages.

You can also add a shared sidebar to a card with tabs or pills created with `navs_tab_card()` or `navs_pill_card()`.
:::

::: {.col-sm-12 .col-lg-6 .text-center .mt-2 .mt-lg-4}
```{r preview-page-navbar, echo = FALSE}
describe_layout_function(
  "page_navbar()",
  "A shared sidebar in a multi-page layout.",
  card_body_fill(
    class = "p-0",
    height = 200,
    id = "page_navbar_example_card",
    navs_bar(
      collapsible = FALSE,
      fillable = TRUE,
      sidebar = sidebar("Shared sidebar", width = "33%", class = "bg-light"),
      nav("Page 1", "Page 1 content"),
      nav("Page 2", "Page 2 content")
    ),
    tags$script(HTML("$(document).ready(function() {
      var demo_nav = $('#page_navbar_example_card nav.navbar');
      setTimeout(function(){ demo_nav.headroom('destroy') }, 100);
    });"))
  ) |>
  tagAppendAttributes(class = "flex-row", .cssSelector = ".navbar-nav") |>
  tagAppendAttributes(class = "d-none", .cssSelector = ".navbar-header") |>
  tagAppendAttributes(class = "navbar-dark", .cssSelector = "nav")
)
```

```{r preview-navs-tab-card, echo = FALSE}
describe_layout_function(
  c("navs_tab_card()", "navs_pill_card()"),
  "A shared sidebar for tabs within a card.",
  card_body_fill(
    class = "p-2",
    height = 200,
    navs_tab_card(
      title = "Tab Card",
      sidebar = sidebar("Shared sidebar", width = "33%", class = "bg-light"),
      nav("Tab 1", "Tab 1 content"),
      nav("Tab 2", "Tab 2 content")
    )
  )
)
```
:::
::::

:::: {.row}
::: {.col-sm-12 .col-lg-6}
### Local Sidebar {#intro-local-sidebar}

Use `layout_sidebar()` whenever you want a **local sidebar** adjacent to a content panel.
`layout_sidebar()` creates a bordered area by default, making it useful anywhere in your interface.

It also fits nicely into `card()` components and `nav()` pages or tabs allowing you to add a sidebar to individual pages or tabs.
:::

::: {.col-sm-12 .col-lg-6 .text-center .mt-2 .mt-lg-4}
```{r preview-layout-sidebar, echo = FALSE}
describe_layout_function(
  "layout_sidebar()",
  "A flexible, local sidebar layout.",
  card_body_fill(
    class = "p-2",
    height = 200,
    layout_sidebar(
      sidebar = sidebar("Local sidebar", width = "33%", class = "bg-light"),
      "Content with a sidebar"
    )
  )
)
```
:::
::::

::: {.callout .callout-warning}
<h3 data-toc-skip>Prefer local sidebars</h3>

Although [shared sidebars](#shared-sidebar) have been popularized by packages like [shinydashboard](http://rstudio.github.io/shinydashboard/), they're not always ideal for creating a good user experience.

As a general rule, group sidebar controls as closely as possible with the contents they affect.
Use `layout_sidebar()` to group inputs in a [local sidebar](#local-sidebar) adjacent to the output they control.
Use global sidebars sparingly and only when the inputs in them are use across many outputs on your page.

Note that while we talk about shared and local sidebars in this article, those are properties of the interface design.
Controls placed in a sidebar aren't inherently limited to the outputs next to the sidebar.
It's your job as the app designer to choose where the controls appear and to ensure a good user experience.
:::

In the next few sections, we'll dive a little deeper into each of the sidebar layout functions listed above.

## Setup

In this article, we'll explore the flexibility of bslib's sidebar layouts by showing many variations of the same inputs and outputs to filter and visualize diamond quality data[^diamonds].

In a Shiny app[^1], you'll probably want to use inputs like `shiny::selectInput()`, `shiny::sliderInput()`, etc., in the sidebar, but because you're reading this article in a static website, we'll use [crosstalk](https://rstudio.github.io/crosstalk/) input widgets.

[^diamonds]: The diamonds in our data set are a 1,000 rows randomly sampled from `ggplot2::diamonds`.
[^1]: In a Shiny app, we also recommend you add an `id` to the `sidebar()` so that you can reactively read/update whether the sidebar is open/closed.

```{r, sidebar-create-contents}
```

## Foundations

We'll start with the most common sidebar layout: a page-level sidebar.
With bslib, `page_navbar()` provides a modern version of `shiny::navbarPage()` to create a "multi-page app"[^2].
`page_navbar()` not only defaults to a modern version of Bootstrap, but also includes a `sidebar` argument to let you add a shared sidebar to all pages.

[^2]: These functions don't actually make what web developers would consider a  multi-page app since they don't actually request different HTML pages (they are based on Bootstrap nav components).

### Shared sidebar {#shared-sidebar}

To show the same `sidebar()` on every page -- i.e. a _shared_ or _global_ sidebar  --- pass a `sidebar()` to the `sidebar` argument of `page_navbar()`:

```{r navbar-global, as_iframe = TRUE}
page_navbar(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

Try changing the filter selections while switching between Page 1 and Page 2.
The changes you make to the filters while looking at one page are also used to update the plots on other page(s).
This is a good use of a shared sidebar because the same inputs control all plots in the shared container, which in this case is the pages of the app.

### Local sidebar {#local-sidebar}

When your inputs aren't shared across outputs in your app or page, you can create a _local sidebar_ with `layout_sidebar()`.
Place a `layout_sidebar()` inside a `nav()` container to create a sidebar adjacent to the content items included in your `layout_sidebar()`.
In the example below, we used a sidebar layout for the filter controls for the plot on Page 1 without including these inputs next to the unrelated map on Page 2.

```{r navbar-local-scroll, as_iframe = TRUE, scrolling = TRUE}
page_navbar(
  title = "Local sidebar",
  fluid = FALSE,
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity, width = 175),
      plot_price,
      plot_carat
    ),
    h3("More content in page 1...")
  ),
  nav("Page 2", map_quakes)
)
```

Notice that `layout_sidebar()` includes a border by default and doesn't fill its parent page container.
In fact, there is content on Page 1 below the container with the sidebar -- and that content could even include other containers with local sidebar layouts.

In the next section, we'll show you how to determine the scrolling or filling behavior of each sidebar content areas.

### Scrolling layout

By default, `layout_sidebar()` provides rounded borders and padding around the container so that it can easily be dropped into any larger page.
In this way, the `layout_sidebar()` container is like a pared-down `card()` component.

Like [cards](cards.html), by default, the vertical height of the sidebar layout container will grow with the size of its contents.

```{r, sidebar-create-contents, echo=FALSE}
```

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  plot_price, plot_carat
)
```
:::
::::

If you have a lot of content in a `layout_sidebar()`, one option is to specify a `height` for the container to make its contents scrollable.

```{r, sidebar-create-contents, echo=FALSE}
```

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short-300}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long-300}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  plot_price, plot_carat
)
```
:::
::::

### Filling layout

If, instead of scrolling the content area, you want to allow the contents of the sidebar layout to resize themselves to the container height, also set `fillable = TRUE`.

```{r, sidebar-create-contents, echo=FALSE}
```

:::: {.row}
::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-short-fillable}
layout_sidebar(
  sidebar("Short sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  fillable = TRUE,
  plot_depth
)
```
:::

::: {.col-lg-6 .col-sm-12 .mb-3}
```{r scroll-layout-long-fillable}
layout_sidebar(
  sidebar("Long sidebar layout", width = "33%", class = "bg-light"),
  height = 300,
  fillable = TRUE,
  plot_price, plot_carat
)
```
:::
::::

By setting `fillable = TRUE`, we tell `layout_sidebar()` that its main content area should be a _fillable container_.
Fillable containers work together with _fill items_.
When a container is fillable, any fill items in the container will grow or shrink to fill all available space in the container.
Because plotly plots are fill items, they grow or shrink to fill the available space of the fillable container in which they are placed.

In the next section, we'll see how we can use fillable pages for full-height sidebar layouts.

## Page sidebars

Our [first example](#shared-sidebar) used the `sidebar` argument of `page_navbar()` to create a shared sidebar across all pages in the app.
In this section, we'll explore a few more page-based sidebar layouts.

### Navbar pages

Let's return to the [shared sidebar example](#shared-sidebar) and apply the concepts we learned about in [Filling layout](#filling-layout).
If we set `fillable = TRUE` in `page_navbar()`, any fill items in each page will grow or shrink to fill the main content area.
Recall that plotly plots are fill items, so the plots on each fillable page will grow or shrink to fill the available space.

```{r navbar-global-fillable, as_iframe = TRUE, resizable = TRUE}
page_navbar(
  title = "Global sidebar w/ fill",
  sidebar = sidebar(filter_cut, filter_clarity),
  fillable = TRUE,
  nav("Page 1", plot_price, plot_carat),
  nav("Page 2", plot_depth)
)
```

Suppose we want to include a full-height sidebar on just one page of our app because the other pages include unrelated outputs.
Like plotly plots, `layout_sidebar()` containers are also fill items by default.
We can create a local sidebar for Page 1 with `layout_sidebar()` and we can take advantage of the fact that, in addition to accepting logical values, `fillable` in `page_navber()` can accept a vector of page titles.
We'll take this alternate approach in the following example to make only the first page fillable.

```{r navbar-local-fill-outer, as_iframe = TRUE, scrolling = TRUE, resizable = TRUE}
page_navbar(
  title = "Local sidebar",
  fillable = "Page 1",
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity, width = 175),
      border = FALSE,
      plot_price,
      plot_carat
    )
  ),
  nav("Page 2", map_quakes)
)
```

Notice that the sidebar is full height but the plots are in a scrolling region.
Which option do we need to change to make the plots also fill the page?

If we want fill items, in this case the plotly plots, to fill available space, we need to make their containing element a fillable container.
We can do this by setting `fillable = TRUE` in `layout_sidebar()`.
Then, the plotly plots (which are fill items) will fill the main content area of the sidebar layout (which is a fillable container _and_ a fill item), and the sidebar layout will, in turn, fill the page (which is a fillable container).

```{r navbar-local-fill, as_iframe = TRUE, resizable = TRUE}
page_navbar(
  title = "Local sidebar w/ fill",
  fillable = "Page 1",
  nav(
    "Page 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity),
      fillable = TRUE,
      border = FALSE,
      plot_price,
      plot_carat
    )
  ),
  nav("Page 2", map_quakes)
)
```

The examples above all have resizable height.
Try resizing the page frame by grabbing the lower right corner to see how the plots grow and shrink to fit in their fillable container's height.

### Other pages

Most of our examples so far have focused on sidebar layouts within `page_navbar()`, but `layout_sidebar()` can be also used inside any Bootstrap `page()`: it works with `page_fixed()`, `page_fluid()`, `page_fill()`, and more.

For example, instead of `page_navbar()`, we can add a full-page sidebar to `page_fill()` because `page_fill()` produces a fillable container by definition that `layout_sidebar()` will fill[^why-scrollable].

[^why-scrollable]: **Check your understanding:** Why do you have to scroll to see the second plot? How would you make the plots fill the page too?

```{r page-fill, as_iframe = TRUE}
page_fill(
  title = "My filled page",
  h1("My filled page", class = "px-3 my-3"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity),
    border_radius = FALSE,
    "Scroll down for another plot ðŸ‘‡",
    plot_price,
    plot_carat
  )
)
```


## Cards

You can create a sidebar layout within a `card()` simply by adding `layout_sidebar()` within the card next to other card elements like `card_header()` and `card_footer()`.

The sidebar even works with the `full_screen = TRUE` option, in which case you probably also want to set `fillable = TRUE` in `layout_sidebar()` so that its contents will grow or shrink to fill the card container.
Also, consider hiding the sidebar by default within cards by setting `open = FALSE` within `sidebar()`, especially if space is limited or if you have [multiple cards with sidebars in a responsive layout](layouts.html#responsive-column-first-layout).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
card(
  full_screen = TRUE,
  style = "max-height: 300px",
  card_header("Filter diamond price by cut and clarity"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity, lorem::ipsum(5), open = FALSE),
    plot_price,
    fillable = TRUE
  )
)
```

## Cards with tabs

It's also possible to embed a sidebar layout within a `card()`s that has multiple tabs or pills with `navs_tab_card()` or `navs_pill_card()`.
As with `page_navbar()`, you can create a [shared sidebar](#card-tabs-shared-sidebar) using the `sidebar` argument of `navs_tab_card()` or `navs_pill_card()`.
Or you can create use `layout_sidebar()` to create a [local sidebar](#card-tabs-local-sidebar) for a particular tab pane.

### Shared sidebar {#card-tabs-shared-sidebar}

To show the same `sidebar()` on every tab pane, pass it to the `sidebar` argument of `navs_tab_card()` or `navs_pill_card()`.

You'll also probably want to set the card `height` as well (we chose `height = 450` in the example below) to keep a fixed card height across all tabs.
If you want the tab contents to fill the available card height, wrap the card elements in `card_body_fillable()` or set `wrapper = card_body_fillable` so that it's used for all tab cards.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Global sidebar",
  sidebar = sidebar(filter_cut, filter_clarity),
  height = 450,
  full_screen = TRUE,
  wrapper = card_body_fillable,
  nav("Tab 1", plot_price, plot_carat),
  nav("Tab 2", plot_depth)
)
```

### Local sidebar {#card-tabs-local-sidebar}

To create a sidebar layout that's specific to a page, place a `layout_sidebar()` inside the tab's `nav()` container.

In this example, we've used `fillable = TRUE` in the `layout_sidebar()` on the first tab so that plots fill the tab's card body.
When you expand the example card below, the plotly plot on Tab 1 will grow but the map on Tab 2 will keep the same height.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
navs_tab_card(
  title = "Tab-specific sidebar",
  height = 450,
  full_screen = TRUE,
  nav(
    "Tab 1",
    layout_sidebar(
      sidebar(filter_cut, filter_clarity),
      fillable = TRUE,
      plot_price
    )
  ),
  nav("Tab 2", map_quakes)
)
```

## Shiny

FIXME: Link here from sections above.

When used within Shiny apps, sidebars provide a few additional features you can leverage.

### Sidebar state

In a shiny app, whether or not the `sidebar()` is opened reported through an input named after the `id` of the sidebar.
In the following Shiny UI, the sidebar has `id = "sidebar"`.
In the server logic, `input$sidebar` will report `TRUE` when the sidebar is opened and `FALSE` when the sidebar is closed.

```{r eval = FALSE}
library(shiny)

ui <- page_navbar(
  title = "Sidebar example",
  id = "nav",
  sidebar = sidebar(id = "sidebar", filter_cut, filter_clarity),
  fillable = "Page 2",
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth)
)
```

You can also open and close the sidebar reactively in your Shiny `server` function using `sidebar_open()` and `sidebar_close()` and the sidebar `id`.
In the following chunk, we read the current navbar page and close the sidebar on Page 2 and re-open it on Page 1.

```{r, eval = FALSE}
server <- function(input, output) {
  observe({
    if (input$nav == "Page 1") {
      sidebar_open("sidebar")
     } else {
      sidebar_close("sidebar")
     }
  })
}

shinyApp(ui, server)
```


```{r shiny-sidebar-state, echo = FALSE, as_iframe = TRUE}
page_navbar(
  title = "Sidebar example",
  id = "nav",
  fillable = "Page 2",
  sidebar = sidebar(
    id = "sidebar",
    filter_cut,
    filter_clarity
  ),
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth),
  footer = htmltools::tags$script(htmltools::HTML("
$('#nav').on('shown.bs.tab', function(ev) {
  const page = ev.target.dataset.value;
  const $sb = $('.bslib-sidebar-layout > .bslib-sidebar-input');
  if (page === 'Page 2') {
    $sb.parent().addClass('sidebar-collapsed');
  } else {
    $sb.parent().removeClass('sidebar-collapsed');
  }
  $sb.trigger('toggleCollapse.sidebarInputBinding');
  setTimeout(function() {
    const resizeEvent = new Event('resize');
    window.dispatchEvent(resizeEvent);
  }, 500);
});"
  ))
)
```


### Dynamic sidebar

When [shared sidebars](#shared-sidebar) include the same inputs in several pages or tabs, it's sometimes helpful to have the sidebar controls change depending on which page or tab is active. Thanks to `shiny::conditionalPanel()`[^4], this can be done fairly easily in a Shiny app with `page_navvar()` or in `navs_tab_card()` or `navs_tab_pill()`.

[^4]: If the controls depend on some other application state, we can also, of course, use `shiny::uiOutput()` to fill the contents of a `sidebar()`).

```{r, eval = FALSE}
shinyApp(
  page_navbar(
    title = "Dynamic sidebar",
    id = "nav",
    sidebar = sidebar(
      filter_cut, filter_clarity,
      conditionalPanel(
        "input.nav === 'Page 2'",
        filter_color
      )
    ),
    fillable = "Page 2",
    nav("Page 1", plot_price, plot_carat),
    nav("Page 2", plot_depth)
  ),
  server = function(...) {
    # no server logic required
  }
)
```

```{r shiny-dynamic-sidebar, echo = FALSE, as_iframe = TRUE}
page_navbar(
  title = "Sidebar example",
  id = "nav",
  fillable = "Page 2",
  sidebar = sidebar(
    id = "sidebar",
    filter_cut,
    filter_clarity,
    div(id = "sidebar-page-2", class = "hidden", filter_color)
  ),
  nav("Page 1", plot_price),
  nav("Page 2", plot_carat, plot_depth),
  footer = htmltools::tags$script(htmltools::HTML("
$('#sidebar-page-2').hide();

$('#nav').on('shown.bs.tab', function(ev) {
  const page = ev.target.dataset.value;
  page === 'Page 2' ? $('#sidebar-page-2').show() : $('#sidebar-page-2').hide();
});
"
  ))
)
```

## Accordians

All sidebars have special treatment for accordians.
When an `accordion()` appears directly within a `sidebar()` (as an immediate child of the sidebar), the accordian panels will render flush to the sidebar, providing a convenient way to group multiple related input controls under a collapsible section.

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
filters_acc <- accordion(
  open = TRUE,
  accordion_panel(
    "Cut", icon = bsicons::bs_icon("scissors"),
    filter_select("cut", NULL, dat, ~cut),
  ),
  accordion_panel(
    "Clarity", icon = bsicons::bs_icon("search"),
    filter_select("clarity", NULL, dat, ~clarity)
  )
)

layout_sidebar(sidebar(filters_acc), plot_price)
```

## Nested sidebars

It's possible to nest sidebar layouts, which means you can effectively have any number of left and/or right sidebars in a given layout. When doing this, you'll want the main content area of every `layout_sidebar()` that contains a `layout_sidebar()` to be fillable and have zero padding (`class = "p-0"`).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r page-fill-double, as_iframe = TRUE}
page_fill(
  h1("Left and right sidebar", class = "px-3 my-3"),
  layout_sidebar(
    sidebar(filter_cut, filter_clarity),
    layout_sidebar(
        sidebar(filter_color, position = "right", open = FALSE),
        plot_price,
        border = FALSE
    ),
    border_radius = FALSE,
    fillable = TRUE,
    class = "p-0"
  )
)
```

## Styling and customization

Both `sidebar()` and `layout_sidebar()` have named arguments which, as we've already seen, are helpful for customizing the styling and behavior of both the sidebar and main content areas. In fact, the previous example demonstrated advanced usage of `sidebar()`'s `position` and `open` as well as `layout_sidebar()`'s `fillable`, `border`, etc. However, there are other useful arguments we haven't seen yet like `bg` color (when specified, a contrasting foreground color may also be provided to dark backgrounds "just work").

For other "lower-level" theming, you may want to leverage [Bootstrap utility `class`es]((https://getbootstrap.com/docs/5.3/utilities/spacing/)) and/or inline styles. When doing this, you'll want to be aware that `layout_sidebar()`'s `...` arguments (and thus `class`, `style`, etc.) are added to the main content's container (_not_ the overall layout container). So, to add `class` or `style` attributes on the layout `container`, use `htmltools::tagAppendAttributes()`. Note also that `layout_sidebar()` derives some of it's default style from Bootstrap CSS variables (e.g., `--bs-border-color`), which enables theming at the component-level ([theming via `bs_theme()`](bs5-variables.html) works on the page-level).

```{r, sidebar-create-contents, echo=FALSE}
```

```{r}
library(htmltools)
library(leaflet)

squake <- SharedData$new(quakes)

container <- layout_sidebar(
  class = "p-0",
  sidebar(
    bg = "#1E1E1E",
    width = "35%",
    class = "fw-bold font-monospace",
    filter_slider("mag", "Magnitude", squake, ~mag)
  ),
  leaflet(squake) |> addTiles() |> addCircleMarkers()
)

tagAppendAttributes(container, style = css("--bs-border-color" = "darkgray"))
```
