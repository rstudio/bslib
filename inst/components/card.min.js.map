{
  "version": 3,
  "sources": ["../../srcts/src/components/_documentObserver.ts", "../../srcts/src/components/_utils.ts", "../../srcts/src/components/card.ts"],
  "sourcesContent": ["/**\n * The DocumentObserver class creates an observer detecting all DOM changes,\n * watching for added or removed elements (or their children) that match\n * the specified selectors. When a matching element is added or removed, the\n * respective callback function is called. The DocumentObserver is insensitive\n * to when it's instantiated; it always runs `added.callback()` once on the\n * document body (waiting for DOMContentLoaded if necessary) and then starts\n * watching the DOM for added/removed elements.\n */\n\ninterface DocumentObserverConfig {\n  added: {\n    selector: string;\n    callback: (node: HTMLElement) => void;\n  };\n  removed: {\n    selector: string;\n    callback: (node: HTMLElement) => void;\n  };\n}\n\nclass DocumentObserver {\n  private observer: MutationObserver;\n  private config: DocumentObserverConfig;\n\n  constructor(config: DocumentObserverConfig) {\n    const mutationObserverCallback = (mutationsList: MutationRecord[]) => {\n      for (const mutation of mutationsList) {\n        if (mutation.type === \"childList\") {\n          for (const addedNode of mutation.addedNodes) {\n            if (addedNode.nodeType !== Node.ELEMENT_NODE) continue;\n            this._callback(addedNode as HTMLElement, this.config.added);\n          }\n          for (const removedNode of mutation.removedNodes) {\n            if (removedNode.nodeType !== Node.ELEMENT_NODE) continue;\n            this._callback(removedNode as HTMLElement, this.config.removed);\n          }\n        }\n      }\n    };\n\n    this.config = config;\n    this.observer = new MutationObserver(mutationObserverCallback);\n    if (document.readyState === \"complete\") {\n      this.connect();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => this.connect());\n    }\n  }\n\n  private _callback(\n    el: HTMLElement,\n    {\n      selector,\n      callback,\n    }: { selector: string; callback: (node: HTMLElement) => void }\n  ) {\n    const elMatches = el.matches(selector);\n    const hasMatchingChild = el.querySelector(selector);\n    if (!elMatches && !hasMatchingChild) return;\n    if (elMatches) callback(el);\n    if (!hasMatchingChild) return;\n    el.querySelectorAll(selector).forEach((node) =>\n      callback(node as HTMLElement)\n    );\n  }\n\n  connect(): void {\n    this._callback(document.body, this.config.added);\n    this.observer.observe(document, { childList: true, subtree: true });\n  }\n\n  disconnect(): void {\n    this.observer.disconnect();\n  }\n}\n\nexport { DocumentObserver };\nexport type { DocumentObserverConfig };\n", "import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  const selectors = [\n    \"[href]\",\n    \"input:not([disabled])\",\n    \"button:not([disabled])\",\n    \"select:not([disabled])\",\n    \"summary:not(:disabled)\",\n    \"details:not([disabled])\",\n    \"textarea:not([disabled])\",\n    '[tabindex]:not([tabindex=\"-1\"]):not([disabled])',\n  ];\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n};\nexport type { HtmlDep };\n", "import type { Tooltip as TooltipType } from \"bootstrap\";\nimport type { ShinyEventValue } from \"rstudio-shiny/srcts/types/src/events/shinyEvents\";\nimport { DocumentObserver } from \"./_documentObserver\";\nimport { getAllFocusableChildren } from \"./_utils\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Tooltip = (\n  window.bootstrap ? window.bootstrap.Tooltip : class {}\n) as typeof TooltipType;\n\ninterface CardOverlay {\n  container: HTMLDivElement;\n  anchor: HTMLAnchorElement;\n}\n\nclass Card {\n  private container: HTMLElement;\n  private overlay: CardOverlay;\n  private cardResizeObserver: ResizeObserver;\n  private shinyOutputResizeObserver: ResizeObserver | undefined;\n  private lastFocusInterior: HTMLElement | undefined;\n  private prevFocusExterior: HTMLElement | undefined;\n\n  private static attr = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ATTR_INIT: \"data-bslib-card-needs-init\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_CARD: \"bslib-card\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_FULL_SCREEN: \"bslib-full-screen\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_HAS_FULL_SCREEN: \"bslib-has-full-screen\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_FULL_SCREEN_ENTER: \"bslib-full-screen-enter\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_FULL_SCREEN_EXIT: \"bslib-full-screen-exit\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ID_FULL_SCREEN_OVERLAY: \"bslib-full-screen-overlay\",\n  };\n\n  constructor(el: HTMLElement) {\n    el.removeAttribute(Card.attr.ATTR_INIT);\n\n    this.container = el;\n    Card.instanceMap.set(el, this);\n\n    // Let Shiny know to trigger resize when the card size changes\n    // TODO: shiny could/should do this itself (rstudio/shiny#3682)\n    const resizeEvent = new Event(\"resize\");\n    this.cardResizeObserver = new ResizeObserver(() => {\n      window.dispatchEvent(resizeEvent);\n    });\n    this.cardResizeObserver.observe(this.container);\n\n    this._addEventListeners();\n    this._enableTooltips();\n    this._startShinyOutputResizeObserver();\n    this.overlay = this._createOverlay();\n  }\n\n  enterFullScreen(event?: Event): void {\n    if (event) event.preventDefault();\n\n    this.overlay.container.addEventListener(\"click\", () =>\n      this.exitFullScreen()\n    );\n    document.addEventListener(\n      \"keyup\",\n      (ev) => this._exitFullScreenOnEscape(ev),\n      false\n    );\n\n    const focusableElements = getAllFocusableChildren(this.container);\n    if (focusableElements.length > 0) {\n      // set focus on first focusable element in the card\n      focusableElements[0].focus();\n      // store the last focusable element so we can cycle focus\n      this.lastFocusInterior = focusableElements[focusableElements.length - 1];\n    } else {\n      // this card doesn't have any focusable elements, so focus is vaguely\n      // within the card (having clicked the full screen button). We're can't\n      // know exactly where focus is located (we've hidden the button), so we\n      // attach a listener to the next Tab keydown event to entrap focus within\n      // the full screen card.\n      this.lastFocusInterior = this.overlay.anchor;\n      if (!this.container.contains(document.activeElement)) {\n        this.prevFocusExterior = document.activeElement as HTMLElement;\n        this.prevFocusExterior.addEventListener(\n          \"keydown\",\n          (ev) => this._entrapFocus(ev),\n          { once: true }\n        );\n      }\n    }\n\n    if (this.lastFocusInterior) {\n      this.lastFocusInterior.onkeydown = (ev) => {\n        // If tabbing forwards out of the card, return to close button\n        if (ev.key === \"Tab\" && !ev.shiftKey) {\n          ev.preventDefault();\n          this.overlay.anchor.focus();\n        }\n      };\n    }\n\n    this.container.classList.add(Card.attr.CLASS_FULL_SCREEN);\n    document.body.classList.add(Card.attr.CLASS_HAS_FULL_SCREEN);\n    this.container.insertAdjacentElement(\"beforebegin\", this.overlay.container);\n  }\n\n  exitFullScreen(): void {\n    // Remove event listeners that were added when entering full screen\n    this.overlay.container.removeEventListener(\"click\", () =>\n      this.exitFullScreen()\n    );\n\n    if (this.lastFocusInterior) {\n      this.lastFocusInterior.onkeydown = null;\n    }\n\n    document.removeEventListener(\n      \"keyup\",\n      (ev) => this._exitFullScreenOnEscape(ev),\n      false\n    );\n\n    // Remove overlay and remove full screen classes from card\n    this.overlay.container.remove();\n    this.container.classList.remove(Card.attr.CLASS_FULL_SCREEN);\n    document.body.classList.remove(Card.attr.CLASS_HAS_FULL_SCREEN);\n\n    // Reset focus tracking state\n    this.lastFocusInterior = undefined;\n    this.prevFocusExterior = undefined;\n  }\n\n  destroy(): void {\n    this._removeEventListeners();\n    this.cardResizeObserver.disconnect();\n    if (this.shinyOutputResizeObserver) {\n      this.shinyOutputResizeObserver.disconnect();\n    }\n    Card.instanceMap.delete(this.container);\n  }\n\n  private _addEventListeners(): void {\n    const btnFullScreen = this.container.querySelector(\n      `:scope > .${Card.attr.CLASS_FULL_SCREEN_ENTER}`\n    );\n    if (!btnFullScreen) return;\n    btnFullScreen.addEventListener(\"click\", (ev) => this.enterFullScreen(ev));\n  }\n\n  private _removeEventListeners(): void {\n    const btnFullScreen = this.container.querySelector(\n      `:scope > .${Card.attr.CLASS_FULL_SCREEN_ENTER}`\n    );\n    if (!btnFullScreen) return;\n    btnFullScreen.removeEventListener(\"click\", (ev) =>\n      this.enterFullScreen(ev)\n    );\n  }\n\n  private _enableTooltips(): void {\n    const selector = `.${Card.attr.CLASS_FULL_SCREEN_ENTER}[data-bs-toggle='tooltip']`;\n    if (!this.container.querySelector(selector)) {\n      return;\n    }\n    const tooltipList = this.container.querySelectorAll(selector);\n    tooltipList.forEach((tt) => new Tooltip(tt));\n  }\n\n  private _startShinyOutputResizeObserver(): void {\n    // In some complex fill-based layouts with multiple outputs (e.g., plotly),\n    // shiny initializes with the correct sizing, but in-between the 1st and last\n    // renderValue(), the size of the output containers can change, meaning every\n    // output but the 1st gets initialized with the wrong size during their\n    // renderValue(); and then after the render phase, shiny won't know trigger a\n    // resize since all the widgets will return to their original size\n    // (and thus, Shiny thinks there isn't any resizing to do).\n    // We workaround that situation by manually triggering a resize on the binding\n    // when the output container changes (this way, if the size is different during\n    // the render phase, Shiny will know about it)\n\n    // TODO: Remove disable/ignore comments when rstudio/shiny#3815 is available\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore; Type definitions are not found. This occurs when `strict: true`\n    $(document).on(\"shiny:value\", (x: ShinyEventValue) => {\n      const el = x.binding.el;\n      if (!this.container.contains(el)) return;\n      if (el.dataset.bslibOutputObserver) return;\n\n      this.shinyOutputResizeObserver = new ResizeObserver(x.binding.onResize);\n      this.shinyOutputResizeObserver.observe(el);\n      el.dataset.bslibOutputObserver = \"true\";\n    });\n  }\n\n  private _exitFullScreenOnEscape(event: KeyboardEvent): void {\n    // if a select input element has focus, then don't exit full screen\n    if (document.activeElement instanceof HTMLSelectElement) {\n      return;\n    }\n\n    if (event.key === \"Escape\") {\n      this.exitFullScreen();\n    }\n  }\n\n  private _entrapFocus(event: KeyboardEvent): void {\n    // This event handler is only enabled when the card doesn't have any\n    // focusable elements. If the user presses Tab, we want to trap focus in the\n    // full screen card, so we move focus to the close button.\n    if (!(event instanceof KeyboardEvent)) return;\n    if (!this.container.matches(`.${Card.attr.CLASS_FULL_SCREEN}`)) return;\n    if (event.key === \"Tab\") {\n      event.preventDefault();\n      this.overlay.anchor.focus();\n    }\n  }\n\n  private _createOverlay(): CardOverlay {\n    const container = document.createElement(\"div\");\n    container.id = Card.attr.ID_FULL_SCREEN_OVERLAY;\n    container.classList.add(Card.attr.ID_FULL_SCREEN_OVERLAY);\n\n    const anchor = document.createElement(\"a\");\n    anchor.classList.add(Card.attr.CLASS_FULL_SCREEN_EXIT);\n    anchor.tabIndex = 0;\n    anchor.onclick = () => this.exitFullScreen();\n    anchor.onkeyup = (ev) => {\n      if (ev.key === \"Enter\" || ev.key === \" \") {\n        this.exitFullScreen();\n      }\n    };\n    anchor.onkeydown = (ev) => {\n      // if tabbing backwards out of the card,\n      // cycle focus back to last focus element within the card\n      if (ev.key === \"Tab\" && ev.shiftKey) {\n        ev.preventDefault();\n        this.lastFocusInterior?.focus();\n      }\n    };\n    anchor.innerHTML = this._overlayCloseHtml();\n\n    container.appendChild(anchor);\n    return { container, anchor };\n  }\n\n  private _overlayCloseHtml(): string {\n    return (\n      \"Close \" +\n      \"<svg width:'20' height='20' fill='currentColor' class='bi bi-x-lg' \" +\n      \"viewBox='0 0 16 16'>\" +\n      \"<path d='M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 \" +\n      \"0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 \" +\n      \"5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z'/></svg>\"\n    );\n  }\n\n  private static instanceMap: WeakMap<HTMLElement, Card> = new WeakMap();\n\n  public static getInstance(el: HTMLElement): Card | undefined {\n    return Card.instanceMap.get(el);\n  }\n\n  private static documentObserver: DocumentObserver = new DocumentObserver({\n    added: {\n      selector: `.${Card.attr.CLASS_CARD}[data-bslib-card-needs-init]`,\n      callback: (card: HTMLElement) => {\n        new Card(card);\n      },\n    },\n    removed: {\n      selector: `.${Card.attr.CLASS_CARD}`,\n      callback: (card: HTMLElement) => {\n        Card.getInstance(card)?.destroy();\n      },\n    },\n  });\n\n  static get observer(): DocumentObserver {\n    return Card.documentObserver;\n  }\n}\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Card = Card;\n\nexport { Card };\n"],
  "mappings": "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",
  "names": ["DocumentObserver", "config", "mutationObserverCallback", "mutationsList", "mutation", "addedNode", "removedNode", "el", "selector", "callback", "elMatches", "hasMatchingChild", "node", "InputBinding", "getAllFocusableChildren", "el", "selectors", "focusable", "Tooltip", "_Card", "el", "resizeEvent", "event", "ev", "focusableElements", "getAllFocusableChildren", "btnFullScreen", "selector", "tt", "x", "container", "anchor", "_a", "Card", "DocumentObserver", "card"]
}
