{
  "version": 3,
  "sources": ["../../srcts/src/components/_utils.ts", "../../srcts/src/components/_shinyResizeObserver.ts", "../../srcts/src/components/card.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  // Built from https://stackoverflow.com/a/36410810\n  // And cross-referenced with https://allyjs.io/data-tables/focusable.html\n  const base = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button\",\n    \"details summary\",\n    \"input\",\n    \"iframe\",\n    \"select\",\n    \"textarea\",\n    '[contentEditable=\"\"]',\n    '[contentEditable=\"true\"]',\n    '[contentEditable=\"TRUE\"]',\n    \"[tabindex]\",\n  ];\n  const modifiers = [':not([tabindex=\"-1\"])', \":not([disabled])\"];\n  const selectors = base.map((b) => b + modifiers.join(\"\"));\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n};\nexport type { HtmlDep };\n", "/**\n * A resize observer that ensures Shiny outputs resize during or just after\n * their parent container size changes. Useful, in particular, for sidebar\n * transitions or for full-screen card transitions.\n *\n * @class ShinyResizeObserver\n * @typedef {ShinyResizeObserver}\n */\nclass ShinyResizeObserver {\n  /**\n   * The actual ResizeObserver instance.\n   * @private\n   * @type {ResizeObserver}\n   */\n  private resizeObserver: ResizeObserver;\n  /**\n   * An array of elements that are currently being watched by the Resize\n   * Observer.\n   *\n   * @details\n   * We don't currently have lifecycle hooks that allow us to unobserve elements\n   * when they are removed from the DOM. As a result, we need to manually check\n   * that the elements we're watching still exist in the DOM. This array keeps\n   * track of the elements we're watching so that we can check them later.\n   * @private\n   * @type {HTMLElement[]}\n   */\n  private resizeObserverEntries: HTMLElement[];\n\n  /**\n   * Watch containers for size changes and ensure that Shiny outputs and\n   * htmlwidgets within resize appropriately.\n   *\n   * @details\n   * The ShinyResizeObserver is used to watch the containers, such as Sidebars\n   * and Cards for size changes, in particular when the sidebar state is toggled\n   * or the card body is expanded full screen. It performs two primary tasks:\n   *\n   * 1. Dispatches a `resize` event on the window object. This is necessary to\n   *    ensure that Shiny outputs resize appropriately. In general, the window\n   *    resizing is throttled and the output update occurs when the transition\n   *    is complete.\n   * 2. If an output with a resize method on the output binding is detected, we\n   *    directly call the `.onResize()` method of the binding. This ensures that\n   *    htmlwidgets transition smoothly. In static mode, htmlwidgets does this\n   *    already.\n   *\n   * @note\n   * This resize observer also handles race conditions in some complex\n   * fill-based layouts with multiple outputs (e.g., plotly), where shiny\n   * initializes with the correct sizing, but in-between the 1st and last\n   * renderValue(), the size of the output containers can change, meaning every\n   * output but the 1st gets initialized with the wrong size during their\n   * renderValue(). Then, after the render phase, shiny won't know to trigger a\n   * resize since all the widgets will return to their original size (and thus,\n   * Shiny thinks there isn't any resizing to do). The resize observer works\n   * around this by ensuring that the output is resized whenever its container\n   * size changes.\n   * @constructor\n   */\n  constructor() {\n    this.resizeObserverEntries = [];\n    this.resizeObserver = new ResizeObserver((entries) => {\n      const resizeEvent = new Event(\"resize\");\n      window.dispatchEvent(resizeEvent);\n\n      // the rest of this callback is only relevant in Shiny apps\n      if (!window.Shiny) return;\n\n      const resized = [] as HTMLElement[];\n\n      for (const entry of entries) {\n        if (!(entry.target instanceof HTMLElement)) continue;\n        if (!entry.target.querySelector(\".shiny-bound-output\")) continue;\n\n        entry.target\n          .querySelectorAll<HTMLElement>(\".shiny-bound-output\")\n          .forEach((el) => {\n            if (resized.includes(el)) return;\n\n            const { binding, onResize } = $(el).data(\"shinyOutputBinding\");\n            if (!binding || !binding.resize) return;\n\n            // if this output is owned by another observer, skip it\n            const owner = (el as any).shinyResizeObserver;\n            if (owner && owner !== this) return;\n            // mark this output as owned by this shinyResizeObserver instance\n            if (!owner) (el as any).shinyResizeObserver = this;\n\n            // trigger immediate resizing of outputs with a resize method\n            onResize(el);\n            // only once per output and resize event\n            resized.push(el);\n\n            // set plot images to 100% width temporarily during the transition\n            if (!el.classList.contains(\"shiny-plot-output\")) return;\n            const img = el.querySelector<HTMLImageElement>(\n              'img:not([width=\"100%\"])'\n            );\n            if (img) img.setAttribute(\"width\", \"100%\");\n          });\n      }\n    });\n  }\n\n  /**\n   * Observe an element for size changes.\n   * @param {HTMLElement} el - The element to observe.\n   */\n  observe(el: HTMLElement): void {\n    this.resizeObserver.observe(el);\n    this.resizeObserverEntries.push(el);\n  }\n\n  /**\n   * Stop observing an element for size changes.\n   * @param {HTMLElement} el - The element to stop observing.\n   */\n  unobserve(el: HTMLElement): void {\n    const idxEl = this.resizeObserverEntries.indexOf(el);\n    if (idxEl < 0) return;\n\n    this.resizeObserver.unobserve(el);\n    this.resizeObserverEntries.splice(idxEl, 1);\n  }\n\n  /**\n   * This method checks that we're not continuing to watch elements that no\n   * longer exist in the DOM. If any are found, we stop observing them and\n   * remove them from our array of observed elements.\n   *\n   * @private\n   * @static\n   */\n  flush(): void {\n    this.resizeObserverEntries.forEach((el) => {\n      if (!document.body.contains(el)) this.unobserve(el);\n    });\n  }\n}\n\nexport { ShinyResizeObserver };\n", "import type { Tooltip as TooltipType } from \"bootstrap\";\nimport { getAllFocusableChildren } from \"./_utils\";\nimport { ShinyResizeObserver } from \"./_shinyResizeObserver\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Tooltip = (\n  window.bootstrap ? window.bootstrap.Tooltip : class {}\n) as typeof TooltipType;\n\ninterface CardOverlay {\n  container: HTMLDivElement;\n  anchor: HTMLAnchorElement;\n}\n\nclass Card {\n  private container: HTMLElement;\n  private overlay: CardOverlay;\n  private prevFocusExterior: HTMLElement | undefined;\n\n  private static attr = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ATTR_INIT: \"data-bslib-card-init\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_CARD: \"bslib-card\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_FULL_SCREEN: \"bslib-full-screen\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_HAS_FULL_SCREEN: \"bslib-has-full-screen\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_FULL_SCREEN_ENTER: \"bslib-full-screen-enter\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    CLASS_FULL_SCREEN_EXIT: \"bslib-full-screen-exit\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    ID_FULL_SCREEN_OVERLAY: \"bslib-full-screen-overlay\",\n  };\n\n  /**\n   * A Shiny-specific resize observer that ensures Shiny outputs in the main\n   * content areas of the sidebar resize appropriately.\n   * @private\n   * @type {ShinyResizeObserver}\n   * @static\n   */\n  private static shinyResizeObserver = new ShinyResizeObserver();\n\n  constructor(el: HTMLElement) {\n    // remove initialization attribute and script\n    el.removeAttribute(Card.attr.ATTR_INIT);\n    el.querySelector<HTMLScriptElement>(\n      `script[${Card.attr.ATTR_INIT}]`\n    )?.remove();\n\n    this.container = el;\n    Card.instanceMap.set(el, this);\n\n    // Let Shiny know to trigger resize when the card size changes\n    // TODO: shiny could/should do this itself (rstudio/shiny#3682)\n    Card.shinyResizeObserver.observe(this.container);\n\n    this._addEventListeners();\n    this._enableTooltips();\n    this.overlay = this._createOverlay();\n  }\n\n  enterFullScreen(event?: Event): void {\n    if (event) event.preventDefault();\n\n    this.overlay.container.addEventListener(\"click\", () =>\n      this.exitFullScreen()\n    );\n\n    document.addEventListener(\n      \"keyup\",\n      (ev) => this._exitFullScreenOnEscape(ev),\n      false\n    );\n\n    this.container.addEventListener(\"keydown\", (ev) => this._trapFocusExit(ev));\n\n    // Set initial focus on the card\n    this.container.setAttribute(\"tabindex\", \"-1\");\n    this.container.focus();\n\n    this.container.classList.add(Card.attr.CLASS_FULL_SCREEN);\n    document.body.classList.add(Card.attr.CLASS_HAS_FULL_SCREEN);\n    this.container.insertAdjacentElement(\"beforebegin\", this.overlay.container);\n  }\n\n  exitFullScreen(): void {\n    // Remove event listeners that were added when entering full screen\n    this.overlay.container.removeEventListener(\"click\", () =>\n      this.exitFullScreen()\n    );\n\n    document.removeEventListener(\n      \"keyup\",\n      (ev) => this._exitFullScreenOnEscape(ev),\n      false\n    );\n\n    this.container.removeEventListener(\"keydown\", (ev) =>\n      this._trapFocusExit(ev)\n    );\n\n    // Remove overlay and remove full screen classes from card\n    this.overlay.container.remove();\n    this.container.classList.remove(Card.attr.CLASS_FULL_SCREEN);\n    this.container.removeAttribute(\"tabindex\");\n    document.body.classList.remove(Card.attr.CLASS_HAS_FULL_SCREEN);\n\n    // Reset focus tracking state\n    this.prevFocusExterior = undefined;\n  }\n\n  private _addEventListeners(): void {\n    const btnFullScreen = this.container.querySelector(\n      `:scope > .${Card.attr.CLASS_FULL_SCREEN_ENTER}`\n    );\n    if (!btnFullScreen) return;\n    btnFullScreen.addEventListener(\"click\", (ev) => this.enterFullScreen(ev));\n  }\n\n  private _enableTooltips(): void {\n    const selector = `.${Card.attr.CLASS_FULL_SCREEN_ENTER}[data-bs-toggle='tooltip']`;\n    if (!this.container.querySelector(selector)) {\n      return;\n    }\n    const tooltipList = this.container.querySelectorAll(selector);\n    tooltipList.forEach((tt) => new Tooltip(tt));\n  }\n\n  private _exitFullScreenOnEscape(event: KeyboardEvent): void {\n    // if a select input element has focus, then don't exit full screen\n    if (document.activeElement instanceof HTMLSelectElement) {\n      return;\n    }\n\n    if (event.key === \"Escape\") {\n      this.exitFullScreen();\n    }\n  }\n\n  private _trapFocusExit(event: KeyboardEvent): void {\n    if (!(event instanceof KeyboardEvent)) return;\n    if (event.key !== \"Tab\") return;\n\n    const isFocusedContainer = event.target === this.container;\n    const isFocusedWithin = this.container.contains(event.target as Node);\n\n    if (event.shiftKey && !(isFocusedWithin || isFocusedContainer)) return;\n\n    // We have to check every time because the card contents may have changed\n    const focusableElements = getAllFocusableChildren(this.container);\n    const hasFocusableElements = focusableElements.length > 0;\n    const lastFocusable = focusableElements[focusableElements.length - 1];\n\n    if (event.target !== lastFocusable && !isFocusedContainer) {\n      return;\n    }\n\n    // We're going to take control over tab focus now\n    event.preventDefault();\n\n    if (isFocusedContainer) {\n      hasFocusableElements\n        ? focusableElements[0].focus()\n        : this.overlay.anchor.focus();\n    } else {\n      // If tabbing forwards out of the card, return to close button\n      this.overlay.anchor.focus();\n    }\n  }\n\n  private _createOverlay(): CardOverlay {\n    const container = document.createElement(\"div\");\n    container.id = Card.attr.ID_FULL_SCREEN_OVERLAY;\n\n    const anchor = this._createOverlayCloseAnchor();\n    container.appendChild(anchor);\n\n    return { container, anchor };\n  }\n\n  private _createOverlayCloseAnchor(): HTMLAnchorElement {\n    const anchor = document.createElement(\"a\");\n    anchor.classList.add(Card.attr.CLASS_FULL_SCREEN_EXIT);\n    anchor.tabIndex = 0;\n    anchor.onclick = () => this.exitFullScreen();\n    anchor.onkeyup = (ev) => {\n      if (ev.key === \"Enter\" || ev.key === \" \") {\n        this.exitFullScreen();\n      }\n    };\n    anchor.onkeydown = (ev) => {\n      // if tabbing backwards out of the card,\n      // cycle focus back to last focus element within the card\n      if (ev.key !== \"Tab\") return;\n\n      const focusableElements = getAllFocusableChildren(this.container);\n\n      if (focusableElements.length === 0) {\n        // nothing to move to in any direction so stay on the close button\n        ev.preventDefault();\n        return;\n      }\n\n      // can move forward to the next focusable element (don't prevent default)\n      if (!ev.shiftKey) return;\n\n      // we are tabbing backwards, cycle back to the last focusable element\n      ev.preventDefault();\n      const lastFocusable = focusableElements[focusableElements.length - 1];\n      lastFocusable.focus();\n    };\n    anchor.innerHTML = this._overlayCloseHtml();\n\n    return anchor;\n  }\n\n  private _overlayCloseHtml(): string {\n    return (\n      \"Close \" +\n      \"<svg width='20' height='20' fill='currentColor' class='bi bi-x-lg' \" +\n      \"viewBox='0 0 16 16'>\" +\n      \"<path d='M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 \" +\n      \"0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 \" +\n      \"5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z'/></svg>\"\n    );\n  }\n\n  private static instanceMap: WeakMap<HTMLElement, Card> = new WeakMap();\n\n  public static getInstance(el: HTMLElement): Card | undefined {\n    return Card.instanceMap.get(el);\n  }\n\n  /**\n   * If cards are initialized before the DOM is ready, we re-schedule the\n   * initialization to occur on DOMContentLoaded.\n   * @private\n   * @static\n   * @type {boolean}\n   */\n  private static onReadyScheduled = false;\n\n  public static initializeAllCards(flushResizeObserver = true): void {\n    if (document.readyState === \"loading\") {\n      if (!Card.onReadyScheduled) {\n        Card.onReadyScheduled = true;\n        document.addEventListener(\"DOMContentLoaded\", () => {\n          Card.initializeAllCards(false);\n        });\n      }\n      return;\n    }\n\n    if (flushResizeObserver) {\n      // Trigger a recheck of observed cards to unobserve non-existent cards\n      Card.shinyResizeObserver.flush();\n    }\n\n    const initSelector = `.${Card.attr.CLASS_CARD}[${Card.attr.ATTR_INIT}]`;\n    if (!document.querySelector(initSelector)) {\n      // no cards to initialize\n      return;\n    }\n\n    const cards = document.querySelectorAll(initSelector);\n    cards.forEach((card) => new Card(card as HTMLElement));\n  }\n}\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Card = Card;\n\nexport { Card };\n"],
  "mappings": "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",
  "names": ["InputBinding", "getAllFocusableChildren", "el", "base", "modifiers", "selectors", "b", "focusable", "ShinyResizeObserver", "entries", "resizeEvent", "resized", "entry", "el", "binding", "onResize", "owner", "img", "idxEl", "Tooltip", "_Card", "el", "_a", "event", "ev", "btnFullScreen", "selector", "tt", "isFocusedContainer", "isFocusedWithin", "focusableElements", "getAllFocusableChildren", "hasFocusableElements", "lastFocusable", "container", "anchor", "flushResizeObserver", "initSelector", "card", "Card", "ShinyResizeObserver"]
}
