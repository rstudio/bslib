{
  "version": 3,
  "sources": ["../../srcts/src/components/_documentObserver.ts", "../../srcts/src/components/card.ts"],
  "sourcesContent": ["/**\n * The DocumentObserver class creates an observer detecting all DOM changes,\n * watching for added or removed elements (or their children) that match\n * the specified selectors. When a matching element is added or removed, the\n * respective callback function is called. The DocumentObserver is insensitive\n * to when it's instantiated; it always runs `added.callback()` once on the\n * document body (waiting for DOMContentLoaded if necessary) and then starts\n * watching the DOM for added/removed elements.\n */\n\ninterface DocumentObserverConfig {\n  added: {\n    selector: string;\n    callback: (node: HTMLElement) => void;\n  };\n  removed: {\n    selector: string;\n    callback: (node: HTMLElement) => void;\n  };\n}\n\nclass DocumentObserver {\n  private observer: MutationObserver;\n  private config: DocumentObserverConfig;\n\n  constructor(config: DocumentObserverConfig) {\n    const mutationObserverCallback = (mutationsList: MutationRecord[]) => {\n      for (const mutation of mutationsList) {\n        if (mutation.type === \"childList\") {\n          for (const addedNode of mutation.addedNodes) {\n            if (addedNode.nodeType !== Node.ELEMENT_NODE) continue;\n            this._callback(addedNode as HTMLElement, this.config.added);\n          }\n          for (const removedNode of mutation.removedNodes) {\n            if (removedNode.nodeType !== Node.ELEMENT_NODE) continue;\n            this._callback(removedNode as HTMLElement, this.config.removed);\n          }\n        }\n      }\n    };\n\n    this.config = config;\n    this.observer = new MutationObserver(mutationObserverCallback);\n    if (document.readyState === \"complete\") {\n      this.connect();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => this.connect());\n    }\n  }\n\n  private _callback(\n    el: HTMLElement,\n    {\n      selector,\n      callback,\n    }: { selector: string; callback: (node: HTMLElement) => void }\n  ) {\n    const elMatches = el.matches(selector);\n    const hasMatchingChild = el.querySelector(selector);\n    if (!elMatches && !hasMatchingChild) return;\n    if (elMatches) callback(el);\n    if (!hasMatchingChild) return;\n    el.querySelectorAll(selector).forEach((node) =>\n      callback(node as HTMLElement)\n    );\n  }\n\n  connect(): void {\n    this._callback(document.body, this.config.added);\n    this.observer.observe(document, { childList: true, subtree: true });\n  }\n\n  disconnect(): void {\n    this.observer.disconnect();\n  }\n}\n\nexport { DocumentObserver };\nexport type { DocumentObserverConfig };\n", "import type { Tooltip as TooltipType } from \"bootstrap\";\nimport type { ShinyEventValue } from \"rstudio-shiny/srcts/types/src/events/shinyEvents\";\nimport { DocumentObserver } from \"./_documentObserver\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Tooltip = (\n  window.bootstrap ? window.bootstrap.Tooltip : class {}\n) as typeof TooltipType;\n\nclass Card {\n  private container: HTMLElement;\n  cardResizeObserver: ResizeObserver;\n  shinyOutputResizeObserver: ResizeObserver | undefined;\n\n  constructor(el: HTMLElement) {\n    el.removeAttribute(\"data-bslib-card-needs-init\");\n\n    this.container = el;\n    Card.instanceMap.set(el, this);\n\n    // Let Shiny know to trigger resize when the card size changes\n    // TODO: shiny could/should do this itself (rstudio/shiny#3682)\n    const resizeEvent = new Event(\"resize\");\n    this.cardResizeObserver = new ResizeObserver(() => {\n      window.dispatchEvent(resizeEvent);\n    });\n    this.cardResizeObserver.observe(this.container);\n\n    this._addEventListeners();\n    this._enableTooltips();\n    this._startShinyOutputResizeObserver();\n  }\n\n  enterFullScreen(event?: Event): void {\n    if (event) event.preventDefault();\n\n    const overlay = this._createOverlay();\n    overlay.addEventListener(\"click\", () => this.exitFullScreen());\n    document.addEventListener(\"keyup\", this._exitFullScreenOnEscape, false);\n\n    this.container.classList.add(\"bslib-full-screen\");\n    this.container.insertAdjacentElement(\"beforebegin\", overlay);\n  }\n\n  exitFullScreen(): void {\n    const overlay = document.getElementById(\"bslib-full-screen-overlay\");\n\n    overlay ? overlay.remove() : null;\n    this.container.classList.remove(\"bslib-full-screen\");\n\n    overlay?.removeEventListener(\"click\", () => this.exitFullScreen());\n    document.removeEventListener(\"keyup\", this._exitFullScreenOnEscape, false);\n  }\n\n  destroy(): void {\n    this._removeEventListeners();\n    this.cardResizeObserver.disconnect();\n    if (this.shinyOutputResizeObserver) {\n      this.shinyOutputResizeObserver.disconnect();\n    }\n    Card.instanceMap.delete(this.container);\n  }\n\n  private _addEventListeners(): void {\n    const btnFullScreen = this.container.querySelector(\n      \".bslib-full-screen-enter\"\n    );\n    if (!btnFullScreen) return;\n    btnFullScreen.addEventListener(\"click\", (ev) => this.enterFullScreen(ev));\n  }\n\n  private _removeEventListeners(): void {\n    const btnFullScreen = this.container.querySelector(\n      \".bslib-full-screen-enter\"\n    );\n    if (!btnFullScreen) return;\n    btnFullScreen.removeEventListener(\"click\", (ev) =>\n      this.enterFullScreen(ev)\n    );\n  }\n\n  private _enableTooltips(): void {\n    if (!this.container.querySelector('[data-bs-toggle=\"tooltip\"]')) {\n      return;\n    }\n    const tooltipList = this.container.querySelectorAll(\n      '[data-bs-toggle=\"tooltip\"]'\n    );\n    tooltipList.forEach((tt) => new Tooltip(tt));\n  }\n\n  private _startShinyOutputResizeObserver(): void {\n    // In some complex fill-based layouts with multiple outputs (e.g., plotly),\n    // shiny initializes with the correct sizing, but in-between the 1st and last\n    // renderValue(), the size of the output containers can change, meaning every\n    // output but the 1st gets initialized with the wrong size during their\n    // renderValue(); and then after the render phase, shiny won't know trigger a\n    // resize since all the widgets will return to their original size\n    // (and thus, Shiny thinks there isn't any resizing to do).\n    // We workaround that situation by manually triggering a resize on the binding\n    // when the output container changes (this way, if the size is different during\n    // the render phase, Shiny will know about it)\n\n    // TODO: Remove disable/ignore comments when rstudio/shiny#3815 is available\n    // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n    // @ts-ignore; Type definitions are not found. This occurs when `strict: true`\n    $(document).on(\"shiny:value\", (x: ShinyEventValue) => {\n      const el = x.binding.el;\n      if (!this.container.contains(el)) return;\n      if (el.dataset.bslibOutputObserver) return;\n\n      this.shinyOutputResizeObserver = new ResizeObserver(x.binding.onResize);\n      this.shinyOutputResizeObserver.observe(el);\n      el.dataset.bslibOutputObserver = \"true\";\n    });\n  }\n\n  private _exitFullScreenOnEscape(event: KeyboardEvent): void {\n    if (event.key === \"Escape\") {\n      this.exitFullScreen();\n    }\n  }\n\n  private _createOverlay(): HTMLElement {\n    const overlay = document.createElement(\"div\");\n    overlay.id = \"bslib-full-screen-overlay\";\n    overlay.classList.add(\"bslib-full-screen-overlay\");\n\n    const overlayAnchor = document.createElement(\"a\");\n    overlayAnchor.classList.add(\"bslib-full-screen-exit\");\n    overlayAnchor.innerHTML = this._overlayCloseHtml();\n\n    overlay.appendChild(overlayAnchor);\n    return overlay;\n  }\n\n  private _overlayCloseHtml(): string {\n    return (\n      \"Close \" +\n      \"<svg width:'20' height='20' fill='currentColor' class='bi bi-x-lg' \" +\n      \"viewBox='0 0 16 16'>\" +\n      \"<path d='M2.146 2.854a.5.5 0 1 1 .708-.708L8 7.293l5.146-5.147a.5.5 \" +\n      \"0 0 1 .708.708L8.707 8l5.147 5.146a.5.5 0 0 1-.708.708L8 8.707l-5.146 \" +\n      \"5.147a.5.5 0 0 1-.708-.708L7.293 8 2.146 2.854Z'/></svg>\"\n    );\n  }\n\n  private static instanceMap: WeakMap<HTMLElement, Card> = new WeakMap();\n\n  public static getInstance(el: HTMLElement): Card | undefined {\n    return Card.instanceMap.get(el);\n  }\n\n  private static documentObserver: DocumentObserver = new DocumentObserver({\n    added: {\n      selector: \".bslib-card[data-bslib-card-needs-init]\",\n      callback: (card: HTMLElement) => {\n        new Card(card);\n      },\n    },\n    removed: {\n      selector: \".bslib-card\",\n      callback: (card: HTMLElement) => {\n        Card.getInstance(card)?.destroy();\n      },\n    },\n  });\n\n  static get observer(): DocumentObserver {\n    return Card.documentObserver;\n  }\n}\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Card = Card;\n\nexport { Card };\n"],
  "mappings": "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",
  "names": ["DocumentObserver", "config", "mutationObserverCallback", "mutationsList", "mutation", "addedNode", "removedNode", "el", "selector", "callback", "elMatches", "hasMatchingChild", "node", "Tooltip", "_Card", "el", "resizeEvent", "event", "overlay", "btnFullScreen", "ev", "tt", "x", "overlayAnchor", "Card", "DocumentObserver", "card", "_a"]
}
