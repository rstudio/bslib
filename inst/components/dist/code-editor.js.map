{
  "version": 3,
  "sources": ["../../../srcts/src/components/_utils.ts", "../../../srcts/src/components/codeEditor.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\nimport type { ShinyClass } from \"rstudio-shiny/srcts/types/src\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Shiny: ShinyClass | undefined = window.Shiny;\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\nfunction registerBslibGlobal(name: string, value: object): void {\n  (window as any).bslib = (window as any).bslib || {};\n  if (!(window as any).bslib[name]) {\n    (window as any).bslib[name] = value;\n  } else {\n    console.error(\n      `[bslib] Global window.bslib.${name} was already defined, using previous definition.`\n    );\n  }\n}\n\ntype ShinyClientMessage = {\n  message: string;\n  headline?: string;\n  status?: \"error\" | \"info\" | \"warning\";\n};\n\nfunction showShinyClientMessage({\n  headline = \"\",\n  message,\n  status = \"warning\",\n}: ShinyClientMessage): void {\n  document.dispatchEvent(\n    new CustomEvent(\"shiny:client-message\", {\n      detail: { headline: headline, message: message, status: status },\n    })\n  );\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  // Cross-referenced with https://allyjs.io/data-tables/focusable.html\n  const base = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button\",\n    \"details summary\",\n    \"input\",\n    \"iframe\",\n    \"select\",\n    \"textarea\",\n    '[contentEditable=\"\"]',\n    '[contentEditable=\"true\"]',\n    '[contentEditable=\"TRUE\"]',\n    \"[tabindex]\",\n  ];\n  const modifiers = [':not([tabindex=\"-1\"])', \":not([disabled])\"];\n  const selectors = base.map((b) => b + modifiers.join(\"\"));\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nasync function shinyRenderContent(\n  ...args: Parameters<ShinyClass[\"renderContentAsync\"]>\n): Promise<void> {\n  if (!Shiny) {\n    throw new Error(\"This function must be called in a Shiny app.\");\n  }\n  if (Shiny.renderContentAsync) {\n    return await Shiny.renderContentAsync.apply(null, args);\n  } else {\n    return await Shiny.renderContent.apply(null, args);\n  }\n}\n\n// Copied from shiny utils\nasync function updateLabel(\n  labelContent: string | { html: string; deps: HtmlDep[] } | undefined,\n  labelNode: JQuery<HTMLElement>\n): Promise<void> {\n  // Only update if label was specified in the update method\n  if (typeof labelContent === \"undefined\") return;\n  if (labelNode.length !== 1) {\n    throw new Error(\"labelNode must be of length 1\");\n  }\n\n  if (typeof labelContent === \"string\") {\n    labelContent = {\n      html: labelContent,\n      deps: [],\n    };\n  }\n\n  if (labelContent.html === \"\") {\n    labelNode.addClass(\"shiny-label-null\");\n  } else {\n    await shinyRenderContent(labelNode, labelContent);\n    labelNode.removeClass(\"shiny-label-null\");\n  }\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  registerBslibGlobal,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n  shinyRenderContent,\n  showShinyClientMessage,\n  Shiny,\n  updateLabel,\n};\nexport type { HtmlDep, ShinyClientMessage };\n", "/**\n * Code Editor Input Binding for bslib\n *\n * This binding creates a code editor using prism-code-editor with syntax\n * highlighting, theme support, and bidirectional communication with R/Shiny.\n *\n * NOTE: This file uses dynamic imports (await import(...)) for lazy loading\n * of prism-code-editor and its language grammars. This requires:\n * - tsconfig.json: \"module\": \"esnext\" for type checking to accept dynamic imports\n * - tsconfig.json: ts-node section with \"module\": \"commonjs\" for the build script\n * - esbuild: \"format\": \"esm\" in build config for the output bundle\n *\n * The module settings only affect type checking and ts-node execution;\n * the actual browser output format is controlled by esbuild.\n */\n\nimport type { InputSubscribeCallback } from \"rstudio-shiny/srcts/types/src/bindings/input/inputBinding\";\nimport { registerBinding, InputBinding, hasDefinedProperty } from \"./_utils\";\n\n// Default values - should match R defaults in input-code-editor.R\n/* eslint-disable @typescript-eslint/naming-convention */\nconst DEFAULT_LANGUAGE = \"sql\";\nconst DEFAULT_TAB_SIZE = 2;\nconst DEFAULT_THEME_LIGHT = \"github-light\";\nconst DEFAULT_THEME_DARK = \"github-dark\";\nconst SUBMIT_FLASH_DURATION_MS = 400;\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// Type definitions for prism-code-editor\ninterface PrismEditor {\n  value: string;\n  keyCommandMap: {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Enter?: (\n      e: KeyboardEvent,\n      selection: unknown,\n      value: string\n    ) => boolean | undefined;\n    [key: string]: unknown;\n  };\n  setOptions(options: PrismEditorOptions): void;\n  update(): void;\n}\n\ninterface PrismEditorOptions {\n  language?: string;\n  value?: string;\n  tabSize?: number;\n  insertSpaces?: boolean;\n  lineNumbers?: boolean;\n  wordWrap?: boolean;\n  readOnly?: boolean;\n}\n\ninterface PrismCodeEditorModule {\n  createEditor: (\n    element: HTMLElement,\n    options: PrismEditorOptions,\n    ...extensions: any[]\n  ) => PrismEditor;\n}\n\ninterface CopyButtonModule {\n  copyButton: () => any;\n}\n\ninterface CommandsModule {\n  defaultCommands: () => any;\n}\n\n// Extended HTMLElement types to include custom properties\ninterface CodeEditorElement extends HTMLElement {\n  prismEditor?: PrismEditor;\n  darkLightObserver?: MutationObserver;\n  codeEditorUpdateCallback?: () => void;\n  isInitialized?: Promise<PrismEditor | undefined>;\n}\n\n// Message data from R uses snake_case to match session$sendInputMessage\n// eslint-disable-next-line @typescript-eslint/naming-convention\ntype CodeEditorReceiveMessageData = {\n  code?: string;\n  /* eslint-disable @typescript-eslint/naming-convention */\n  tab_size?: number;\n  indentation?: \"space\" | \"tab\";\n  read_only?: boolean;\n  line_numbers?: boolean;\n  word_wrap?: boolean;\n  language?: string;\n  theme_light?: string;\n  theme_dark?: string;\n  /* eslint-enable @typescript-eslint/naming-convention */\n};\n\n// Track which languages have been loaded to avoid duplicate imports\nconst loadedLanguages = new Set<string>();\n\n// Track which editor instances have been initialized\nconst initializedEditors = new WeakSet<HTMLElement>();\n\n// Memoized base path for prism-code-editor files\nlet prismCodeEditorBasePath: string | null = null;\n\n/**\n * Get the base path for prism-code-editor files by locating the script element.\n * @returns The base path (memoized after first call)\n * @throws Error if the prism-code-editor script cannot be found\n */\nfunction getPrismCodeEditorBasePath(): string {\n  if (prismCodeEditorBasePath !== null) {\n    return prismCodeEditorBasePath;\n  }\n\n  const scriptElement = document.querySelector(\n    'script[src*=\"prism-code-editor\"][src$=\"index.js\"]'\n  );\n\n  if (!scriptElement) {\n    throw new Error(\n      \"Could not find prism-code-editor script element. \" +\n        \"Ensure the prism-code-editor dependency is properly loaded.\"\n    );\n  }\n\n  const src = scriptElement.getAttribute(\"src\");\n  if (!src) {\n    throw new Error(\"prism-code-editor script element has no src attribute\");\n  }\n\n  const absoluteSrc = new URL(src, document.baseURI).href;\n  prismCodeEditorBasePath = absoluteSrc.replace(/\\/index\\.js$/, \"\");\n  return prismCodeEditorBasePath;\n}\n\nasync function loadLanguage(language: string, basePath: string): Promise<void> {\n  if (loadedLanguages.has(language)) {\n    return;\n  }\n  if ([\"plain\", \"plaintext\", \"text\", \"txt\"].includes(language)) {\n    // No grammar needed for plain text\n    return;\n  }\n  let languageToLoad = language;\n  // Handle html \u2192 markup mapping for backwards compatibility\n  if (language === \"html\") {\n    languageToLoad = \"markup\";\n  }\n  try {\n    await import(`${basePath}/prism/languages/${languageToLoad}.js`);\n    loadedLanguages.add(language);\n  } catch (error) {\n    console.error(`Failed to load language '${language}':`, error);\n    throw error;\n  }\n}\n\n/**\n * Load a theme stylesheet for the code editor.\n * Handles cleanup of old themes and error cases.\n */\nfunction loadTheme(inputId: string, themeName: string, basePath: string): void {\n  const linkId = `code-editor-theme-${inputId}`;\n  const existingLink = document.getElementById(linkId);\n\n  const newLink = document.createElement(\"link\");\n  newLink.id = linkId;\n  newLink.rel = \"stylesheet\";\n  newLink.href = `${basePath}/themes/${themeName}.css`;\n\n  // Clean up existing link after new one loads (or on error to prevent accumulation)\n  const cleanup = (): void => {\n    existingLink?.remove();\n  };\n\n  newLink.addEventListener(\"load\", cleanup);\n  newLink.addEventListener(\"error\", () => {\n    console.error(`Failed to load code editor theme: ${themeName}`);\n    cleanup();\n  });\n\n  document.head.appendChild(newLink);\n}\n\nfunction setupThemeWatcher(\n  el: CodeEditorElement,\n  themeLight: string,\n  themeDark: string,\n  basePath: string\n): void {\n  const inputId = el.id;\n  const updateTheme = (): void => {\n    const htmlEl = document.documentElement;\n    const theme = htmlEl.getAttribute(\"data-bs-theme\");\n    const themeName =\n      theme === \"dark\"\n        ? el.dataset.themeDark || themeDark\n        : el.dataset.themeLight || themeLight;\n    loadTheme(inputId, themeName, basePath);\n  };\n  updateTheme();\n\n  // Since we filter with attributeFilter, we know all mutations are for data-bs-theme\n  const observer = new MutationObserver(() => updateTheme());\n  observer.observe(document.documentElement, {\n    attributes: true,\n    attributeFilter: [\"data-bs-theme\"],\n  });\n  el.darkLightObserver = observer;\n}\n\nasync function initializeEditor(\n  el: CodeEditorElement\n): Promise<PrismEditor | undefined> {\n  if (initializedEditors.has(el)) {\n    return el.prismEditor;\n  }\n  const editorContainer = el.querySelector(\".code-editor\");\n  if (!editorContainer) {\n    console.error(\n      \"Could not find .code-editor inside .shiny-input-code-editor\"\n    );\n    return;\n  }\n  const language = el.dataset.language || DEFAULT_LANGUAGE;\n  const initialCode = el.dataset.initialCode || \"\";\n  const themeLight = el.dataset.themeLight || DEFAULT_THEME_LIGHT;\n  const themeDark = el.dataset.themeDark || DEFAULT_THEME_DARK;\n  const readOnly = el.dataset.readOnly === \"true\";\n  const lineNumbers = el.dataset.lineNumbers !== \"false\";\n  const wordWrap = el.dataset.wordWrap === \"true\";\n  const tabSize =\n    parseInt(el.dataset.tabSize || String(DEFAULT_TAB_SIZE)) ||\n    DEFAULT_TAB_SIZE;\n  const insertSpaces = el.dataset.insertSpaces !== \"false\";\n\n  const basePath = getPrismCodeEditorBasePath();\n\n  // Load language grammar first, then parallelize the remaining imports\n  await loadLanguage(language, basePath);\n  const [{ createEditor }, { copyButton }, { defaultCommands }] =\n    await Promise.all([\n      import(`${basePath}/index.js`) as Promise<PrismCodeEditorModule>,\n      import(\n        `${basePath}/extensions/copyButton/index.js`\n      ) as Promise<CopyButtonModule>,\n      import(`${basePath}/extensions/commands.js`) as Promise<CommandsModule>,\n    ]);\n\n  const editor = createEditor(\n    editorContainer as HTMLElement,\n    {\n      language: language,\n      value: initialCode,\n      tabSize: tabSize,\n      insertSpaces: insertSpaces,\n      lineNumbers: lineNumbers,\n      wordWrap: wordWrap,\n      readOnly: readOnly,\n    },\n    copyButton(),\n    defaultCommands()\n  );\n\n  const oldEnterCallback = editor.keyCommandMap.Enter;\n  editor.keyCommandMap.Enter = (\n    e: KeyboardEvent,\n    selection: unknown,\n    value: string\n  ) => {\n    if (e.metaKey || e.ctrlKey) {\n      el.dispatchEvent(new CustomEvent(\"codeEditorUpdate\"));\n      editorContainer.classList.add(\"code-editor-submit-flash\");\n      setTimeout(() => {\n        editorContainer.classList.remove(\"code-editor-submit-flash\");\n      }, SUBMIT_FLASH_DURATION_MS);\n      return true;\n    }\n    return oldEnterCallback?.(e, selection, value);\n  };\n\n  el.prismEditor = editor;\n  initializedEditors.add(el);\n  setupThemeWatcher(el, themeLight, themeDark, basePath);\n\n  const textarea = el.querySelector(\"textarea\");\n  if (textarea) {\n    textarea.addEventListener(\"blur\", () => {\n      el.dispatchEvent(new CustomEvent(\"codeEditorUpdate\"));\n    });\n  }\n\n  return editor;\n}\n\nclass CodeEditorInputBinding extends InputBinding {\n  find(scope: HTMLElement): JQuery<HTMLElement> {\n    return $(scope).find(\".shiny-input-code-editor\");\n  }\n\n  getValue(el: HTMLElement): string {\n    const codeEl = el as CodeEditorElement;\n    if (codeEl.prismEditor) {\n      return codeEl.prismEditor.value;\n    }\n    return el.dataset.initialCode || \"\";\n  }\n\n  setValue(el: HTMLElement, value: string): void {\n    const codeEl = el as CodeEditorElement;\n    if (codeEl.prismEditor) {\n      codeEl.prismEditor.setOptions({ value: value });\n    } else {\n      el.dataset.initialCode = value;\n    }\n  }\n\n  subscribe(el: HTMLElement, callback: InputSubscribeCallback): void {\n    const codeEl = el as CodeEditorElement;\n\n    // Store the initialization promise so receiveMessage can await it\n    codeEl.isInitialized = initializeEditor(codeEl);\n    codeEl.isInitialized\n      .then(() => {\n        // Notify Shiny that the editor is ready with its initial value\n        callback(false);\n      })\n      .catch((error) => {\n        console.error(\"Failed to initialize code editor:\", error);\n      });\n\n    const updateCallback = (): void => callback(true);\n    el.addEventListener(\"codeEditorUpdate\", updateCallback);\n    codeEl.codeEditorUpdateCallback = updateCallback;\n  }\n\n  unsubscribe(el: HTMLElement): void {\n    const codeEl = el as CodeEditorElement;\n\n    // Clean up event listener\n    const updateCallback = codeEl.codeEditorUpdateCallback;\n    if (updateCallback) {\n      el.removeEventListener(\"codeEditorUpdate\", updateCallback);\n      delete codeEl.codeEditorUpdateCallback;\n    }\n\n    // Clean up theme observer\n    if (codeEl.darkLightObserver) {\n      codeEl.darkLightObserver.disconnect();\n      delete codeEl.darkLightObserver;\n    }\n\n    // Clean up theme stylesheet to prevent memory leaks\n    const linkId = `code-editor-theme-${el.id}`;\n    document.getElementById(linkId)?.remove();\n  }\n\n  async receiveMessage(\n    el: HTMLElement,\n    data: CodeEditorReceiveMessageData\n  ): Promise<void> {\n    const codeEl = el as CodeEditorElement;\n\n    // Wait for initialization if still pending\n    if (codeEl.isInitialized) {\n      await codeEl.isInitialized;\n    }\n\n    const editor = codeEl.prismEditor;\n    if (!editor) {\n      console.warn(\"Cannot update code editor: editor not initialized\");\n      return;\n    }\n\n    // Collect synchronous option updates\n    const options: PrismEditorOptions = {};\n    if (hasDefinedProperty(data, \"code\")) {\n      options.value = data.code;\n    }\n    if (hasDefinedProperty(data, \"tab_size\")) {\n      options.tabSize = data.tab_size;\n    }\n    if (hasDefinedProperty(data, \"indentation\")) {\n      options.insertSpaces = data.indentation === \"space\";\n    }\n    if (hasDefinedProperty(data, \"read_only\")) {\n      options.readOnly = data.read_only;\n    }\n    if (hasDefinedProperty(data, \"line_numbers\")) {\n      options.lineNumbers = data.line_numbers;\n    }\n    if (hasDefinedProperty(data, \"word_wrap\")) {\n      options.wordWrap = data.word_wrap;\n    }\n    if (Object.keys(options).length > 0) {\n      editor.setOptions(options);\n    }\n\n    // Handle language change (async) - await before firing update event\n    if (hasDefinedProperty(data, \"language\") && data.language) {\n      const newLanguage = data.language;\n      if (newLanguage !== el.dataset.language) {\n        const basePath = getPrismCodeEditorBasePath();\n        try {\n          await loadLanguage(newLanguage, basePath);\n          el.dataset.language = newLanguage;\n          editor.setOptions({ language: newLanguage });\n          editor.update();\n        } catch (error) {\n          console.error(\n            `Failed to change language to '${newLanguage}':`,\n            error\n          );\n        }\n      }\n    }\n\n    // Handle theme updates\n    if (hasDefinedProperty(data, \"theme_light\") && data.theme_light) {\n      this._maybeLoadThemeForMode(el, data.theme_light, \"themeLight\", false);\n    }\n    if (hasDefinedProperty(data, \"theme_dark\") && data.theme_dark) {\n      this._maybeLoadThemeForMode(el, data.theme_dark, \"themeDark\", true);\n    }\n\n    el.dispatchEvent(new CustomEvent(\"codeEditorUpdate\"));\n  }\n\n  /**\n   * Update theme dataset and load the theme if it matches the current mode.\n   * @param el - The code editor element\n   * @param themeValue - The theme name to set\n   * @param datasetKey - The dataset key to update (\"themeLight\" or \"themeDark\")\n   * @param loadForDarkMode - Whether this theme should load when in dark mode\n   */\n  private _maybeLoadThemeForMode(\n    el: HTMLElement,\n    themeValue: string,\n    datasetKey: \"themeDark\" | \"themeLight\",\n    loadForDarkMode: boolean\n  ): void {\n    el.dataset[datasetKey] = themeValue;\n    const currentTheme = document.documentElement.getAttribute(\"data-bs-theme\");\n    const isDark = currentTheme === \"dark\";\n\n    if (isDark === loadForDarkMode) {\n      const basePath = getPrismCodeEditorBasePath();\n      loadTheme(el.id, themeValue, basePath);\n    }\n  }\n\n  getRatePolicy(): { policy: \"throttle\"; delay: number } {\n    return {\n      policy: \"throttle\",\n      delay: 300,\n    };\n  }\n}\n\nregisterBinding(CodeEditorInputBinding, \"code-editor\");\n"],
  "mappings": "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",
  "names": []
}
