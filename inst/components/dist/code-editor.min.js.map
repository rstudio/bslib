{
  "version": 3,
  "sources": ["../../../srcts/src/components/_utils.ts", "../../../srcts/src/components/codeEditor.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\nimport type { ShinyClass } from \"rstudio-shiny/srcts/types/src\";\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst Shiny: ShinyClass | undefined = window.Shiny;\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\nfunction registerBslibGlobal(name: string, value: object): void {\n  (window as any).bslib = (window as any).bslib || {};\n  if (!(window as any).bslib[name]) {\n    (window as any).bslib[name] = value;\n  } else {\n    console.error(\n      `[bslib] Global window.bslib.${name} was already defined, using previous definition.`\n    );\n  }\n}\n\ntype ShinyClientMessage = {\n  message: string;\n  headline?: string;\n  status?: \"error\" | \"info\" | \"warning\";\n};\n\nfunction showShinyClientMessage({\n  headline = \"\",\n  message,\n  status = \"warning\",\n}: ShinyClientMessage): void {\n  document.dispatchEvent(\n    new CustomEvent(\"shiny:client-message\", {\n      detail: { headline: headline, message: message, status: status },\n    })\n  );\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nfunction getAllFocusableChildren(el: HTMLElement): HTMLElement[] {\n  // Cross-referenced with https://allyjs.io/data-tables/focusable.html\n  const base = [\n    \"a[href]\",\n    \"area[href]\",\n    \"button\",\n    \"details summary\",\n    \"input\",\n    \"iframe\",\n    \"select\",\n    \"textarea\",\n    '[contentEditable=\"\"]',\n    '[contentEditable=\"true\"]',\n    '[contentEditable=\"TRUE\"]',\n    \"[tabindex]\",\n  ];\n  const modifiers = [':not([tabindex=\"-1\"])', \":not([disabled])\"];\n  const selectors = base.map((b) => b + modifiers.join(\"\"));\n  const focusable = el.querySelectorAll(selectors.join(\", \"));\n  return Array.from(focusable) as HTMLElement[];\n}\n\nasync function shinyRenderContent(\n  ...args: Parameters<ShinyClass[\"renderContentAsync\"]>\n): Promise<void> {\n  if (!Shiny) {\n    throw new Error(\"This function must be called in a Shiny app.\");\n  }\n  if (Shiny.renderContentAsync) {\n    return await Shiny.renderContentAsync.apply(null, args);\n  } else {\n    return await Shiny.renderContent.apply(null, args);\n  }\n}\n\n// Copied from shiny utils\nasync function updateLabel(\n  labelContent: string | { html: string; deps: HtmlDep[] } | undefined,\n  labelNode: JQuery<HTMLElement>\n): Promise<void> {\n  // Only update if label was specified in the update method\n  if (typeof labelContent === \"undefined\") return;\n  if (labelNode.length !== 1) {\n    throw new Error(\"labelNode must be of length 1\");\n  }\n\n  if (typeof labelContent === \"string\") {\n    labelContent = {\n      html: labelContent,\n      deps: [],\n    };\n  }\n\n  if (labelContent.html === \"\") {\n    labelNode.addClass(\"shiny-label-null\");\n  } else {\n    await shinyRenderContent(labelNode, labelContent);\n    labelNode.removeClass(\"shiny-label-null\");\n  }\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  registerBslibGlobal,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n  getAllFocusableChildren,\n  shinyRenderContent,\n  showShinyClientMessage,\n  Shiny,\n  updateLabel,\n};\nexport type { HtmlDep, ShinyClientMessage };\n", "/**\n * Code Editor Input Binding for bslib\n *\n * This binding creates a code editor using prism-code-editor with syntax\n * highlighting, theme support, and bidirectional communication with R/Shiny.\n *\n * NOTE: This file uses dynamic imports (await import(...)) for lazy loading\n * of prism-code-editor and its language grammars. This requires:\n * - tsconfig.json: \"module\": \"esnext\" for type checking to accept dynamic imports\n * - tsconfig.json: ts-node section with \"module\": \"commonjs\" for the build script\n * - esbuild: \"format\": \"esm\" in build config for the output bundle\n *\n * The module settings only affect type checking and ts-node execution;\n * the actual browser output format is controlled by esbuild.\n */\n\nimport type { InputSubscribeCallback } from \"rstudio-shiny/srcts/types/src/bindings/input/inputBinding\";\nimport { registerBinding, InputBinding, hasDefinedProperty } from \"./_utils\";\n\n// Default values - should match R defaults in input-code-editor.R\n/* eslint-disable @typescript-eslint/naming-convention */\nconst DEFAULT_LANGUAGE = \"sql\";\nconst DEFAULT_TAB_SIZE = 2;\nconst DEFAULT_THEME_LIGHT = \"github-light\";\nconst DEFAULT_THEME_DARK = \"github-dark\";\nconst SUBMIT_FLASH_DURATION_MS = 400;\n/* eslint-enable @typescript-eslint/naming-convention */\n\n// Type definitions for prism-code-editor\ninterface PrismEditor {\n  value: string;\n  keyCommandMap: {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Enter?: (\n      e: KeyboardEvent,\n      selection: unknown,\n      value: string\n    ) => boolean | undefined;\n    [key: string]: unknown;\n  };\n  setOptions(options: PrismEditorOptions): void;\n  update(): void;\n}\n\ninterface PrismEditorOptions {\n  language?: string;\n  value?: string;\n  tabSize?: number;\n  insertSpaces?: boolean;\n  lineNumbers?: boolean;\n  wordWrap?: boolean;\n  readOnly?: boolean;\n}\n\ninterface PrismCodeEditorModule {\n  createEditor: (\n    element: HTMLElement,\n    options: PrismEditorOptions,\n    ...extensions: any[]\n  ) => PrismEditor;\n}\n\ninterface CopyButtonModule {\n  copyButton: () => any;\n}\n\ninterface CommandsModule {\n  defaultCommands: () => any;\n}\n\n// Extended HTMLElement types to include custom properties\ninterface CodeEditorElement extends HTMLElement {\n  prismEditor?: PrismEditor;\n  darkLightObserver?: MutationObserver;\n  codeEditorUpdateCallback?: () => void;\n  isInitialized?: Promise<PrismEditor | undefined>;\n}\n\n// Message data from R uses snake_case to match session$sendInputMessage\n// eslint-disable-next-line @typescript-eslint/naming-convention\ntype CodeEditorReceiveMessageData = {\n  code?: string;\n  /* eslint-disable @typescript-eslint/naming-convention */\n  tab_size?: number;\n  indentation?: \"space\" | \"tab\";\n  read_only?: boolean;\n  line_numbers?: boolean;\n  word_wrap?: boolean;\n  language?: string;\n  theme_light?: string;\n  theme_dark?: string;\n  /* eslint-enable @typescript-eslint/naming-convention */\n};\n\n// Track which languages have been loaded to avoid duplicate imports\nconst loadedLanguages = new Set<string>();\n\n// Track which editor instances have been initialized\nconst initializedEditors = new WeakSet<HTMLElement>();\n\n// Memoized base path for prism-code-editor files\nlet prismCodeEditorBasePath: string | null = null;\n\n/**\n * Get the base path for prism-code-editor files by locating the script element.\n * @returns The base path (memoized after first call)\n * @throws Error if the prism-code-editor script cannot be found\n */\nfunction getPrismCodeEditorBasePath(): string {\n  if (prismCodeEditorBasePath !== null) {\n    return prismCodeEditorBasePath;\n  }\n\n  const scriptElement = document.querySelector(\n    'script[src*=\"prism-code-editor\"][src$=\"index.js\"]'\n  );\n\n  if (!scriptElement) {\n    throw new Error(\n      \"Could not find prism-code-editor script element. \" +\n        \"Ensure the prism-code-editor dependency is properly loaded.\"\n    );\n  }\n\n  const src = scriptElement.getAttribute(\"src\");\n  if (!src) {\n    throw new Error(\"prism-code-editor script element has no src attribute\");\n  }\n\n  const absoluteSrc = new URL(src, document.baseURI).href;\n  prismCodeEditorBasePath = absoluteSrc.replace(/\\/index\\.js$/, \"\");\n  return prismCodeEditorBasePath;\n}\n\nasync function loadLanguage(language: string, basePath: string): Promise<void> {\n  if (loadedLanguages.has(language)) {\n    return;\n  }\n  if ([\"plain\", \"plaintext\", \"text\", \"txt\"].includes(language)) {\n    // No grammar needed for plain text\n    return;\n  }\n  let languageToLoad = language;\n  // Handle html \u2192 markup mapping for backwards compatibility\n  if (language === \"html\") {\n    languageToLoad = \"markup\";\n  }\n  try {\n    await import(`${basePath}/prism/languages/${languageToLoad}.js`);\n    loadedLanguages.add(language);\n  } catch (error) {\n    console.error(`Failed to load language '${language}':`, error);\n    throw error;\n  }\n}\n\n/**\n * Load a theme stylesheet for the code editor.\n * Handles cleanup of old themes and error cases.\n */\nfunction loadTheme(inputId: string, themeName: string, basePath: string): void {\n  const linkId = `code-editor-theme-${inputId}`;\n  const existingLink = document.getElementById(linkId);\n\n  const newLink = document.createElement(\"link\");\n  newLink.id = linkId;\n  newLink.rel = \"stylesheet\";\n  newLink.href = `${basePath}/themes/${themeName}.css`;\n\n  // Clean up existing link after new one loads (or on error to prevent accumulation)\n  const cleanup = (): void => {\n    existingLink?.remove();\n  };\n\n  newLink.addEventListener(\"load\", cleanup);\n  newLink.addEventListener(\"error\", () => {\n    console.error(`Failed to load code editor theme: ${themeName}`);\n    cleanup();\n  });\n\n  document.head.appendChild(newLink);\n}\n\nfunction setupThemeWatcher(\n  el: CodeEditorElement,\n  themeLight: string,\n  themeDark: string,\n  basePath: string\n): void {\n  const inputId = el.id;\n  const updateTheme = (): void => {\n    const htmlEl = document.documentElement;\n    const theme = htmlEl.getAttribute(\"data-bs-theme\");\n    const themeName =\n      theme === \"dark\"\n        ? el.dataset.themeDark || themeDark\n        : el.dataset.themeLight || themeLight;\n    loadTheme(inputId, themeName, basePath);\n  };\n  updateTheme();\n\n  // Since we filter with attributeFilter, we know all mutations are for data-bs-theme\n  const observer = new MutationObserver(() => updateTheme());\n  observer.observe(document.documentElement, {\n    attributes: true,\n    attributeFilter: [\"data-bs-theme\"],\n  });\n  el.darkLightObserver = observer;\n}\n\nasync function initializeEditor(\n  el: CodeEditorElement\n): Promise<PrismEditor | undefined> {\n  if (initializedEditors.has(el)) {\n    return el.prismEditor;\n  }\n  const editorContainer = el.querySelector(\".code-editor\");\n  if (!editorContainer) {\n    console.error(\n      \"Could not find .code-editor inside .shiny-input-code-editor\"\n    );\n    return;\n  }\n  const language = el.dataset.language || DEFAULT_LANGUAGE;\n  const initialCode = el.dataset.initialCode || \"\";\n  const themeLight = el.dataset.themeLight || DEFAULT_THEME_LIGHT;\n  const themeDark = el.dataset.themeDark || DEFAULT_THEME_DARK;\n  const readOnly = el.dataset.readOnly === \"true\";\n  const lineNumbers = el.dataset.lineNumbers !== \"false\";\n  const wordWrap = el.dataset.wordWrap === \"true\";\n  const tabSize =\n    parseInt(el.dataset.tabSize || String(DEFAULT_TAB_SIZE)) ||\n    DEFAULT_TAB_SIZE;\n  const insertSpaces = el.dataset.insertSpaces !== \"false\";\n\n  const basePath = getPrismCodeEditorBasePath();\n\n  // Load language grammar first, then parallelize the remaining imports\n  await loadLanguage(language, basePath);\n  const [{ createEditor }, { copyButton }, { defaultCommands }] =\n    await Promise.all([\n      import(`${basePath}/index.js`) as Promise<PrismCodeEditorModule>,\n      import(\n        `${basePath}/extensions/copyButton/index.js`\n      ) as Promise<CopyButtonModule>,\n      import(`${basePath}/extensions/commands.js`) as Promise<CommandsModule>,\n    ]);\n\n  const editor = createEditor(\n    editorContainer as HTMLElement,\n    {\n      language: language,\n      value: initialCode,\n      tabSize: tabSize,\n      insertSpaces: insertSpaces,\n      lineNumbers: lineNumbers,\n      wordWrap: wordWrap,\n      readOnly: readOnly,\n    },\n    copyButton(),\n    defaultCommands()\n  );\n\n  const oldEnterCallback = editor.keyCommandMap.Enter;\n  editor.keyCommandMap.Enter = (\n    e: KeyboardEvent,\n    selection: unknown,\n    value: string\n  ) => {\n    if (e.metaKey || e.ctrlKey) {\n      el.dispatchEvent(new CustomEvent(\"codeEditorUpdate\"));\n      editorContainer.classList.add(\"code-editor-submit-flash\");\n      setTimeout(() => {\n        editorContainer.classList.remove(\"code-editor-submit-flash\");\n      }, SUBMIT_FLASH_DURATION_MS);\n      return true;\n    }\n    return oldEnterCallback?.(e, selection, value);\n  };\n\n  el.prismEditor = editor;\n  initializedEditors.add(el);\n  setupThemeWatcher(el, themeLight, themeDark, basePath);\n\n  const textarea = el.querySelector(\"textarea\");\n  if (textarea) {\n    textarea.addEventListener(\"blur\", () => {\n      el.dispatchEvent(new CustomEvent(\"codeEditorUpdate\"));\n    });\n  }\n\n  return editor;\n}\n\nclass CodeEditorInputBinding extends InputBinding {\n  find(scope: HTMLElement): JQuery<HTMLElement> {\n    return $(scope).find(\".shiny-input-code-editor\");\n  }\n\n  getValue(el: HTMLElement): string {\n    const codeEl = el as CodeEditorElement;\n    if (codeEl.prismEditor) {\n      return codeEl.prismEditor.value;\n    }\n    return el.dataset.initialCode || \"\";\n  }\n\n  setValue(el: HTMLElement, value: string): void {\n    const codeEl = el as CodeEditorElement;\n    if (codeEl.prismEditor) {\n      codeEl.prismEditor.setOptions({ value: value });\n    } else {\n      el.dataset.initialCode = value;\n    }\n  }\n\n  subscribe(el: HTMLElement, callback: InputSubscribeCallback): void {\n    const codeEl = el as CodeEditorElement;\n\n    // Store the initialization promise so receiveMessage can await it\n    codeEl.isInitialized = initializeEditor(codeEl);\n    codeEl.isInitialized\n      .then(() => {\n        // Notify Shiny that the editor is ready with its initial value\n        callback(false);\n      })\n      .catch((error) => {\n        console.error(\"Failed to initialize code editor:\", error);\n      });\n\n    const updateCallback = (): void => callback(true);\n    el.addEventListener(\"codeEditorUpdate\", updateCallback);\n    codeEl.codeEditorUpdateCallback = updateCallback;\n  }\n\n  unsubscribe(el: HTMLElement): void {\n    const codeEl = el as CodeEditorElement;\n\n    // Clean up event listener\n    const updateCallback = codeEl.codeEditorUpdateCallback;\n    if (updateCallback) {\n      el.removeEventListener(\"codeEditorUpdate\", updateCallback);\n      delete codeEl.codeEditorUpdateCallback;\n    }\n\n    // Clean up theme observer\n    if (codeEl.darkLightObserver) {\n      codeEl.darkLightObserver.disconnect();\n      delete codeEl.darkLightObserver;\n    }\n\n    // Clean up theme stylesheet to prevent memory leaks\n    const linkId = `code-editor-theme-${el.id}`;\n    document.getElementById(linkId)?.remove();\n  }\n\n  async receiveMessage(\n    el: HTMLElement,\n    data: CodeEditorReceiveMessageData\n  ): Promise<void> {\n    const codeEl = el as CodeEditorElement;\n\n    // Wait for initialization if still pending\n    if (codeEl.isInitialized) {\n      await codeEl.isInitialized;\n    }\n\n    const editor = codeEl.prismEditor;\n    if (!editor) {\n      console.warn(\"Cannot update code editor: editor not initialized\");\n      return;\n    }\n\n    // Collect synchronous option updates\n    const options: PrismEditorOptions = {};\n    if (hasDefinedProperty(data, \"code\")) {\n      options.value = data.code;\n    }\n    if (hasDefinedProperty(data, \"tab_size\")) {\n      options.tabSize = data.tab_size;\n    }\n    if (hasDefinedProperty(data, \"indentation\")) {\n      options.insertSpaces = data.indentation === \"space\";\n    }\n    if (hasDefinedProperty(data, \"read_only\")) {\n      options.readOnly = data.read_only;\n    }\n    if (hasDefinedProperty(data, \"line_numbers\")) {\n      options.lineNumbers = data.line_numbers;\n    }\n    if (hasDefinedProperty(data, \"word_wrap\")) {\n      options.wordWrap = data.word_wrap;\n    }\n    if (Object.keys(options).length > 0) {\n      editor.setOptions(options);\n    }\n\n    // Handle language change (async) - await before firing update event\n    if (hasDefinedProperty(data, \"language\") && data.language) {\n      const newLanguage = data.language;\n      if (newLanguage !== el.dataset.language) {\n        const basePath = getPrismCodeEditorBasePath();\n        try {\n          await loadLanguage(newLanguage, basePath);\n          el.dataset.language = newLanguage;\n          editor.setOptions({ language: newLanguage });\n          editor.update();\n        } catch (error) {\n          console.error(\n            `Failed to change language to '${newLanguage}':`,\n            error\n          );\n        }\n      }\n    }\n\n    // Handle theme updates\n    if (hasDefinedProperty(data, \"theme_light\") && data.theme_light) {\n      this._maybeLoadThemeForMode(el, data.theme_light, \"themeLight\", false);\n    }\n    if (hasDefinedProperty(data, \"theme_dark\") && data.theme_dark) {\n      this._maybeLoadThemeForMode(el, data.theme_dark, \"themeDark\", true);\n    }\n\n    el.dispatchEvent(new CustomEvent(\"codeEditorUpdate\"));\n  }\n\n  /**\n   * Update theme dataset and load the theme if it matches the current mode.\n   * @param el - The code editor element\n   * @param themeValue - The theme name to set\n   * @param datasetKey - The dataset key to update (\"themeLight\" or \"themeDark\")\n   * @param loadForDarkMode - Whether this theme should load when in dark mode\n   */\n  private _maybeLoadThemeForMode(\n    el: HTMLElement,\n    themeValue: string,\n    datasetKey: \"themeDark\" | \"themeLight\",\n    loadForDarkMode: boolean\n  ): void {\n    el.dataset[datasetKey] = themeValue;\n    const currentTheme = document.documentElement.getAttribute(\"data-bs-theme\");\n    const isDark = currentTheme === \"dark\";\n\n    if (isDark === loadForDarkMode) {\n      const basePath = getPrismCodeEditorBasePath();\n      loadTheme(el.id, themeValue, basePath);\n    }\n  }\n\n  getRatePolicy(): { policy: \"throttle\"; delay: number } {\n    return {\n      policy: \"throttle\",\n      delay: 300,\n    };\n  }\n}\n\nregisterBinding(CodeEditorInputBinding, \"code-editor\");\n"],
  "mappings": "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",
  "names": ["Shiny", "InputBinding", "registerBinding", "inputBindingClass", "name", "hasDefinedProperty", "obj", "prop", "DEFAULT_LANGUAGE", "DEFAULT_TAB_SIZE", "DEFAULT_THEME_LIGHT", "DEFAULT_THEME_DARK", "SUBMIT_FLASH_DURATION_MS", "loadedLanguages", "initializedEditors", "prismCodeEditorBasePath", "getPrismCodeEditorBasePath", "scriptElement", "src", "loadLanguage", "language", "basePath", "__async", "languageToLoad", "error", "loadTheme", "inputId", "themeName", "linkId", "existingLink", "newLink", "cleanup", "setupThemeWatcher", "el", "themeLight", "themeDark", "updateTheme", "observer", "initializeEditor", "editorContainer", "initialCode", "readOnly", "lineNumbers", "wordWrap", "tabSize", "insertSpaces", "createEditor", "copyButton", "defaultCommands", "editor", "oldEnterCallback", "e", "selection", "value", "textarea", "CodeEditorInputBinding", "InputBinding", "scope", "codeEl", "callback", "updateCallback", "_a", "data", "options", "hasDefinedProperty", "newLanguage", "themeValue", "datasetKey", "loadForDarkMode", "registerBinding"]
}
