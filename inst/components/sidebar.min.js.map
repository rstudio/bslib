{
  "version": 3,
  "sources": ["../../srcts/src/components/_utils.ts", "../../srcts/src/components/sidebar.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n};\nexport type { HtmlDep };\n", "import {\n  InputBinding,\n  registerBinding,\n  doWindowResizeOnElementResize,\n} from \"./_utils\";\n\ntype SidebarMethod = \"close\" | \"open\" | \"toggle\";\n\ntype MessageData = {\n  method: SidebarMethod;\n};\n\ntype SidebarComponents = {\n  container: HTMLElement;\n  main: HTMLElement;\n  sidebar: HTMLElement;\n  toggle: HTMLElement;\n  isClosed: boolean;\n};\n\nclass Sidebar {\n  public static readonly classes = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LAYOUT: \"bslib-sidebar-layout\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    COLLAPSE: \"sidebar-collapsed\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    TRANSITIONING: \"transitioning\",\n  };\n\n  public static initCollapsible(container: HTMLElement): void {\n    // Signal that this layout is initialized by removing the init attribute\n    container.removeAttribute(\"data-bslib-sidebar-init\");\n\n    Sidebar._initSidebarCounters(container);\n    Sidebar._initDesktop(container);\n  }\n\n  private static _initSidebarCounters(container: HTMLElement): void {\n    // This function walks up the DOM tree, adding CSS variables to each\n    // direct parent sidebar layout that count the layout's position in the\n    // stack of nested layouts. We use these counters to keep the collapse\n    // toggles from overlapping. Note that always-open sidebars that don't\n    // have collapse toggles break the chain of nesting.\n\n    const selectorChildLayouts =\n      `.${Sidebar.classes.LAYOUT}` +\n      \"> .main > \" +\n      `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`;\n\n    const isInnermostLayout =\n      container.querySelector(selectorChildLayouts) === null;\n\n    if (!isInnermostLayout) {\n      // There are sidebar layouts nested within this layout; defer to children\n      return;\n    }\n\n    function nextSidebarParent(el: HTMLElement | null): HTMLElement | null {\n      el = el ? el.parentElement : null;\n      if (el && el.classList.contains(\"main\")) {\n        // .bslib-sidebar-layout > .main > .bslib-sidedbar-layout\n        el = el.parentElement;\n      }\n      if (el && el.classList.contains(Sidebar.classes.LAYOUT)) {\n        return el;\n      }\n      return null;\n    }\n\n    const layouts = [container];\n    let parent = nextSidebarParent(container);\n\n    while (parent) {\n      // Add parent to front of layouts array, so we sort outer -> inner\n      layouts.unshift(parent);\n      parent = nextSidebarParent(parent);\n    }\n\n    const count = { left: 0, right: 0 };\n    layouts.forEach(function (x: HTMLElement, i: number): void {\n      x.style.setProperty(\"--bslib-sidebar-counter\", i.toString());\n      const isRight = x.classList.contains(\"sidebar-right\");\n      const thisCount = isRight ? count.right++ : count.left++;\n      x.style.setProperty(\n        \"--bslib-sidebar-overlap-counter\",\n        thisCount.toString()\n      );\n    });\n  }\n\n  private static _initDesktop(container: HTMLElement): void {\n    // If sidebar is marked open='desktop'...\n    if (container.dataset.bslibSidebarOpen !== \"desktop\") {\n      return;\n    }\n\n    // then close sidebar on mobile\n    const initCollapsed = window\n      .getComputedStyle(container)\n      .getPropertyValue(\"--bslib-sidebar-js-init-collapsed\");\n\n    if (initCollapsed === \"true\") {\n      Sidebar.toggle(container, \"close\");\n    }\n  }\n\n  private static _findLayoutContainer(el: HTMLElement): HTMLElement {\n    const container = el.closest(`.${Sidebar.classes.LAYOUT}`);\n    if (!container) {\n      throw new Error(\n        `Expected container or direct ancestor with class ${Sidebar.classes.LAYOUT}`\n      );\n    }\n    return container as HTMLElement;\n  }\n\n  public static components(el: HTMLElement): SidebarComponents {\n    el = Sidebar._findLayoutContainer(el);\n\n    // sidebar components\n    const main = el.querySelector(\":scope > .main\") as HTMLElement;\n    const sidebar = el.querySelector(\":scope > .sidebar\") as HTMLElement;\n    const toggle = el.querySelector(\":scope > .collapse-toggle\") as HTMLElement;\n\n    // sidebar state\n    const isClosed = el.classList.contains(Sidebar.classes.COLLAPSE);\n\n    return { container: el, main, sidebar, toggle, isClosed };\n  }\n\n  public static toggle(el: HTMLElement, method: SidebarMethod) {\n    const { container, main, sidebar, isClosed } = Sidebar.components(el);\n\n    if ([\"open\", \"close\", \"toggle\"].indexOf(method) === -1) {\n      throw new Error(`Unknown method ${method}`);\n    }\n\n    if (method === \"toggle\") {\n      method = isClosed ? \"open\" : \"close\";\n    }\n\n    if ((isClosed && method === \"close\") || (!isClosed && method === \"open\")) {\n      // nothing to do, sidebar is already in the desired state\n      return;\n    }\n\n    // Make sure outputs resize properly when the sidebar is opened/closed\n    doWindowResizeOnElementResize(main);\n\n    if (method === \"open\") {\n      // unhide sidebar immediately when opening,\n      // otherwise the sidebar is hidden on transitionend\n      sidebar.hidden = false;\n    }\n\n    // Add a transitioning class just before adding COLLAPSE_CLASS since we want\n    // some of the transitioning styles to apply before the collapse state\n    container.classList.add(Sidebar.classes.TRANSITIONING);\n    container.classList.toggle(Sidebar.classes.COLLAPSE);\n  }\n\n  public static finalizeState(el: HTMLElement): HTMLElement {\n    const { container, sidebar, toggle, isClosed } = Sidebar.components(el);\n    container.classList.remove(Sidebar.classes.TRANSITIONING);\n    sidebar.hidden = isClosed;\n    toggle.ariaExpanded = isClosed ? \"false\" : \"true\";\n    return sidebar;\n  }\n}\n\nclass SidebarInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(`.${Sidebar.classes.LAYOUT} > .bslib-sidebar-input`);\n  }\n\n  getValue(el: HTMLElement): boolean {\n    return !$(el).parent().hasClass(Sidebar.classes.COLLAPSE);\n  }\n\n  setValue(el: HTMLElement, value: boolean): void {\n    const method = value ? \"open\" : \"close\";\n    this.receiveMessage(el, { method });\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"toggleCollapse.sidebarInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".sidebarInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: MessageData) {\n    Sidebar.toggle(el, data.method);\n  }\n}\n\nregisterBinding(SidebarInputBinding, \"sidebar\");\n\n$(document).on(\n  \"click\",\n  `.${Sidebar.classes.LAYOUT} > .collapse-toggle`,\n  (e) => {\n    e.preventDefault();\n    Sidebar.toggle(e.target, \"toggle\");\n  }\n);\n\n// Once the collapse transition completes (on the collapse toggle icon, which is\n// always guaranteed to transition), then remove the transitioning class\n$(document).on(\n  \"transitionend\",\n  `.${Sidebar.classes.LAYOUT} > .collapse-toggle > .collapse-icon`,\n  (e) => {\n    const sidebar = Sidebar.finalizeState(e.target);\n    $(sidebar).trigger(\"toggleCollapse.sidebarInputBinding\");\n  }\n);\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Sidebar = Sidebar;\n"],
  "mappings": "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",
  "names": ["InputBinding", "registerBinding", "inputBindingClass", "name", "doWindowResizeOnElementResize", "el", "resizeEvent", "ro", "_Sidebar", "container", "selectorChildLayouts", "nextSidebarParent", "el", "layouts", "parent", "count", "x", "i", "thisCount", "main", "sidebar", "toggle", "isClosed", "method", "doWindowResizeOnElementResize", "Sidebar", "SidebarInputBinding", "InputBinding", "scope", "value", "callback", "event", "data", "registerBinding", "e"]
}
