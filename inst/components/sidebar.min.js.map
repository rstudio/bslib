{
  "version": 3,
  "sources": ["../../srcts/src/components/_utils.ts", "../../node_modules/arrive/src/arrive.js", "../../srcts/src/components/sidebar.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n};\nexport type { HtmlDep };\n", "/*globals jQuery,Window,HTMLElement,HTMLDocument,HTMLCollection,NodeList,MutationObserver */\n/*exported Arrive*/\n/*jshint latedef:false */\n\n/*\n * arrive.js\n * v2.4.1\n * https://github.com/uzairfarooq/arrive\n * MIT licensed\n *\n * Copyright (c) 2014-2017 Uzair Farooq\n */\nvar Arrive = (function(window, $, undefined) {\n\n  \"use strict\";\n\n  if(!window.MutationObserver || typeof HTMLElement === 'undefined'){\n    return; //for unsupported browsers\n  }\n\n  var arriveUniqueId = 0;\n\n  var utils = (function() {\n    var matches = HTMLElement.prototype.matches || HTMLElement.prototype.webkitMatchesSelector || HTMLElement.prototype.mozMatchesSelector\n                  || HTMLElement.prototype.msMatchesSelector;\n\n    return {\n      matchesSelector: function(elem, selector) {\n        return elem instanceof HTMLElement && matches.call(elem, selector);\n      },\n      // to enable function overloading - By John Resig (MIT Licensed)\n      addMethod: function (object, name, fn) {\n        var old = object[ name ];\n        object[ name ] = function(){\n          if ( fn.length == arguments.length ) {\n            return fn.apply( this, arguments );\n          }\n          else if ( typeof old == 'function' ) {\n            return old.apply( this, arguments );\n          }\n        };\n      },\n      callCallbacks: function(callbacksToBeCalled, registrationData) {\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // as onlyOnce param is true, make sure we fire the event for only one item\n          callbacksToBeCalled = [callbacksToBeCalled[0]];\n        }\n\n        for (var i = 0, cb; (cb = callbacksToBeCalled[i]); i++) {\n          if (cb && cb.callback) {\n            cb.callback.call(cb.elem, cb.elem);\n          }\n        }\n\n        if (registrationData && registrationData.options.onceOnly && registrationData.firedElems.length == 1) {\n          // unbind event after first callback as onceOnly is true.\n          registrationData.me.unbindEventWithSelectorAndCallback.call(\n            registrationData.target, registrationData.selector, registrationData.callback);\n        }\n      },\n      // traverse through all descendants of a node to check if event should be fired for any descendant\n      checkChildNodesRecursively: function(nodes, registrationData, matchFunc, callbacksToBeCalled) {\n        // check each new node if it matches the selector\n        for (var i=0, node; (node = nodes[i]); i++) {\n          if (matchFunc(node, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: node });\n          }\n\n          if (node.childNodes.length > 0) {\n            utils.checkChildNodesRecursively(node.childNodes, registrationData, matchFunc, callbacksToBeCalled);\n          }\n        }\n      },\n      mergeArrays: function(firstArr, secondArr){\n        // Overwrites default options with user-defined options.\n        var options = {},\n            attrName;\n        for (attrName in firstArr) {\n          if (firstArr.hasOwnProperty(attrName)) {\n            options[attrName] = firstArr[attrName];\n          }\n        }\n        for (attrName in secondArr) {\n          if (secondArr.hasOwnProperty(attrName)) {\n            options[attrName] = secondArr[attrName];\n          }\n        }\n        return options;\n      },\n      toElementsArray: function (elements) {\n        // check if object is an array (or array like object)\n        // Note: window object has .length property but it's not array of elements so don't consider it an array\n        if (typeof elements !== \"undefined\" && (typeof elements.length !== \"number\" || elements === window)) {\n          elements = [elements];\n        }\n        return elements;\n      }\n    };\n  })();\n\n\n  // Class to maintain state of all registered events of a single type\n  var EventsBucket = (function() {\n    var EventsBucket = function() {\n      // holds all the events\n\n      this._eventsBucket    = [];\n      // function to be called while adding an event, the function should do the event initialization/registration\n      this._beforeAdding    = null;\n      // function to be called while removing an event, the function should do the event destruction\n      this._beforeRemoving  = null;\n    };\n\n    EventsBucket.prototype.addEvent = function(target, selector, options, callback) {\n      var newEvent = {\n        target:             target,\n        selector:           selector,\n        options:            options,\n        callback:           callback,\n        firedElems:         []\n      };\n\n      if (this._beforeAdding) {\n        this._beforeAdding(newEvent);\n      }\n\n      this._eventsBucket.push(newEvent);\n      return newEvent;\n    };\n\n    EventsBucket.prototype.removeEvent = function(compareFunction) {\n      for (var i=this._eventsBucket.length - 1, registeredEvent; (registeredEvent = this._eventsBucket[i]); i--) {\n        if (compareFunction(registeredEvent)) {\n          if (this._beforeRemoving) {\n              this._beforeRemoving(registeredEvent);\n          }\n\n          // mark callback as null so that even if an event mutation was already triggered it does not call callback\n          var removedEvents = this._eventsBucket.splice(i, 1);\n          if (removedEvents && removedEvents.length) {\n            removedEvents[0].callback = null;\n          }\n        }\n      }\n    };\n\n    EventsBucket.prototype.beforeAdding = function(beforeAdding) {\n      this._beforeAdding = beforeAdding;\n    };\n\n    EventsBucket.prototype.beforeRemoving = function(beforeRemoving) {\n      this._beforeRemoving = beforeRemoving;\n    };\n\n    return EventsBucket;\n  })();\n\n\n  /**\n   * @constructor\n   * General class for binding/unbinding arrive and leave events\n   */\n  var MutationEvents = function(getObserverConfig, onMutation) {\n    var eventsBucket    = new EventsBucket(),\n        me              = this;\n\n    var defaultOptions = {\n      fireOnAttributesModification: false\n    };\n\n    // actual event registration before adding it to bucket\n    eventsBucket.beforeAdding(function(registrationData) {\n      var\n        target    = registrationData.target,\n        observer;\n\n      // mutation observer does not work on window or document\n      if (target === window.document || target === window) {\n        target = document.getElementsByTagName(\"html\")[0];\n      }\n\n      // Create an observer instance\n      observer = new MutationObserver(function(e) {\n        onMutation.call(this, e, registrationData);\n      });\n\n      var config = getObserverConfig(registrationData.options);\n\n      observer.observe(target, config);\n\n      registrationData.observer = observer;\n      registrationData.me = me;\n    });\n\n    // cleanup/unregister before removing an event\n    eventsBucket.beforeRemoving(function (eventData) {\n      eventData.observer.disconnect();\n    });\n\n    this.bindEvent = function(selector, options, callback) {\n      options = utils.mergeArrays(defaultOptions, options);\n\n      var elements = utils.toElementsArray(this);\n\n      for (var i = 0; i < elements.length; i++) {\n        eventsBucket.addEvent(elements[i], selector, options, callback);\n      }\n    };\n\n    this.unbindEvent = function() {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n        for (var i = 0; i < elements.length; i++) {\n          if (this === undefined || eventObj.target === elements[i]) {\n            return true;\n          }\n        }\n        return false;\n      });\n    };\n\n    this.unbindEventWithSelectorOrCallback = function(selector) {\n      var elements = utils.toElementsArray(this),\n          callback = selector,\n          compareFunction;\n\n      if (typeof selector === \"function\") {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      else {\n        compareFunction = function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n      eventsBucket.removeEvent(compareFunction);\n    };\n\n    this.unbindEventWithSelectorAndCallback = function(selector, callback) {\n      var elements = utils.toElementsArray(this);\n      eventsBucket.removeEvent(function(eventObj) {\n          for (var i = 0; i < elements.length; i++) {\n            if ((this === undefined || eventObj.target === elements[i]) && eventObj.selector === selector && eventObj.callback === callback) {\n              return true;\n            }\n          }\n          return false;\n      });\n    };\n\n    return this;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'arrive' events\n   */\n  var ArriveEvents = function() {\n    // Default options for 'arrive' event\n    var arriveDefaultOptions = {\n      fireOnAttributesModification: false,\n      onceOnly: false,\n      existing: false\n    };\n\n    function getArriveObserverConfig(options) {\n      var config = {\n        attributes: false,\n        childList: true,\n        subtree: true\n      };\n\n      if (options.fireOnAttributesModification) {\n        config.attributes = true;\n      }\n\n      return config;\n    }\n\n    function onArriveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var newNodes    = mutation.addedNodes,\n            targetNode = mutation.target,\n            callbacksToBeCalled = [],\n            node;\n\n        // If new nodes are added\n        if( newNodes !== null && newNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(newNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n        else if (mutation.type === \"attributes\") {\n          if (nodeMatchFunc(targetNode, registrationData, callbacksToBeCalled)) {\n            callbacksToBeCalled.push({ callback: registrationData.callback, elem: targetNode });\n          }\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData, callbacksToBeCalled) {\n      // check a single node to see if it matches the selector\n      if (utils.matchesSelector(node, registrationData.selector)) {\n        if(node._id === undefined) {\n          node._id = arriveUniqueId++;\n        }\n        // make sure the arrive event is not already fired for the element\n        if (registrationData.firedElems.indexOf(node._id) == -1) {\n          registrationData.firedElems.push(node._id);\n\n          return true;\n        }\n      }\n\n      return false;\n    }\n\n    arriveEvents = new MutationEvents(getArriveObserverConfig, onArriveMutation);\n\n    var mutationBindEvent = arriveEvents.bindEvent;\n\n    // override bindEvent function\n    arriveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = arriveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(arriveDefaultOptions, options);\n      }\n\n      var elements = utils.toElementsArray(this);\n\n      if (options.existing) {\n        var existing = [];\n\n        for (var i = 0; i < elements.length; i++) {\n          var nodes = elements[i].querySelectorAll(selector);\n          for (var j = 0; j < nodes.length; j++) {\n            existing.push({ callback: callback, elem: nodes[j] });\n          }\n        }\n\n        // no need to bind event if the callback has to be fired only once and we have already found the element\n        if (options.onceOnly && existing.length) {\n          return callback.call(existing[0].elem, existing[0].elem);\n        }\n\n        setTimeout(utils.callCallbacks, 1, existing);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return arriveEvents;\n  };\n\n\n  /**\n   * @constructor\n   * Processes 'leave' events\n   */\n  var LeaveEvents = function() {\n    // Default options for 'leave' event\n    var leaveDefaultOptions = {};\n\n    function getLeaveObserverConfig() {\n      var config = {\n        childList: true,\n        subtree: true\n      };\n\n      return config;\n    }\n\n    function onLeaveMutation(mutations, registrationData) {\n      mutations.forEach(function( mutation ) {\n        var removedNodes  = mutation.removedNodes,\n            callbacksToBeCalled = [];\n\n        if( removedNodes !== null && removedNodes.length > 0 ) {\n          utils.checkChildNodesRecursively(removedNodes, registrationData, nodeMatchFunc, callbacksToBeCalled);\n        }\n\n        utils.callCallbacks(callbacksToBeCalled, registrationData);\n      });\n    }\n\n    function nodeMatchFunc(node, registrationData) {\n      return utils.matchesSelector(node, registrationData.selector);\n    }\n\n    leaveEvents = new MutationEvents(getLeaveObserverConfig, onLeaveMutation);\n\n    var mutationBindEvent = leaveEvents.bindEvent;\n\n    // override bindEvent function\n    leaveEvents.bindEvent = function(selector, options, callback) {\n\n      if (typeof callback === \"undefined\") {\n        callback = options;\n        options = leaveDefaultOptions;\n      } else {\n        options = utils.mergeArrays(leaveDefaultOptions, options);\n      }\n\n      mutationBindEvent.call(this, selector, options, callback);\n    };\n\n    return leaveEvents;\n  };\n\n\n  var arriveEvents = new ArriveEvents(),\n      leaveEvents  = new LeaveEvents();\n\n  function exposeUnbindApi(eventObj, exposeTo, funcName) {\n    // expose unbind function with function overriding\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEvent);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorOrCallback);\n    utils.addMethod(exposeTo, funcName, eventObj.unbindEventWithSelectorAndCallback);\n  }\n\n  /*** expose APIs ***/\n  function exposeApi(exposeTo) {\n    exposeTo.arrive = arriveEvents.bindEvent;\n    exposeUnbindApi(arriveEvents, exposeTo, \"unbindArrive\");\n\n    exposeTo.leave = leaveEvents.bindEvent;\n    exposeUnbindApi(leaveEvents, exposeTo, \"unbindLeave\");\n  }\n\n  if ($) {\n    exposeApi($.fn);\n  }\n  exposeApi(HTMLElement.prototype);\n  exposeApi(NodeList.prototype);\n  exposeApi(HTMLCollection.prototype);\n  exposeApi(HTMLDocument.prototype);\n  exposeApi(Window.prototype);\n\n  var Arrive = {};\n  // expose functions to unbind all arrive/leave events\n  exposeUnbindApi(arriveEvents, Arrive, \"unbindAllArrive\");\n  exposeUnbindApi(leaveEvents, Arrive, \"unbindAllLeave\");\n\n  return Arrive;\n\n})(window, typeof jQuery === 'undefined' ? null : jQuery, undefined);", "import {\n  InputBinding,\n  registerBinding,\n  doWindowResizeOnElementResize,\n} from \"./_utils\";\n\nimport \"arrive\";\n\ntype SidebarMethod = \"close\" | \"open\" | \"toggle\";\n\ntype MessageData = {\n  method: SidebarMethod;\n};\n\ntype SidebarComponents = {\n  container: HTMLElement;\n  main: HTMLElement;\n  sidebar: HTMLElement;\n  toggle: HTMLElement & {\n    handlers?: { start: (ev: MouseEvent) => void; end: () => void };\n  };\n  isClosed: boolean;\n};\n\nclass Sidebar {\n  public static readonly classes = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LAYOUT: \"bslib-sidebar-layout\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    COLLAPSE: \"sidebar-collapsed\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    TRANSITIONING: \"transitioning\",\n  };\n\n  public static initCollapsible(container: HTMLElement): void {\n    // Signal that this layout is initialized by removing the init attribute\n    container.removeAttribute(\"data-bslib-sidebar-init\");\n\n    Sidebar._initEventListeners(container);\n    Sidebar._initSidebarCounters(container);\n    Sidebar._initDesktop(container);\n  }\n\n  private static _initEventListeners(container: HTMLElement): void {\n    const { sidebar, toggle } = Sidebar.components(container);\n\n    // We store a reference to the sidebar toggle event handlers on the toggle\n    // element itself, so that we can remove them later if needed.\n    toggle.handlers = {\n      start: (ev) => {\n        ev.preventDefault();\n        Sidebar.toggle(container, \"toggle\");\n      },\n      end: () => {\n        Sidebar.finalizeState(container);\n        $(sidebar).trigger(\"toggleCollapse.sidebarInputBinding\");\n      },\n    };\n\n    toggle.addEventListener(\"click\", toggle.handlers.start);\n\n    // Once the collapse transition completes (on the collapse toggle icon, which is\n    // always guaranteed to transition), then remove the transitioning class\n    toggle\n      .querySelector(\".collapse-icon\")\n      ?.addEventListener(\"transitionend\", toggle.handlers.end);\n  }\n\n  private static _initSidebarCounters(container: HTMLElement): void {\n    // This function walks up the DOM tree, adding CSS variables to each\n    // direct parent sidebar layout that count the layout's position in the\n    // stack of nested layouts. We use these counters to keep the collapse\n    // toggles from overlapping. Note that always-open sidebars that don't\n    // have collapse toggles break the chain of nesting.\n\n    const selectorChildLayouts =\n      `.${Sidebar.classes.LAYOUT}` +\n      \"> .main > \" +\n      `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`;\n\n    const isInnermostLayout =\n      container.querySelector(selectorChildLayouts) === null;\n\n    if (!isInnermostLayout) {\n      // There are sidebar layouts nested within this layout; defer to children\n      return;\n    }\n\n    function nextSidebarParent(el: HTMLElement | null): HTMLElement | null {\n      el = el ? el.parentElement : null;\n      if (el && el.classList.contains(\"main\")) {\n        // .bslib-sidebar-layout > .main > .bslib-sidedbar-layout\n        el = el.parentElement;\n      }\n      if (el && el.classList.contains(Sidebar.classes.LAYOUT)) {\n        return el;\n      }\n      return null;\n    }\n\n    const layouts = [container];\n    let parent = nextSidebarParent(container);\n\n    while (parent) {\n      // Add parent to front of layouts array, so we sort outer -> inner\n      layouts.unshift(parent);\n      parent = nextSidebarParent(parent);\n    }\n\n    const count = { left: 0, right: 0 };\n    layouts.forEach(function (x: HTMLElement, i: number): void {\n      x.style.setProperty(\"--bslib-sidebar-counter\", i.toString());\n      const isRight = x.classList.contains(\"sidebar-right\");\n      const thisCount = isRight ? count.right++ : count.left++;\n      x.style.setProperty(\n        \"--bslib-sidebar-overlap-counter\",\n        thisCount.toString()\n      );\n    });\n  }\n\n  private static _initDesktop(container: HTMLElement): void {\n    // If sidebar is marked open='desktop'...\n    if (container.dataset.bslibSidebarOpen?.trim() !== \"desktop\") {\n      return;\n    }\n\n    // then close sidebar on mobile\n    const initCollapsed = window\n      .getComputedStyle(container)\n      .getPropertyValue(\"--bslib-sidebar-js-init-collapsed\");\n\n    if (initCollapsed.trim() === \"true\") {\n      Sidebar.toggle(container, \"close\");\n    }\n  }\n\n  private static _findLayoutContainer(el: HTMLElement): HTMLElement {\n    const container = el.closest(`.${Sidebar.classes.LAYOUT}`);\n    if (!container) {\n      throw new Error(\n        `Expected container or direct ancestor with class ${Sidebar.classes.LAYOUT}`\n      );\n    }\n    return container as HTMLElement;\n  }\n\n  public static components(el: HTMLElement): SidebarComponents {\n    el = Sidebar._findLayoutContainer(el);\n\n    // sidebar components\n    const main = el.querySelector(\":scope > .main\") as HTMLElement;\n    const sidebar = el.querySelector(\":scope > .sidebar\") as HTMLElement;\n    const toggle = el.querySelector(\":scope > .collapse-toggle\") as HTMLElement;\n\n    // sidebar state\n    const isClosed = el.classList.contains(Sidebar.classes.COLLAPSE);\n\n    return { container: el, main, sidebar, toggle, isClosed };\n  }\n\n  public static toggle(el: HTMLElement, method: SidebarMethod) {\n    const { container, main, sidebar, isClosed } = Sidebar.components(el);\n\n    if ([\"open\", \"close\", \"toggle\"].indexOf(method) === -1) {\n      throw new Error(`Unknown method ${method}`);\n    }\n\n    if (method === \"toggle\") {\n      method = isClosed ? \"open\" : \"close\";\n    }\n\n    if ((isClosed && method === \"close\") || (!isClosed && method === \"open\")) {\n      // nothing to do, sidebar is already in the desired state\n      return;\n    }\n\n    // Make sure outputs resize properly when the sidebar is opened/closed\n    doWindowResizeOnElementResize(main);\n\n    if (method === \"open\") {\n      // unhide sidebar immediately when opening,\n      // otherwise the sidebar is hidden on transitionend\n      sidebar.hidden = false;\n    }\n\n    // Add a transitioning class just before adding COLLAPSE_CLASS since we want\n    // some of the transitioning styles to apply before the collapse state\n    container.classList.add(Sidebar.classes.TRANSITIONING);\n    container.classList.toggle(Sidebar.classes.COLLAPSE);\n  }\n\n  public static finalizeState(el: HTMLElement, force = false): HTMLElement {\n    const { container, sidebar, toggle, isClosed } = Sidebar.components(el);\n    if (isClosed && !force) {\n      setTimeout(() => Sidebar.finalizeState(el, true), 100);\n    } else {\n      container.classList.remove(Sidebar.classes.TRANSITIONING);\n      sidebar.hidden = isClosed;\n      toggle.ariaExpanded = isClosed ? \"false\" : \"true\";\n    }\n    return sidebar;\n  }\n\n  public static removeEventListeners(el: HTMLElement): void {\n    // If a sidebar layout is removed from the page, we should also clean up any\n    // event listeners that were added to the layout's components.\n    const { toggle } = Sidebar.components(el);\n    if (!toggle.handlers) return;\n    toggle.removeEventListener(\"click\", toggle.handlers.start);\n    toggle\n      .querySelector(\".collapse-icon\")\n      ?.removeEventListener(\"transitionend\", toggle.handlers.end);\n  }\n}\n\nclass SidebarInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(`.${Sidebar.classes.LAYOUT} > .bslib-sidebar-input`);\n  }\n\n  getValue(el: HTMLElement): boolean {\n    return !$(el).parent().hasClass(Sidebar.classes.COLLAPSE);\n  }\n\n  setValue(el: HTMLElement, value: boolean): void {\n    const method = value ? \"open\" : \"close\";\n    this.receiveMessage(el, { method });\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"toggleCollapse.sidebarInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".sidebarInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: MessageData) {\n    Sidebar.toggle(el, data.method);\n  }\n}\n\nregisterBinding(SidebarInputBinding, \"sidebar\");\n\n// Initialize sidebars on page load or when added to the page ----------------\ndocument.arrive(\n  `.${Sidebar.classes.LAYOUT}[data-bslib-sidebar-init]`,\n  (container) => {\n    console.log(\"arrive\", container);\n    Sidebar.initCollapsible(container as HTMLElement);\n  }\n);\n\ndocument.leave(\n  `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`,\n  (container) => {\n    console.log(\"leave\", container);\n    Sidebar.removeEventListeners(container as HTMLElement);\n  }\n);\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Sidebar = Sidebar;\n"],
  "mappings": ";mBAQA,IAAMA,EACJ,OAAO,MAAQ,MAAM,aAAe,KAAM,CAAC,EAG7C,SAASC,EACPC,EACAC,EACM,CACF,OAAO,OACT,MAAM,cAAc,SAAS,IAAID,EAAqB,SAAWC,CAAI,CAEzE,CAqBA,SAASC,EAA8BC,EAAuB,CAC5D,GAAI,EAAEA,CAAE,EAAE,KAAK,wBAAwB,EACrC,OAEF,IAAMC,EAAc,IAAI,MAAM,QAAQ,EAChCC,EAAK,IAAI,eAAe,IAAM,CAClC,OAAO,cAAcD,CAAW,CAClC,CAAC,EACDC,EAAG,QAAQF,CAAE,EACb,EAAEA,CAAE,EAAE,KAAK,yBAA0BE,CAAE,CACzC,CCtCA,IAAIC,EAAU,SAASC,EAAQC,EAAGC,EAAW,CAE3C,aAEA,GAAG,CAACF,EAAO,kBAAoB,OAAO,aAAgB,YACpD,OAGF,IAAIG,EAAiB,EAEjBC,EAAS,UAAW,CACtB,IAAIC,EAAU,YAAY,UAAU,SAAW,YAAY,UAAU,uBAAyB,YAAY,UAAU,oBACnG,YAAY,UAAU,kBAEvC,MAAO,CACL,gBAAiB,SAASC,EAAMC,EAAU,CACxC,OAAOD,aAAgB,aAAeD,EAAQ,KAAKC,EAAMC,CAAQ,CACnE,EAEA,UAAW,SAAUC,EAAQC,EAAMC,EAAI,CACrC,IAAIC,EAAMH,EAAQC,CAAK,EACvBD,EAAQC,CAAK,EAAI,UAAU,CACzB,GAAKC,EAAG,QAAU,UAAU,OAC1B,OAAOA,EAAG,MAAO,KAAM,SAAU,EAE9B,GAAK,OAAOC,GAAO,WACtB,OAAOA,EAAI,MAAO,KAAM,SAAU,CAEtC,CACF,EACA,cAAe,SAASC,EAAqBC,EAAkB,CACzDA,GAAoBA,EAAiB,QAAQ,UAAYA,EAAiB,WAAW,QAAU,IAEjGD,EAAsB,CAACA,EAAoB,CAAC,CAAC,GAG/C,QAASE,EAAI,EAAGC,EAAKA,EAAKH,EAAoBE,CAAC,EAAIA,IAC7CC,GAAMA,EAAG,UACXA,EAAG,SAAS,KAAKA,EAAG,KAAMA,EAAG,IAAI,EAIjCF,GAAoBA,EAAiB,QAAQ,UAAYA,EAAiB,WAAW,QAAU,GAEjGA,EAAiB,GAAG,mCAAmC,KACrDA,EAAiB,OAAQA,EAAiB,SAAUA,EAAiB,QAAQ,CAEnF,EAEA,2BAA4B,SAASG,EAAOH,EAAkBI,EAAWL,EAAqB,CAE5F,QAASE,EAAE,EAAGI,EAAOA,EAAOF,EAAMF,CAAC,EAAIA,IACjCG,EAAUC,EAAML,EAAkBD,CAAmB,GACvDA,EAAoB,KAAK,CAAE,SAAUC,EAAiB,SAAU,KAAMK,CAAK,CAAC,EAG1EA,EAAK,WAAW,OAAS,GAC3Bd,EAAM,2BAA2Bc,EAAK,WAAYL,EAAkBI,EAAWL,CAAmB,CAGxG,EACA,YAAa,SAASO,EAAUC,EAAU,CAExC,IAAIC,EAAU,CAAC,EACXC,EACJ,IAAKA,KAAYH,EACXA,EAAS,eAAeG,CAAQ,IAClCD,EAAQC,CAAQ,EAAIH,EAASG,CAAQ,GAGzC,IAAKA,KAAYF,EACXA,EAAU,eAAeE,CAAQ,IACnCD,EAAQC,CAAQ,EAAIF,EAAUE,CAAQ,GAG1C,OAAOD,CACT,EACA,gBAAiB,SAAUE,EAAU,CAGnC,OAAI,OAAOA,GAAa,cAAgB,OAAOA,EAAS,QAAW,UAAYA,IAAavB,KAC1FuB,EAAW,CAACA,CAAQ,GAEfA,CACT,CACF,CACF,EAAG,EAICC,EAAgB,UAAW,CAC7B,IAAIA,EAAe,UAAW,CAG5B,KAAK,cAAmB,CAAC,EAEzB,KAAK,cAAmB,KAExB,KAAK,gBAAmB,IAC1B,EAEA,OAAAA,EAAa,UAAU,SAAW,SAASC,EAAQlB,EAAUc,EAASK,EAAU,CAC9E,IAAIC,EAAW,CACb,OAAoBF,EACpB,SAAoBlB,EACpB,QAAoBc,EACpB,SAAoBK,EACpB,WAAoB,CAAC,CACvB,EAEA,OAAI,KAAK,eACP,KAAK,cAAcC,CAAQ,EAG7B,KAAK,cAAc,KAAKA,CAAQ,EACzBA,CACT,EAEAH,EAAa,UAAU,YAAc,SAASI,EAAiB,CAC7D,QAAS,EAAE,KAAK,cAAc,OAAS,EAAGC,EAAkBA,EAAkB,KAAK,cAAc,CAAC,EAAI,IACpG,GAAID,EAAgBC,CAAe,EAAG,CAChC,KAAK,iBACL,KAAK,gBAAgBA,CAAe,EAIxC,IAAIC,EAAgB,KAAK,cAAc,OAAO,EAAG,CAAC,EAC9CA,GAAiBA,EAAc,SACjCA,EAAc,CAAC,EAAE,SAAW,KAEhC,CAEJ,EAEAN,EAAa,UAAU,aAAe,SAASO,EAAc,CAC3D,KAAK,cAAgBA,CACvB,EAEAP,EAAa,UAAU,eAAiB,SAASQ,EAAgB,CAC/D,KAAK,gBAAkBA,CACzB,EAEOR,CACT,EAAG,EAOCS,EAAiB,SAASC,EAAmBC,EAAY,CAC3D,IAAIC,EAAkB,IAAIZ,EACtBa,EAAkB,KAElBC,EAAiB,CACnB,6BAA8B,EAChC,EAGA,OAAAF,EAAa,aAAa,SAASvB,EAAkB,CACnD,IACEY,EAAYZ,EAAiB,OAC7B0B,GAGEd,IAAWzB,EAAO,UAAYyB,IAAWzB,KAC3CyB,EAAS,SAAS,qBAAqB,MAAM,EAAE,CAAC,GAIlDc,EAAW,IAAI,iBAAiB,SAASC,EAAG,CAC1CL,EAAW,KAAK,KAAMK,EAAG3B,CAAgB,CAC3C,CAAC,EAED,IAAI4B,EAASP,EAAkBrB,EAAiB,OAAO,EAEvD0B,EAAS,QAAQd,EAAQgB,CAAM,EAE/B5B,EAAiB,SAAW0B,EAC5B1B,EAAiB,GAAKwB,CACxB,CAAC,EAGDD,EAAa,eAAe,SAAUM,EAAW,CAC/CA,EAAU,SAAS,WAAW,CAChC,CAAC,EAED,KAAK,UAAY,SAASnC,EAAUc,EAASK,EAAU,CACrDL,EAAUjB,EAAM,YAAYkC,EAAgBjB,CAAO,EAInD,QAFIE,EAAWnB,EAAM,gBAAgB,IAAI,EAEhCU,EAAI,EAAGA,EAAIS,EAAS,OAAQT,IACnCsB,EAAa,SAASb,EAAST,CAAC,EAAGP,EAAUc,EAASK,CAAQ,CAElE,EAEA,KAAK,YAAc,UAAW,CAC5B,IAAIH,EAAWnB,EAAM,gBAAgB,IAAI,EACzCgC,EAAa,YAAY,SAASO,EAAU,CAC1C,QAAS7B,EAAI,EAAGA,EAAIS,EAAS,OAAQT,IACnC,GAAI,OAASZ,GAAayC,EAAS,SAAWpB,EAAST,CAAC,EACtD,MAAO,GAGX,MAAO,EACT,CAAC,CACH,EAEA,KAAK,kCAAoC,SAASP,EAAU,CAC1D,IAAIgB,EAAWnB,EAAM,gBAAgB,IAAI,EACrCsB,EAAWnB,EACXqB,EAEA,OAAOrB,GAAa,WACtBqB,EAAkB,SAASe,EAAU,CACnC,QAAS7B,EAAI,EAAGA,EAAIS,EAAS,OAAQT,IACnC,IAAK,OAASZ,GAAayC,EAAS,SAAWpB,EAAST,CAAC,IAAM6B,EAAS,WAAajB,EACnF,MAAO,GAGX,MAAO,EACT,EAGAE,EAAkB,SAASe,EAAU,CACnC,QAAS7B,EAAI,EAAGA,EAAIS,EAAS,OAAQT,IACnC,IAAK,OAASZ,GAAayC,EAAS,SAAWpB,EAAST,CAAC,IAAM6B,EAAS,WAAapC,EACnF,MAAO,GAGX,MAAO,EACT,EAEF6B,EAAa,YAAYR,CAAe,CAC1C,EAEA,KAAK,mCAAqC,SAASrB,EAAUmB,EAAU,CACrE,IAAIH,EAAWnB,EAAM,gBAAgB,IAAI,EACzCgC,EAAa,YAAY,SAASO,EAAU,CACxC,QAAS7B,EAAI,EAAGA,EAAIS,EAAS,OAAQT,IACnC,IAAK,OAASZ,GAAayC,EAAS,SAAWpB,EAAST,CAAC,IAAM6B,EAAS,WAAapC,GAAYoC,EAAS,WAAajB,EACrH,MAAO,GAGX,MAAO,EACX,CAAC,CACH,EAEO,IACT,EAOIkB,EAAe,UAAW,CAE5B,IAAIC,EAAuB,CACzB,6BAA8B,GAC9B,SAAU,GACV,SAAU,EACZ,EAEA,SAASC,EAAwBzB,EAAS,CACxC,IAAIoB,EAAS,CACX,WAAY,GACZ,UAAW,GACX,QAAS,EACX,EAEA,OAAIpB,EAAQ,+BACVoB,EAAO,WAAa,IAGfA,CACT,CAEA,SAASM,EAAiBC,EAAWnC,EAAkB,CACrDmC,EAAU,QAAQ,SAAUC,EAAW,CACrC,IAAIC,EAAcD,EAAS,WACvBE,EAAaF,EAAS,OACtBrC,EAAsB,CAAC,EACvBM,EAGAgC,IAAa,MAAQA,EAAS,OAAS,EACzC9C,EAAM,2BAA2B8C,EAAUrC,EAAkBuC,EAAexC,CAAmB,EAExFqC,EAAS,OAAS,cACrBG,EAAcD,EAAYtC,EAAkBD,CAAmB,GACjEA,EAAoB,KAAK,CAAE,SAAUC,EAAiB,SAAU,KAAMsC,CAAW,CAAC,EAItF/C,EAAM,cAAcQ,EAAqBC,CAAgB,CAC3D,CAAC,CACH,CAEA,SAASuC,EAAclC,EAAML,EAAkBD,EAAqB,CAElE,OAAIR,EAAM,gBAAgBc,EAAML,EAAiB,QAAQ,IACpDK,EAAK,MAAQhB,IACdgB,EAAK,IAAMf,KAGTU,EAAiB,WAAW,QAAQK,EAAK,GAAG,GAAK,KACnDL,EAAiB,WAAW,KAAKK,EAAK,GAAG,EAElC,IAIJ,EACT,CAEAmC,EAAe,IAAIpB,EAAea,EAAyBC,CAAgB,EAE3E,IAAIO,EAAoBD,EAAa,UAGrC,OAAAA,EAAa,UAAY,SAAS9C,EAAUc,EAASK,EAAU,CAEzD,OAAOA,GAAa,aACtBA,EAAWL,EACXA,EAAUwB,GAEVxB,EAAUjB,EAAM,YAAYyC,EAAsBxB,CAAO,EAG3D,IAAIE,EAAWnB,EAAM,gBAAgB,IAAI,EAEzC,GAAIiB,EAAQ,SAAU,CAGpB,QAFIkC,EAAW,CAAC,EAEPzC,EAAI,EAAGA,EAAIS,EAAS,OAAQT,IAEnC,QADIE,EAAQO,EAAST,CAAC,EAAE,iBAAiBP,CAAQ,EACxCiD,EAAI,EAAGA,EAAIxC,EAAM,OAAQwC,IAChCD,EAAS,KAAK,CAAE,SAAU7B,EAAU,KAAMV,EAAMwC,CAAC,CAAE,CAAC,EAKxD,GAAInC,EAAQ,UAAYkC,EAAS,OAC/B,OAAO7B,EAAS,KAAK6B,EAAS,CAAC,EAAE,KAAMA,EAAS,CAAC,EAAE,IAAI,EAGzD,WAAWnD,EAAM,cAAe,EAAGmD,CAAQ,CAC7C,CAEAD,EAAkB,KAAK,KAAM/C,EAAUc,EAASK,CAAQ,CAC1D,EAEO2B,CACT,EAOII,EAAc,UAAW,CAE3B,IAAIC,EAAsB,CAAC,EAE3B,SAASC,GAAyB,CAChC,IAAIlB,EAAS,CACX,UAAW,GACX,QAAS,EACX,EAEA,OAAOA,CACT,CAEA,SAASmB,EAAgBZ,EAAWnC,EAAkB,CACpDmC,EAAU,QAAQ,SAAUC,EAAW,CACrC,IAAIY,EAAgBZ,EAAS,aACzBrC,EAAsB,CAAC,EAEvBiD,IAAiB,MAAQA,EAAa,OAAS,GACjDzD,EAAM,2BAA2ByD,EAAchD,EAAkBuC,EAAexC,CAAmB,EAGrGR,EAAM,cAAcQ,EAAqBC,CAAgB,CAC3D,CAAC,CACH,CAEA,SAASuC,EAAclC,EAAML,EAAkB,CAC7C,OAAOT,EAAM,gBAAgBc,EAAML,EAAiB,QAAQ,CAC9D,CAEAiD,EAAc,IAAI7B,EAAe0B,EAAwBC,CAAe,EAExE,IAAIN,EAAoBQ,EAAY,UAGpC,OAAAA,EAAY,UAAY,SAASvD,EAAUc,EAASK,EAAU,CAExD,OAAOA,GAAa,aACtBA,EAAWL,EACXA,EAAUqC,GAEVrC,EAAUjB,EAAM,YAAYsD,EAAqBrC,CAAO,EAG1DiC,EAAkB,KAAK,KAAM/C,EAAUc,EAASK,CAAQ,CAC1D,EAEOoC,CACT,EAGIT,EAAe,IAAIT,EACnBkB,EAAe,IAAIL,EAEvB,SAASM,EAAgBpB,EAAUqB,EAAUC,EAAU,CAErD7D,EAAM,UAAU4D,EAAUC,EAAUtB,EAAS,WAAW,EACxDvC,EAAM,UAAU4D,EAAUC,EAAUtB,EAAS,iCAAiC,EAC9EvC,EAAM,UAAU4D,EAAUC,EAAUtB,EAAS,kCAAkC,CACjF,CAGA,SAASuB,EAAUF,EAAU,CAC3BA,EAAS,OAASX,EAAa,UAC/BU,EAAgBV,EAAcW,EAAU,cAAc,EAEtDA,EAAS,MAAQF,EAAY,UAC7BC,EAAgBD,EAAaE,EAAU,aAAa,CACtD,CAEI/D,GACFiE,EAAUjE,EAAE,EAAE,EAEhBiE,EAAU,YAAY,SAAS,EAC/BA,EAAU,SAAS,SAAS,EAC5BA,EAAU,eAAe,SAAS,EAClCA,EAAU,aAAa,SAAS,EAChCA,EAAU,OAAO,SAAS,EAE1B,IAAInE,EAAS,CAAC,EAEd,OAAAgE,EAAgBV,EAActD,EAAQ,iBAAiB,EACvDgE,EAAgBD,EAAa/D,EAAQ,gBAAgB,EAE9CA,CAET,EAAG,OAAQ,OAAO,QAAW,YAAc,KAAO,OAAQ,MAAS,ECpbnE,IAAMoE,EAAN,KAAc,CAUZ,OAAc,gBAAgBC,EAA8B,CAE1DA,EAAU,gBAAgB,yBAAyB,EAEnDD,EAAQ,oBAAoBC,CAAS,EACrCD,EAAQ,qBAAqBC,CAAS,EACtCD,EAAQ,aAAaC,CAAS,CAChC,CAEA,OAAe,oBAAoBA,EAA8B,CA3CnE,IAAAC,EA4CI,GAAM,CAAE,QAAAC,EAAS,OAAAC,CAAO,EAAIJ,EAAQ,WAAWC,CAAS,EAIxDG,EAAO,SAAW,CAChB,MAAQC,GAAO,CACbA,EAAG,eAAe,EAClBL,EAAQ,OAAOC,EAAW,QAAQ,CACpC,EACA,IAAK,IAAM,CACTD,EAAQ,cAAcC,CAAS,EAC/B,EAAEE,CAAO,EAAE,QAAQ,oCAAoC,CACzD,CACF,EAEAC,EAAO,iBAAiB,QAASA,EAAO,SAAS,KAAK,GAItDF,EAAAE,EACG,cAAc,gBAAgB,IADjC,MAAAF,EAEI,iBAAiB,gBAAiBE,EAAO,SAAS,IACxD,CAEA,OAAe,qBAAqBH,EAA8B,CAOhE,IAAMK,EACJ,IAAIN,EAAQ,QAAQ,oBAEhBA,EAAQ,QAAQ,iDAKtB,GAAI,EAFFC,EAAU,cAAcK,CAAoB,IAAM,MAIlD,OAGF,SAASC,EAAkBC,EAA4C,CAMrE,OALAA,EAAKA,EAAKA,EAAG,cAAgB,KACzBA,GAAMA,EAAG,UAAU,SAAS,MAAM,IAEpCA,EAAKA,EAAG,eAENA,GAAMA,EAAG,UAAU,SAASR,EAAQ,QAAQ,MAAM,EAC7CQ,EAEF,IACT,CAEA,IAAMC,EAAU,CAACR,CAAS,EACtBS,EAASH,EAAkBN,CAAS,EAExC,KAAOS,GAELD,EAAQ,QAAQC,CAAM,EACtBA,EAASH,EAAkBG,CAAM,EAGnC,IAAMC,EAAQ,CAAE,KAAM,EAAG,MAAO,CAAE,EAClCF,EAAQ,QAAQ,SAAUG,EAAgBC,EAAiB,CACzDD,EAAE,MAAM,YAAY,0BAA2BC,EAAE,SAAS,CAAC,EAE3D,IAAMC,EADUF,EAAE,UAAU,SAAS,eAAe,EACxBD,EAAM,QAAUA,EAAM,OAClDC,EAAE,MAAM,YACN,kCACAE,EAAU,SAAS,CACrB,CACF,CAAC,CACH,CAEA,OAAe,aAAab,EAA8B,CAzH5D,IAAAC,EA2HI,KAAIA,EAAAD,EAAU,QAAQ,mBAAlB,YAAAC,EAAoC,UAAW,UACjD,OAIoB,OACnB,iBAAiBD,CAAS,EAC1B,iBAAiB,mCAAmC,EAErC,KAAK,IAAM,QAC3BD,EAAQ,OAAOC,EAAW,OAAO,CAErC,CAEA,OAAe,qBAAqBO,EAA8B,CAChE,IAAMP,EAAYO,EAAG,QAAQ,IAAIR,EAAQ,QAAQ,QAAQ,EACzD,GAAI,CAACC,EACH,MAAM,IAAI,MACR,oDAAoDD,EAAQ,QAAQ,QACtE,EAEF,OAAOC,CACT,CAEA,OAAc,WAAWO,EAAoC,CAC3DA,EAAKR,EAAQ,qBAAqBQ,CAAE,EAGpC,IAAMO,EAAOP,EAAG,cAAc,gBAAgB,EACxCL,EAAUK,EAAG,cAAc,mBAAmB,EAC9CJ,EAASI,EAAG,cAAc,2BAA2B,EAGrDQ,EAAWR,EAAG,UAAU,SAASR,EAAQ,QAAQ,QAAQ,EAE/D,MAAO,CAAE,UAAWQ,EAAI,KAAAO,EAAM,QAAAZ,EAAS,OAAAC,EAAQ,SAAAY,CAAS,CAC1D,CAEA,OAAc,OAAOR,EAAiBS,EAAuB,CAC3D,GAAM,CAAE,UAAAhB,EAAW,KAAAc,EAAM,QAAAZ,EAAS,SAAAa,CAAS,EAAIhB,EAAQ,WAAWQ,CAAE,EAEpE,GAAI,CAAC,OAAQ,QAAS,QAAQ,EAAE,QAAQS,CAAM,IAAM,GAClD,MAAM,IAAI,MAAM,kBAAkBA,GAAQ,EAGxCA,IAAW,WACbA,EAASD,EAAW,OAAS,SAG1B,EAAAA,GAAYC,IAAW,SAAa,CAACD,GAAYC,IAAW,UAMjEC,EAA8BH,CAAI,EAE9BE,IAAW,SAGbd,EAAQ,OAAS,IAKnBF,EAAU,UAAU,IAAID,EAAQ,QAAQ,aAAa,EACrDC,EAAU,UAAU,OAAOD,EAAQ,QAAQ,QAAQ,EACrD,CAEA,OAAc,cAAcQ,EAAiBW,EAAQ,GAAoB,CACvE,GAAM,CAAE,UAAAlB,EAAW,QAAAE,EAAS,OAAAC,EAAQ,SAAAY,CAAS,EAAIhB,EAAQ,WAAWQ,CAAE,EACtE,OAAIQ,GAAY,CAACG,EACf,WAAW,IAAMnB,EAAQ,cAAcQ,EAAI,EAAI,EAAG,GAAG,GAErDP,EAAU,UAAU,OAAOD,EAAQ,QAAQ,aAAa,EACxDG,EAAQ,OAASa,EACjBZ,EAAO,aAAeY,EAAW,QAAU,QAEtCb,CACT,CAEA,OAAc,qBAAqBK,EAAuB,CA5M5D,IAAAN,EA+MI,GAAM,CAAE,OAAAE,CAAO,EAAIJ,EAAQ,WAAWQ,CAAE,EACnCJ,EAAO,WACZA,EAAO,oBAAoB,QAASA,EAAO,SAAS,KAAK,GACzDF,EAAAE,EACG,cAAc,gBAAgB,IADjC,MAAAF,EAEI,oBAAoB,gBAAiBE,EAAO,SAAS,KAC3D,CACF,EA9LMgB,EAANpB,EAAMoB,EACmB,QAAU,CAE/B,OAAQ,uBAER,SAAU,oBAEV,cAAe,eACjB,EAwLF,IAAMC,EAAN,cAAkCC,CAAa,CAC7C,KAAKC,EAAoB,CACvB,OAAO,EAAEA,CAAK,EAAE,KAAK,IAAIH,EAAQ,QAAQ,+BAA+B,CAC1E,CAEA,SAASZ,EAA0B,CACjC,MAAO,CAAC,EAAEA,CAAE,EAAE,OAAO,EAAE,SAASY,EAAQ,QAAQ,QAAQ,CAC1D,CAEA,SAASZ,EAAiBgB,EAAsB,CAC9C,IAAMP,EAASO,EAAQ,OAAS,QAChC,KAAK,eAAehB,EAAI,CAAE,OAAAS,CAAO,CAAC,CACpC,CAEA,UAAUT,EAAiBiB,EAAgC,CACzD,EAAEjB,CAAE,EAAE,GACJ,qCAEA,SAAUkB,EAAO,CACfD,EAAS,EAAI,CACf,CACF,CACF,CAEA,YAAYjB,EAAiB,CAC3B,EAAEA,CAAE,EAAE,IAAI,sBAAsB,CAClC,CAEA,eAAeA,EAAiBmB,EAAmB,CACjDP,EAAQ,OAAOZ,EAAImB,EAAK,MAAM,CAChC,CACF,EAEAC,EAAgBP,EAAqB,SAAS,EAG9C,SAAS,OACP,IAAID,EAAQ,QAAQ,kCACnBnB,GAAc,CACb,QAAQ,IAAI,SAAUA,CAAS,EAC/BmB,EAAQ,gBAAgBnB,CAAwB,CAClD,CACF,EAEA,SAAS,MACP,IAAImB,EAAQ,QAAQ,iDACnBnB,GAAc,CACb,QAAQ,IAAI,QAASA,CAAS,EAC9BmB,EAAQ,qBAAqBnB,CAAwB,CACvD,CACF,EAGC,OAAe,MAAS,OAAe,OAAS,CAAC,EACjD,OAAe,MAAM,QAAUmB",
  "names": ["InputBinding", "registerBinding", "inputBindingClass", "name", "doWindowResizeOnElementResize", "el", "resizeEvent", "ro", "Arrive", "window", "$", "undefined", "arriveUniqueId", "utils", "matches", "elem", "selector", "object", "name", "fn", "old", "callbacksToBeCalled", "registrationData", "i", "cb", "nodes", "matchFunc", "node", "firstArr", "secondArr", "options", "attrName", "elements", "EventsBucket", "target", "callback", "newEvent", "compareFunction", "registeredEvent", "removedEvents", "beforeAdding", "beforeRemoving", "MutationEvents", "getObserverConfig", "onMutation", "eventsBucket", "me", "defaultOptions", "observer", "e", "config", "eventData", "eventObj", "ArriveEvents", "arriveDefaultOptions", "getArriveObserverConfig", "onArriveMutation", "mutations", "mutation", "newNodes", "targetNode", "nodeMatchFunc", "arriveEvents", "mutationBindEvent", "existing", "j", "LeaveEvents", "leaveDefaultOptions", "getLeaveObserverConfig", "onLeaveMutation", "removedNodes", "leaveEvents", "exposeUnbindApi", "exposeTo", "funcName", "exposeApi", "_Sidebar", "container", "_a", "sidebar", "toggle", "ev", "selectorChildLayouts", "nextSidebarParent", "el", "layouts", "parent", "count", "x", "i", "thisCount", "main", "isClosed", "method", "doWindowResizeOnElementResize", "force", "Sidebar", "SidebarInputBinding", "InputBinding", "scope", "value", "callback", "event", "data", "registerBinding"]
}
