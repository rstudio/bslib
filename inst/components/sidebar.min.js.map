{
  "version": 3,
  "sources": ["../../srcts/src/components/_utils.ts", "../../srcts/src/components/sidebar.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n};\nexport type { HtmlDep };\n", "import {\n  InputBinding,\n  registerBinding,\n  doWindowResizeOnElementResize,\n} from \"./_utils\";\n\ntype SidebarMethod = \"close\" | \"open\";\n\ntype MessageData = {\n  method: SidebarMethod | null;\n};\n\ntype SidebarComponents = {\n  container: HTMLElement;\n  main: HTMLElement;\n  sidebar: HTMLElement;\n  toggle: HTMLElement;\n  isClosed: boolean;\n};\n\nclass BslibSidebar {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  public static readonly COLLAPSE_CLASS = \"sidebar-collapsed\";\n\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  public static readonly LAYOUT_CLASS = \"bslib-sidebar-layout\";\n\n  public static initSidebar(el: HTMLElement): void {\n    const container = BslibSidebar._findLayoutContainer(el);\n    // remove script with onload attribute to signal initialization happened\n    container.removeChild(el);\n\n    const childLayouts = container.getElementsByClassName(\n      BslibSidebar.LAYOUT_CLASS\n    );\n\n    if (childLayouts.length > 0) {\n      BslibSidebar._initAutoCollapse(container);\n      return;\n    }\n\n    // This layout is the innermost layout, so we add CSS variables to it, and\n    // any direct ancestor sidebar layouts, that count the number of parent\n    // layouts in this subtree. This is used to ensure the collapse toggles\n    // don't overlap.\n\n    function nextSidebarParent(el: HTMLElement | null): HTMLElement | null {\n      el = el ? el.parentElement : null;\n      if (el && el.classList.contains(\"main\")) {\n        // .bslib-sidebar-layout > .main > .bslib-sidedbar-layout\n        el = el.parentElement;\n      }\n      if (el && el.classList.contains(BslibSidebar.LAYOUT_CLASS)) {\n        return el;\n      }\n      return null;\n    }\n\n    const layouts = [container];\n    let parent = nextSidebarParent(el);\n\n    while (parent) {\n      // Add parent to front of layouts array, so we sort outer -> inner\n      layouts.unshift(parent);\n      parent = nextSidebarParent(el);\n    }\n\n    const count = { left: 0, right: 0 };\n    layouts.forEach(function (x: HTMLElement, i: number): void {\n      x.style.setProperty(\"--bslib-sidebar-counter\", i.toString());\n      const isRight = x.classList.contains(\"sidebar-right\");\n      const thisCount = isRight ? count.right++ : count.left++;\n      x.style.setProperty(\n        \"--bslib-sidebar-overlap-counter\",\n        thisCount.toString()\n      );\n    });\n\n    BslibSidebar._initAutoCollapse(container);\n  }\n\n  private static _initAutoCollapse(container: HTMLElement): void {\n    if (!container.dataset.sidebarInitAutoCollapse) {\n      return;\n    }\n\n    // If sidebar is marked open='desktop', then close sidebar on mobile\n    const initCollapsed = window\n      .getComputedStyle(container)\n      .getPropertyValue(\"--bslib-sidebar-js-init-collapsed\");\n    if (initCollapsed === \"true\") {\n      BslibSidebar.toggleCollapse(container, \"close\");\n    }\n  }\n\n  private static _findLayoutContainer(el: HTMLElement): HTMLElement {\n    if (el.classList.contains(BslibSidebar.LAYOUT_CLASS)) {\n      return el;\n    }\n    const container = el.closest(`.${BslibSidebar.LAYOUT_CLASS}`);\n    if (!container) {\n      throw new Error(\n        `Expected container or direct ancestor with class ${BslibSidebar.LAYOUT_CLASS}`\n      );\n    }\n    return container as HTMLElement;\n  }\n\n  public static sidebarComponents(el: HTMLElement): SidebarComponents {\n    el = BslibSidebar._findLayoutContainer(el);\n\n    // sidebar components\n    const main = el.querySelector(\":scope > .main\") as HTMLElement;\n    const sidebar = el.querySelector(\":scope > .sidebar\") as HTMLElement;\n    const toggle = el.querySelector(\":scope > .collapse-toggle\") as HTMLElement;\n\n    // sidebar state\n    const isClosed = el.classList.contains(BslibSidebar.COLLAPSE_CLASS);\n\n    return { container: el, main, sidebar, toggle, isClosed };\n  }\n\n  public static toggleCollapse(el: HTMLElement, method: SidebarMethod | null) {\n    const { container, main, sidebar, isClosed } =\n      BslibSidebar.sidebarComponents(el);\n\n    if (method === null) {\n      method = isClosed ? \"open\" : \"close\";\n    }\n\n    if (method !== \"open\" && method !== \"close\") {\n      throw new Error(`Unknown method ${method}`);\n    }\n\n    if ((isClosed && method === \"close\") || (!isClosed && method === \"open\")) {\n      // nothing to do, sidebar is already in the desired state\n      return;\n    }\n\n    // Make sure outputs resize properly when the sidebar is opened/closed\n    doWindowResizeOnElementResize(main);\n\n    if (method === \"open\") {\n      // unhide sidebar immediately when opening,\n      // otherwise the sidebar is hidden on transitionend\n      sidebar.hidden = false;\n    }\n\n    // Add a transitioning class just before adding COLLAPSE_CLASS since we want\n    // some of the transitioning styles to apply before the collapse state\n    container.classList.add(\"transitioning\");\n    container.classList.toggle(BslibSidebar.COLLAPSE_CLASS);\n  }\n\n  public static finalizeState(el: HTMLElement): HTMLElement {\n    const { container, sidebar, toggle, isClosed } =\n      BslibSidebar.sidebarComponents(el);\n    container.classList.remove(\"transitioning\");\n    sidebar.hidden = isClosed;\n    toggle.ariaExpanded = isClosed ? \"false\" : \"true\";\n    return sidebar;\n  }\n}\n\nclass SidebarInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(\n      `.${BslibSidebar.LAYOUT_CLASS} > .bslib-sidebar-input`\n    );\n  }\n\n  getValue(el: HTMLElement): boolean {\n    return !$(el).parent().hasClass(BslibSidebar.COLLAPSE_CLASS);\n  }\n\n  setValue(el: HTMLElement, value: boolean): void {\n    const method = value ? \"open\" : \"close\";\n    this.receiveMessage(el, { method });\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"toggleCollapse.sidebarInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".sidebarInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: MessageData) {\n    BslibSidebar.toggleCollapse(el, data.method);\n  }\n}\n\nregisterBinding(SidebarInputBinding, \"sidebar\");\n\n$(document).on(\n  \"click\",\n  `.${BslibSidebar.LAYOUT_CLASS} > .collapse-toggle`,\n  (e) => {\n    e.preventDefault();\n    BslibSidebar.toggleCollapse(e.target, null);\n  }\n);\n\n// Once the collapse transition completes (on the collapse toggle icon, which is\n// always guaranteed to transition), then remove the transitioning class\n$(document).on(\n  \"transitionend\",\n  \".bslib-sidebar-layout > .collapse-toggle > .collapse-icon\",\n  (e) => {\n    const sidebar = BslibSidebar.finalizeState(e.target);\n    $(sidebar).trigger(\"toggleCollapse.sidebarInputBinding\");\n  }\n);\n\n// attach BslibSidebar class to window for global usage\n(window as any).BslibSidebar = BslibSidebar;\n"],
  "mappings": "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",
  "names": ["InputBinding", "registerBinding", "inputBindingClass", "name", "doWindowResizeOnElementResize", "el", "resizeEvent", "ro", "_BslibSidebar", "el", "container", "nextSidebarParent", "layouts", "parent", "count", "x", "i", "thisCount", "main", "sidebar", "toggle", "isClosed", "method", "doWindowResizeOnElementResize", "BslibSidebar", "SidebarInputBinding", "InputBinding", "scope", "value", "callback", "event", "data", "registerBinding", "e"]
}
