{
  "version": 3,
  "sources": ["../../srcts/src/components/_utils.ts", "../../srcts/src/components/_documentObserver.ts", "../../srcts/src/components/sidebar.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n};\nexport type { HtmlDep };\n", "/**\n * The DocumentObserver class creates an observer detecting all DOM changes,\n * watching for added or removed elements (or their children) that match\n * the specified selectors. When a matching element is added or removed, the\n * respective callback function is called. The DocumentObserver is insensitive\n * to when it's instantiated; it always runs `added.callback()` once on the\n * document body (waiting for DOMContentLoaded if necessary) and then starts\n * watching the DOM for added/removed elements.\n */\n\ninterface DocumentObserverConfig {\n  added: {\n    selector: string;\n    callback: (node: HTMLElement) => void;\n  };\n  removed: {\n    selector: string;\n    callback: (node: HTMLElement) => void;\n  };\n}\n\nclass DocumentObserver {\n  private observer: MutationObserver;\n  private config: DocumentObserverConfig;\n\n  constructor(config: DocumentObserverConfig) {\n    const mutationObserverCallback = (mutationsList: MutationRecord[]) => {\n      for (const mutation of mutationsList) {\n        if (mutation.type === \"childList\") {\n          for (const addedNode of mutation.addedNodes) {\n            if (addedNode.nodeType !== Node.ELEMENT_NODE) continue;\n            this._callback(addedNode as HTMLElement, this.config.added);\n          }\n          for (const removedNode of mutation.removedNodes) {\n            if (removedNode.nodeType !== Node.ELEMENT_NODE) continue;\n            this._callback(removedNode as HTMLElement, this.config.removed);\n          }\n        }\n      }\n    };\n\n    this.config = config;\n    this.observer = new MutationObserver(mutationObserverCallback);\n    if (document.readyState === \"complete\") {\n      this.connect();\n    } else {\n      document.addEventListener(\"DOMContentLoaded\", () => this.connect());\n    }\n  }\n\n  private _callback(\n    el: HTMLElement,\n    {\n      selector,\n      callback,\n    }: { selector: string; callback: (node: HTMLElement) => void }\n  ) {\n    const elMatches = el.matches(selector);\n    const hasMatchingChild = el.querySelector(selector);\n    if (!elMatches && !hasMatchingChild) return;\n    if (elMatches) callback(el);\n    if (!hasMatchingChild) return;\n    el.querySelectorAll(selector).forEach((node) =>\n      callback(node as HTMLElement)\n    );\n  }\n\n  connect(): void {\n    this._callback(document.body, this.config.added);\n    console.log(\"connecting observer\");\n    this.observer.observe(document, { childList: true, subtree: true });\n  }\n\n  disconnect(): void {\n    this.observer.disconnect();\n  }\n}\n\nexport { DocumentObserver };\nexport type { DocumentObserverConfig };\n", "import {\n  InputBinding,\n  registerBinding,\n  doWindowResizeOnElementResize,\n} from \"./_utils\";\n\nimport { DocumentObserver } from \"./_documentObserver\";\n\ntype SidebarMethod = \"close\" | \"open\" | \"toggle\";\n\ntype MessageData = {\n  method: SidebarMethod;\n};\n\ntype SidebarComponents = {\n  container: HTMLElement;\n  main: HTMLElement;\n  sidebar: HTMLElement;\n  toggle: HTMLElement & {\n    handlers?: { start: (ev: MouseEvent) => void; end: () => void };\n  };\n  isClosed: boolean;\n};\n\nclass Sidebar {\n  public static readonly classes = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LAYOUT: \"bslib-sidebar-layout\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    COLLAPSE: \"sidebar-collapsed\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    TRANSITIONING: \"transitioning\",\n  };\n\n  public static initCollapsible(container: HTMLElement): void {\n    // Signal that this layout is initialized by removing the init attribute\n    container.removeAttribute(\"data-bslib-sidebar-init\");\n\n    Sidebar._initEventListeners(container);\n    Sidebar._initSidebarCounters(container);\n    Sidebar._initDesktop(container);\n  }\n\n  private static _initEventListeners(container: HTMLElement): void {\n    const { sidebar, toggle } = Sidebar.components(container);\n\n    // We store a reference to the sidebar toggle event handlers on the toggle\n    // element itself, so that we can remove them later if needed.\n    toggle.handlers = {\n      start: (ev) => {\n        ev.preventDefault();\n        Sidebar.toggle(container, \"toggle\");\n      },\n      end: () => {\n        Sidebar.finalizeState(container);\n        $(sidebar).trigger(\"toggleCollapse.sidebarInputBinding\");\n      },\n    };\n\n    toggle.addEventListener(\"click\", toggle.handlers.start);\n\n    // Once the collapse transition completes (on the collapse toggle icon, which is\n    // always guaranteed to transition), then remove the transitioning class\n    toggle\n      .querySelector(\".collapse-icon\")\n      ?.addEventListener(\"transitionend\", toggle.handlers.end);\n  }\n\n  private static _initSidebarCounters(container: HTMLElement): void {\n    // This function walks up the DOM tree, adding CSS variables to each\n    // direct parent sidebar layout that count the layout's position in the\n    // stack of nested layouts. We use these counters to keep the collapse\n    // toggles from overlapping. Note that always-open sidebars that don't\n    // have collapse toggles break the chain of nesting.\n\n    const selectorChildLayouts =\n      `.${Sidebar.classes.LAYOUT}` +\n      \"> .main > \" +\n      `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`;\n\n    const isInnermostLayout =\n      container.querySelector(selectorChildLayouts) === null;\n\n    if (!isInnermostLayout) {\n      // There are sidebar layouts nested within this layout; defer to children\n      return;\n    }\n\n    function nextSidebarParent(el: HTMLElement | null): HTMLElement | null {\n      el = el ? el.parentElement : null;\n      if (el && el.classList.contains(\"main\")) {\n        // .bslib-sidebar-layout > .main > .bslib-sidedbar-layout\n        el = el.parentElement;\n      }\n      if (el && el.classList.contains(Sidebar.classes.LAYOUT)) {\n        return el;\n      }\n      return null;\n    }\n\n    const layouts = [container];\n    let parent = nextSidebarParent(container);\n\n    while (parent) {\n      // Add parent to front of layouts array, so we sort outer -> inner\n      layouts.unshift(parent);\n      parent = nextSidebarParent(parent);\n    }\n\n    const count = { left: 0, right: 0 };\n    layouts.forEach(function (x: HTMLElement, i: number): void {\n      x.style.setProperty(\"--bslib-sidebar-counter\", i.toString());\n      const isRight = x.classList.contains(\"sidebar-right\");\n      const thisCount = isRight ? count.right++ : count.left++;\n      x.style.setProperty(\n        \"--bslib-sidebar-overlap-counter\",\n        thisCount.toString()\n      );\n    });\n  }\n\n  private static _initDesktop(container: HTMLElement): void {\n    // If sidebar is marked open='desktop'...\n    if (container.dataset.bslibSidebarOpen?.trim() !== \"desktop\") {\n      return;\n    }\n\n    // then close sidebar on mobile\n    const initCollapsed = window\n      .getComputedStyle(container)\n      .getPropertyValue(\"--bslib-sidebar-js-init-collapsed\");\n\n    if (initCollapsed.trim() === \"true\") {\n      Sidebar.toggle(container, \"close\");\n    }\n  }\n\n  private static _findLayoutContainer(el: HTMLElement): HTMLElement {\n    const container = el.closest(`.${Sidebar.classes.LAYOUT}`);\n    if (!container) {\n      throw new Error(\n        `Expected container or direct ancestor with class ${Sidebar.classes.LAYOUT}`\n      );\n    }\n    return container as HTMLElement;\n  }\n\n  public static components(el: HTMLElement): SidebarComponents {\n    el = Sidebar._findLayoutContainer(el);\n\n    // sidebar components\n    const main = el.querySelector(\":scope > .main\") as HTMLElement;\n    const sidebar = el.querySelector(\":scope > .sidebar\") as HTMLElement;\n    const toggle = el.querySelector(\":scope > .collapse-toggle\") as HTMLElement;\n\n    // sidebar state\n    const isClosed = el.classList.contains(Sidebar.classes.COLLAPSE);\n\n    return { container: el, main, sidebar, toggle, isClosed };\n  }\n\n  public static toggle(el: HTMLElement, method: SidebarMethod) {\n    const { container, main, sidebar, isClosed } = Sidebar.components(el);\n\n    if ([\"open\", \"close\", \"toggle\"].indexOf(method) === -1) {\n      throw new Error(`Unknown method ${method}`);\n    }\n\n    if (method === \"toggle\") {\n      method = isClosed ? \"open\" : \"close\";\n    }\n\n    if ((isClosed && method === \"close\") || (!isClosed && method === \"open\")) {\n      // nothing to do, sidebar is already in the desired state\n      return;\n    }\n\n    // Make sure outputs resize properly when the sidebar is opened/closed\n    doWindowResizeOnElementResize(main);\n\n    if (method === \"open\") {\n      // unhide sidebar immediately when opening,\n      // otherwise the sidebar is hidden on transitionend\n      sidebar.hidden = false;\n    }\n\n    // Add a transitioning class just before adding COLLAPSE_CLASS since we want\n    // some of the transitioning styles to apply before the collapse state\n    container.classList.add(Sidebar.classes.TRANSITIONING);\n    container.classList.toggle(Sidebar.classes.COLLAPSE);\n  }\n\n  public static finalizeState(el: HTMLElement, force = false): HTMLElement {\n    const { container, sidebar, toggle, isClosed } = Sidebar.components(el);\n    if (isClosed && !force) {\n      setTimeout(() => Sidebar.finalizeState(el, true), 100);\n    } else {\n      container.classList.remove(Sidebar.classes.TRANSITIONING);\n      sidebar.hidden = isClosed;\n      toggle.ariaExpanded = isClosed ? \"false\" : \"true\";\n    }\n    return sidebar;\n  }\n\n  public static removeEventListeners(el: HTMLElement): void {\n    // If a sidebar layout is removed from the page, we should also clean up any\n    // event listeners that were added to the layout's components.\n    const { toggle } = Sidebar.components(el);\n    if (!toggle.handlers) return;\n    toggle.removeEventListener(\"click\", toggle.handlers.start);\n    toggle\n      .querySelector(\".collapse-icon\")\n      ?.removeEventListener(\"transitionend\", toggle.handlers.end);\n  }\n}\n\nclass SidebarInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(`.${Sidebar.classes.LAYOUT} > .bslib-sidebar-input`);\n  }\n\n  getValue(el: HTMLElement): boolean {\n    return !$(el).parent().hasClass(Sidebar.classes.COLLAPSE);\n  }\n\n  setValue(el: HTMLElement, value: boolean): void {\n    const method = value ? \"open\" : \"close\";\n    this.receiveMessage(el, { method });\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"toggleCollapse.sidebarInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".sidebarInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: MessageData) {\n    Sidebar.toggle(el, data.method);\n  }\n}\n\nregisterBinding(SidebarInputBinding, \"sidebar\");\n\n// Initialize sidebars on page load or when added to the page ----------------\nconst observer = new DocumentObserver({\n  added: {\n    selector: `.${Sidebar.classes.LAYOUT}[data-bslib-sidebar-init]`,\n    callback: (container) => {\n      console.log(\"added\", container);\n      Sidebar.initCollapsible(container as HTMLElement);\n    },\n  },\n  removed: {\n    selector: `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`,\n    callback: (container) => {\n      console.log(\"removed\", container);\n      Sidebar.removeEventListeners(container as HTMLElement);\n    },\n  },\n});\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Sidebar = Sidebar;\n(window as any).bslib.SidebarObserver = observer;\n"],
  "mappings": "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",
  "names": ["InputBinding", "registerBinding", "inputBindingClass", "name", "doWindowResizeOnElementResize", "el", "resizeEvent", "ro", "DocumentObserver", "config", "mutationObserverCallback", "mutationsList", "mutation", "addedNode", "removedNode", "el", "selector", "callback", "elMatches", "hasMatchingChild", "node", "_Sidebar", "container", "_a", "sidebar", "toggle", "ev", "selectorChildLayouts", "nextSidebarParent", "el", "layouts", "parent", "count", "x", "i", "thisCount", "main", "isClosed", "method", "doWindowResizeOnElementResize", "force", "Sidebar", "SidebarInputBinding", "InputBinding", "scope", "value", "callback", "event", "data", "registerBinding", "observer", "DocumentObserver"]
}
