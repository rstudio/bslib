{
  "version": 3,
  "sources": ["../../srcts/src/components/_utils.ts", "../../srcts/src/components/sidebar.ts"],
  "sourcesContent": ["import type { HtmlDep } from \"rstudio-shiny/srcts/types/src/shiny/render\";\n\nimport type { InputBinding as InputBindingType } from \"rstudio-shiny/srcts/types/src/bindings/input\";\n\n// Exclude undefined from T\ntype NotUndefined<T> = T extends undefined ? never : T;\n\n// eslint-disable-next-line @typescript-eslint/naming-convention\nconst InputBinding = (\n  window.Shiny ? Shiny.InputBinding : class {}\n) as typeof InputBindingType;\n\nfunction registerBinding(\n  inputBindingClass: new () => InputBindingType,\n  name: string\n): void {\n  if (window.Shiny) {\n    Shiny.inputBindings.register(new inputBindingClass(), \"bslib.\" + name);\n  }\n}\n\n// Return true if the key exists on the object and the value is not undefined.\n//\n// This method is mainly used in input bindings' `receiveMessage` method.\n// Since we know that the values are sent by Shiny via `{jsonlite}`,\n// then we know that there are no `undefined` values. `null` is possible, but not `undefined`.\nfunction hasDefinedProperty<\n  Prop extends keyof X,\n  X extends { [key: string]: any }\n>(\n  obj: X,\n  prop: Prop\n): obj is X & { [key in NonNullable<Prop>]: NotUndefined<X[key]> } {\n  return (\n    Object.prototype.hasOwnProperty.call(obj, prop) && obj[prop] !== undefined\n  );\n}\n\n// TODO: Shiny should trigger resize events when the output\n// https://github.com/rstudio/shiny/pull/3682\nfunction doWindowResizeOnElementResize(el: HTMLElement): void {\n  if ($(el).data(\"window-resize-observer\")) {\n    return;\n  }\n  const resizeEvent = new Event(\"resize\");\n  const ro = new ResizeObserver(() => {\n    window.dispatchEvent(resizeEvent);\n  });\n  ro.observe(el);\n  $(el).data(\"window-resize-observer\", ro);\n}\n\nexport {\n  InputBinding,\n  registerBinding,\n  hasDefinedProperty,\n  doWindowResizeOnElementResize,\n};\nexport type { HtmlDep };\n", "import {\n  InputBinding,\n  registerBinding,\n  doWindowResizeOnElementResize,\n} from \"./_utils\";\n\ntype SidebarMethod = \"close\" | \"open\" | \"toggle\";\n\ntype MessageData = {\n  method: SidebarMethod;\n};\n\ninterface SidebarComponents {\n  container: HTMLElement;\n  main: HTMLElement;\n  sidebar: HTMLElement;\n  toggle: HTMLElement;\n}\n\nclass Sidebar {\n  private layout: SidebarComponents;\n  #isClosed = false;\n\n  constructor(container: HTMLElement) {\n    container.removeAttribute(\"data-bslib-sidebar-init\");\n\n    Sidebar.instanceMap.set(container, this);\n    this.layout = {\n      container,\n      main: container.querySelector(\":scope > .main\") as HTMLElement,\n      sidebar: container.querySelector(\":scope > .sidebar\") as HTMLElement,\n      toggle: container.querySelector(\n        \":scope > .collapse-toggle\"\n      ) as HTMLElement,\n    } as SidebarComponents;\n\n    if (!this.layout.toggle) {\n      throw new Error(\"Tried to initialize a non-collapsible sidebar.\");\n    }\n\n    this.#isClosed = this._isClosedOrClosing();\n\n    this._initEventListeners();\n    this._initSidebarCounters();\n    this._initDesktop();\n  }\n\n  get isClosed(): boolean {\n    return this.#isClosed;\n  }\n\n  private _isClosedOrClosing(): boolean {\n    // While in the middle of toggling, the user may want to reverse course\n    return this.layout.container.classList.contains(Sidebar.classes.COLLAPSE);\n  }\n\n  public static readonly classes = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    LAYOUT: \"bslib-sidebar-layout\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    COLLAPSE: \"sidebar-collapsed\",\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    TRANSITIONING: \"transitioning\",\n  };\n\n  private static onReadyScheduled = false;\n  private static instanceMap: WeakMap<HTMLElement, Sidebar> = new WeakMap();\n\n  public static getInstance(el: HTMLElement): Sidebar | undefined {\n    return Sidebar.instanceMap.get(el);\n  }\n\n  public static initCollapsibleAll(scope: Document | HTMLElement): void {\n    if (document.readyState === \"loading\") {\n      if (!Sidebar.onReadyScheduled) {\n        Sidebar.onReadyScheduled = true;\n        document.addEventListener(\"DOMContentLoaded\", () =>\n          Sidebar.initCollapsibleAll(document)\n        );\n      }\n      return;\n    }\n\n    const initSelector = \"[data-bslib-sidebar-init]\";\n    let scopeMatches = false;\n    if (scope instanceof HTMLElement) {\n      scopeMatches = scope.matches(initSelector);\n    }\n    if (!(scopeMatches || scope.querySelector(initSelector))) {\n      // no sidebars to initialize\n      return;\n    }\n\n    const containers = Array.from(scope.querySelectorAll(initSelector));\n    if (scopeMatches && scope instanceof HTMLElement) {\n      containers.unshift(scope);\n    }\n\n    containers.forEach((container) => new Sidebar(container as HTMLElement));\n  }\n\n  private _initEventListeners(): void {\n    const { sidebar, toggle } = this.layout;\n\n    toggle.addEventListener(\"click\", (ev) => {\n      ev.preventDefault();\n      this.toggle(\"toggle\");\n    });\n\n    // Once the collapse transition completes (on the collapse toggle icon, which is\n    // always guaranteed to transition), then remove the transitioning class\n    toggle\n      .querySelector(\".collapse-icon\")\n      ?.addEventListener(\"transitionend\", () => {\n        setTimeout(\n          () => {\n            this._finalizeState();\n            $(sidebar).trigger(\"toggleCollapse.sidebarInputBinding\");\n          },\n          // Add a small delay before finalizing the closed state, otherwise\n          // this happens just before the sidebar reaches the final state and\n          // the sidebar disappears abruptly.\n          this.isClosed ? 100 : 0\n        );\n      });\n  }\n\n  private _initSidebarCounters(): void {\n    // This function walks up the DOM tree, adding CSS variables to each\n    // direct parent sidebar layout that count the layout's position in the\n    // stack of nested layouts. We use these counters to keep the collapse\n    // toggles from overlapping. Note that always-open sidebars that don't\n    // have collapse toggles break the chain of nesting.\n    const { container } = this.layout;\n\n    const selectorChildLayouts =\n      `.${Sidebar.classes.LAYOUT}` +\n      \"> .main > \" +\n      `.${Sidebar.classes.LAYOUT}:not([data-bslib-sidebar-open=\"always\"])`;\n\n    const isInnermostLayout =\n      container.querySelector(selectorChildLayouts) === null;\n\n    if (!isInnermostLayout) {\n      // There are sidebar layouts nested within this layout; defer to children\n      return;\n    }\n\n    function nextSidebarParent(el: HTMLElement | null): HTMLElement | null {\n      el = el ? el.parentElement : null;\n      if (el && el.classList.contains(\"main\")) {\n        // .bslib-sidebar-layout > .main > .bslib-sidedbar-layout\n        el = el.parentElement;\n      }\n      if (el && el.classList.contains(Sidebar.classes.LAYOUT)) {\n        return el;\n      }\n      return null;\n    }\n\n    const layouts = [container];\n    let parent = nextSidebarParent(container);\n\n    while (parent) {\n      // Add parent to front of layouts array, so we sort outer -> inner\n      layouts.unshift(parent);\n      parent = nextSidebarParent(parent);\n    }\n\n    const count = { left: 0, right: 0 };\n    layouts.forEach(function (x: HTMLElement, i: number): void {\n      x.style.setProperty(\"--bslib-sidebar-counter\", i.toString());\n      const isRight = x.classList.contains(\"sidebar-right\");\n      const thisCount = isRight ? count.right++ : count.left++;\n      x.style.setProperty(\n        \"--bslib-sidebar-overlap-counter\",\n        thisCount.toString()\n      );\n    });\n  }\n\n  private _initDesktop(): void {\n    const { container } = this.layout;\n    // If sidebar is marked open='desktop'...\n    if (container.dataset.bslibSidebarOpen?.trim() !== \"desktop\") {\n      return;\n    }\n\n    // then close sidebar on mobile\n    const initCollapsed = window\n      .getComputedStyle(container)\n      .getPropertyValue(\"--bslib-sidebar-js-init-collapsed\");\n\n    if (initCollapsed.trim() === \"true\") {\n      this.toggle(\"close\");\n    }\n  }\n\n  public toggle(method: SidebarMethod) {\n    const { container, main, sidebar } = this.layout;\n    const isClosed = this._isClosedOrClosing();\n\n    if ([\"open\", \"close\", \"toggle\"].indexOf(method) === -1) {\n      throw new Error(`Unknown method ${method}`);\n    }\n\n    if (method === \"toggle\") {\n      method = isClosed ? \"open\" : \"close\";\n    }\n\n    if ((isClosed && method === \"close\") || (!isClosed && method === \"open\")) {\n      // nothing to do, sidebar is already in the desired state\n      return;\n    }\n\n    // Make sure outputs resize properly when the sidebar is opened/closed\n    doWindowResizeOnElementResize(main);\n\n    if (method === \"open\") {\n      // unhide sidebar immediately when opening,\n      // otherwise the sidebar is hidden on transitionend\n      sidebar.hidden = false;\n    }\n\n    // Add a transitioning class just before adding COLLAPSE_CLASS since we want\n    // some of the transitioning styles to apply before the collapse state\n    container.classList.add(Sidebar.classes.TRANSITIONING);\n    container.classList.toggle(Sidebar.classes.COLLAPSE);\n  }\n\n  private _finalizeState(): void {\n    const { container, sidebar, toggle } = this.layout;\n    container.classList.remove(Sidebar.classes.TRANSITIONING);\n    this.#isClosed = container.classList.contains(Sidebar.classes.COLLAPSE);\n    sidebar.hidden = this.#isClosed;\n    toggle.ariaExpanded = this.#isClosed ? \"false\" : \"true\";\n  }\n}\n\nclass SidebarInputBinding extends InputBinding {\n  find(scope: HTMLElement) {\n    return $(scope).find(`.${Sidebar.classes.LAYOUT} > .bslib-sidebar-input`);\n  }\n\n  getValue(el: HTMLElement): boolean {\n    const sb = Sidebar.getInstance(el.parentElement as HTMLElement);\n    return sb ? sb.isClosed : false;\n  }\n\n  setValue(el: HTMLElement, value: boolean): void {\n    const method = value ? \"open\" : \"close\";\n    this.receiveMessage(el, { method });\n  }\n\n  subscribe(el: HTMLElement, callback: (x: boolean) => void) {\n    $(el).on(\n      \"toggleCollapse.sidebarInputBinding\",\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      function (event) {\n        callback(true);\n      }\n    );\n  }\n\n  unsubscribe(el: HTMLElement) {\n    $(el).off(\".sidebarInputBinding\");\n  }\n\n  receiveMessage(el: HTMLElement, data: MessageData) {\n    const sb = Sidebar.getInstance(el.parentElement as HTMLElement);\n    if (sb) sb.toggle(data.method);\n  }\n}\n\nregisterBinding(SidebarInputBinding, \"sidebar\");\n\n// attach Sidebar class to window for global usage\n(window as any).bslib = (window as any).bslib || {};\n(window as any).bslib.Sidebar = Sidebar;\n"],
  "mappings": "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",
  "names": ["InputBinding", "registerBinding", "inputBindingClass", "name", "doWindowResizeOnElementResize", "el", "resizeEvent", "ro", "_isClosed", "_Sidebar", "container", "__privateAdd", "__privateSet", "__privateGet", "el", "scope", "initSelector", "scopeMatches", "containers", "_a", "sidebar", "toggle", "ev", "selectorChildLayouts", "nextSidebarParent", "layouts", "parent", "count", "x", "i", "thisCount", "method", "main", "isClosed", "doWindowResizeOnElementResize", "Sidebar", "SidebarInputBinding", "InputBinding", "sb", "value", "callback", "event", "data", "registerBinding"]
}
